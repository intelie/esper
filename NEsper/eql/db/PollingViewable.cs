using System;
using System.Collections.Generic;

using net.esper.client;
using net.esper.compat;
using net.esper.eql.core;
using net.esper.eql.expression;
using net.esper.events;
using net.esper.view;

namespace net.esper.eql.db
{
    /// <summary>
    /// Implements a poller viewable that uses a polling strategy, a cache and
    /// some input parameters extracted from event streams to perform the polling.
    /// </summary>

    public class PollingViewable : HistoricalEventViewable
    {
        private readonly int myStreamNumber;
        private readonly PollExecStrategy pollExecStrategy;
        private readonly IList<String> inputParameters;
        private readonly DataCache dataCache;
        private readonly EventType eventType;

        private EventPropertyGetter[] getters;
        private int[] getterStreamNumbers;

        /// <summary> Ctor.</summary>
        /// <param name="myStreamNumber">is the stream number of the view
        /// </param>
        /// <param name="inputParameters">are the event property names providing input parameter keys
        /// </param>
        /// <param name="pollExecStrategy">is the strategy to use for retrieving results
        /// </param>
        /// <param name="dataCache">is looked up before using the strategy
        /// </param>
        /// <param name="eventType">is the type of events generated by the view
        /// </param>

        public PollingViewable(
            int myStreamNumber,
            IList<String> inputParameters,
            PollExecStrategy pollExecStrategy,
            DataCache dataCache,
            EventType eventType)
        {
            this.myStreamNumber = myStreamNumber;
            this.inputParameters = inputParameters;
            this.pollExecStrategy = pollExecStrategy;
            this.dataCache = dataCache;
            this.eventType = eventType;
        }

        public virtual void Stop()
        {
            pollExecStrategy.destroy();
        }

        public virtual void validate(StreamTypeService streamTypeService)
        {
            getters = new EventPropertyGetter[inputParameters.Count];
            getterStreamNumbers = new int[inputParameters.Count];

            int count = 0;
            foreach (String inputParam in inputParameters)
            {
                PropertyResolutionDescriptor desc = null;

                // try to resolve the property name alone
                try
                {
                    desc = streamTypeService.resolveByStreamAndPropName(inputParam);
                }
                catch (StreamTypesException ex)
                {
                    throw new ExprValidationException("Property '" + inputParam + "' failed to resolve, reason: " + ex.Message);
                }

                // hold on to getter and stream number for each stream
                int streamId = desc.StreamNum;
                if (streamId == myStreamNumber)
                {
                    throw new ExprValidationException("Invalid property '" + inputParam + "' resolves to the historical data itself");
                }
                String propName = desc.PropertyName;
                getters[count] = streamTypeService.EventTypes[streamId].GetGetter(propName);
                getterStreamNumbers[count] = streamId;

                count++;
            }
        }

        public IList<EventBean>[] poll(EventBean[][] lookupEventsPerStream)
        {
            pollExecStrategy.Start();

            IList<EventBean>[] resultPerInputRow = new ELinkedList<EventBean>[lookupEventsPerStream.Length];

            // Get input parameters for each row
            for (int row = 0; row < lookupEventsPerStream.Length; row++)
            {
                Object[] lookupValues = new Object[inputParameters.Count];

                // Build lookup keys
                for (int valueNum = 0; valueNum < inputParameters.Count; valueNum++)
                {
                    int streamNum = getterStreamNumbers[valueNum];
                    EventBean streamEvent = lookupEventsPerStream[row][streamNum];
                    Object lookupValue = getters[valueNum].GetValue(streamEvent);
                    lookupValues[valueNum] = lookupValue;
                }

                // Get the result from cache
				IList<EventBean> result = dataCache.GetCached( lookupValues );
                if (result != null)
                // found in cache
                {
                    resultPerInputRow[row] = result;
                }
                // not found in cache, get from actual polling (db query)
                else
                {
                    try
                    {
                        result = pollExecStrategy.poll(lookupValues);
                        resultPerInputRow[row] = result;
                        dataCache.PutCached(lookupValues, result);
                    }
                    catch (EPException ex)
                    {
                        pollExecStrategy.done();
                        throw ex;
                    }
                }
            }

            pollExecStrategy.done();

            return resultPerInputRow;
        }

        public virtual View AddView(View view)
        {
            return view;
        }

        public IList<View> GetViews()
        {
            throw new NotSupportedException("Subviews not supported");
        }

        public virtual bool RemoveView(View view)
        {
            throw new NotSupportedException("Subviews not supported");
        }

        public virtual bool HasViews()
        {
            return false;
        }

        public virtual EventType EventType
        {
            get { return eventType; }
        }

        public IEnumerator<EventBean> GetEnumerator()
        {
            throw new NotSupportedException("Iterator not supported");
        }

        #region IEnumerable Members

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        #endregion
    }
}
