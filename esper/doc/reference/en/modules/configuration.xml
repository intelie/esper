<chapter id="configuration" revision="1">

    <title>Configuration</title>
    
	<indexterm><primary>configuration</primary><secondary>overview</secondary></indexterm>
	<indexterm><primary>Configuration class</primary></indexterm>
    <para>
        Esper engine configuration is entirely optional. Esper has a very small number of configuration parameters that can be used to simplify event 
        pattern and EPL statements, and to tune the engine behavior to specific requirements. The Esper engine works out-of-the-box without configuration.
    </para>

    <para>
        An application can supply configuration at the time of engine allocation using the <literal>Configuration</literal> class, and can also use XML files to hold configuration. Configuration can be changed at runtime
        via the <literal>ConfigurationOperations</literal> interface available from <literal>EPAdministrator</literal> via the <literal>getConfiguration</literal> method.
    </para>
    
    <para>
		The difference between using a <literal>Configuration</literal> object and the <literal>ConfigurationOperations</literal> interface is that for the latter, all configuration including event types added through that interface are considered runtime configurations. 
		This means they will be discarded when calling the <literal>initialize</literal> method on an <literal>EPServiceProvider</literal> instance.
    </para>

    <sect1 id="configuration-programmatic" revision="1">
        <title>Programmatic Configuration</title>

	<indexterm><primary>configuration</primary><secondary>programmatic</secondary></indexterm>
        <para>
            An instance of <literal>com.espertech.esper.client.Configuration</literal> represents all configuration parameters. The <literal>Configuration</literal> is used to build an <literal>EPServiceProvider</literal>, which provides the administrative and runtime interfaces for an Esper engine instance.
        </para>

        <para>
            You may obtain a <literal>Configuration</literal> instance by instantiating it directly and adding or setting values on it. The <literal>Configuration</literal> instance is then passed to <literal>EPServiceProviderManager</literal> to obtain a configured Esper engine.
        </para>

		<programlisting><![CDATA[Configuration configuration = new Configuration();
configuration.addEventType("PriceLimit", PriceLimit.class.getName());
configuration.addEventType("StockTick", StockTick.class.getName());
configuration.addImport("org.mycompany.mypackage.MyUtility");
configuration.addImport("org.mycompany.util.*");

EPServiceProvider epService = EPServiceProviderManager.getProvider("sample", configuration);
]]></programlisting>

        <para>
			Note that <literal>Configuration</literal> is meant only as an initialization-time object. The Esper engine represented by an <literal>EPServiceProvider</literal> does not retain any association back to the <literal>Configuration</literal>.
        </para>
        
        <para>
			The <literal>ConfigurationOperations</literal> interface provides runtime configuration options as further described in <xref linkend="api-admin-runtime-config"/>. Through this interface applications can, for example, add new event types at runtime and then create new statements
			that rely on the additional configuration. The <literal>getConfiguration</literal> method on <literal>EPAdministrator</literal> allows access to <literal>ConfigurationOperations</literal>.
        </para>

    </sect1>

	<sect1 id="configuration-via-xml" revision="1">
        <title>Configuration via XML File</title>

		<indexterm><primary>configuration</primary><secondary>via XML</secondary></indexterm>
        <para>
			An alternative approach to configuration is to specify a configuration in a XML file. 
        </para>

        <para>
			The default name for the XML configuration file is <literal>esper.cfg.xml</literal>. Esper reads this file from the root of the <literal>CLASSPATH</literal> as an application resource via the <literal>configure</literal> method.
        </para>
		<programlisting><![CDATA[Configuration configuration = new Configuration();		
configuration.configure();
]]></programlisting>

        <para>
			The <literal>Configuration</literal> class can read the XML configuration file from other sources as well. The <literal>configure</literal> method accepts <literal>URL, File and String</literal> filename parameters.
        </para>
		<programlisting><![CDATA[Configuration configuration = new Configuration();		
configuration.configure("myengine.esper.cfg.xml");
]]></programlisting>
    </sect1>

	<sect1 id="configuration-xml" revision="1">
        <title>XML Configuration File</title>

        <para>
			Here is an example configuration file.
            The schema for the configuration file can be found in the <literal>etc</literal> folder and is named <literal>esper-configuration-4-0.xsd</literal>.
            It is also available online at <literal>http://www.espertech.com/schema/esper/esper-configuration-2.0.xsd</literal> so that IDE can fetch it automatically.
            The namespace used is <literal>http://www.espertech.com/schema/esper</literal>.
        </para>
		<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<esper-configuration xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://www.espertech.com/schema/esper"
    xsi:schemaLocation="
http://www.espertech.com/schema/esper
http://www.espertech.com/schema/esper/esper-configuration-2.0.xsd">
  <event-type name="StockTick" class="com.espertech.esper.example.stockticker.event.StockTick"/>
  <event-type name="PriceLimit" class="com.espertech.esper.example.stockticker.event.PriceLimit"/>
  <auto-import import-name="org.mycompany.mypackage.MyUtility"/>
  <auto-import import-name="org.mycompany.util.*"/>
</esper-configuration>		
]]></programlisting>

        <para>
			The example above is only a subset of the configuration items available. The next chapters outline the available configuration in greater detail.
		</para>
    </sect1>

	<sect1 id="configuration-items" revision="1">
        <title>Configuration Items</title>

		<indexterm><primary>configuration</primary><secondary>items to configure</secondary></indexterm>
		<sect2 id="config-java" revision="1">
			<title>Events represented by Java Classes</title>
			
			<sect3 id="config-java-package-alias" revision="1">
				<title>Package of Java Event Classes</title>
				
				<para>
					Via this configuration an application can make the Java package or packages that contain an application's Java event classes known to an engine. 
					Thereby an application can simply refer to event types in statements by using the simple class name of
					each Java class representing an event type.
				</para>
								
				<para>
					For example, consider an order-taking application that places all event classes in package <literal>com.mycompany.order.event</literal>. One Java class representing an event is the class <literal>OrderEvent</literal>. 
					The application can simply issue a statement as follows to select <literal>OrderEvent</literal> events:
				</para>
				<programlisting><![CDATA[select * from OrderEvent]]></programlisting>

				<para>
					The XML configuration for defining the Java packages that contain Java event classes is:
				</para>
				<programlisting><![CDATA[<event-type-auto-name package-name="com.mycompany.order.event"/>]]></programlisting>
				
				<para>
					The same configuration but using the <literal>Configuration</literal> class:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.addEventTypeAutoName("com.mycompany.order.event");
// ... or ...
config.addEventTypeAutoName(MyEvent.getPackage().getName());]]></programlisting>

			</sect3>

			<sect3 id="config-java-event-name" revision="1">
				<title>Event type name to Java class mapping</title>
				
				<para>
					This configuration item can be used to allow event pattern statements and EPL statements to use an event type name rather then the fully qualified Java class name. Note that Java Interface classes and abstract classes are also supported as event types via the fully qualified Java class name, and an event type name can also be defined for such classes.
				</para>
				
				<para>
					The example pattern statement below first shows a pattern that uses the name <literal>StockTick</literal>. The second pattern statement is equivalent but specifies the fully-qualified Java class name.
				</para>

				<programlisting><![CDATA[every StockTick(symbol='IBM')"]]></programlisting>
				<programlisting><![CDATA[every com.espertech.esper.example.stockticker.event.StockTick(symbol='IBM')]]></programlisting>

				<para>
					The event type name can be listed in the XML configuration file as shown below. The <literal>Configuration</literal> API can also be used to programatically specify an event type name, as shown in an earlier code snippet.
				</para>
				<programlisting><![CDATA[<event-type name="StockTick" class="com.espertech.esper.example.stockticker.event.StockTick"/>]]></programlisting>
				
			</sect3>
			
			<sect3 id="config-java-legacy" revision="1">
				<title>Non-JavaBean and Legacy Java Event Classes</title>
				
				<para>
					Esper can process Java classes that provide event properties through other means then through JavaBean-style getter methods. It is not necessary that the method and member variable names in your Java class adhere to the JavaBean convention - any public methods and public member variables can be exposed as event properties via the below configuration.
				</para>
								
				<para>
					A Java class can optionally be configured with an accessor style attribute. This attribute instructs the engine how it should expose methods and fields for use as event properties in statements.
				</para>

				<table frame="topbot">
					<title>Accessor Styles</title>
					<tgroup cols="2">
						<colspec colwidth="1.5*"/>
						<colspec colwidth="2*"/>
						<thead>
							<row>
								<entry>Style Name</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>javabean</literal></entry>
								<entry>As the default setting, the engine exposes an event property for each public method following the JavaBean getter-method conventions</entry>
							</row>
							<row>
								<entry><literal>public</literal></entry>
								<entry>The engine exposes an event property for each public method and public member variable of the given class</entry>
							</row>
							<row>
								<entry><literal>explicit</literal></entry>
								<entry>The engine exposes an event property only for the explicitly configured public methods and public member variables</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
				
				<para>
					Using the <literal>public</literal> setting for the <literal>accessor-style</literal> attribute instructs the engine to expose an event property for each public method and public member variable of a Java class. The engine assigns event property names of the same name as the name of the method or member variable in the Java class.
				</para>
				
				<para>					
					For example, assuming the class <literal>MyLegacyEvent</literal> exposes a method named <literal>readValue</literal> and a member variable named <literal>myField</literal>, we can then use properties as shown. 
				</para>
				<programlisting><![CDATA[select readValue, myField from MyLegacyEvent]]></programlisting>

				<para>
					Using the <literal>explicit</literal> setting for the <literal>accessor-style</literal> attribute requires that event properties are declared via configuration. This is outlined in the next chapter.
				</para>

				<para>
					When configuring an engine instance from a XML configuration file, the XML snippet below demonstrates the use of the <literal>legacy-type</literal> element and the <literal>accessor-style</literal> attribute.
				</para>

				<programlisting><![CDATA[<event-type name="MyLegacyEvent" class="com.mycompany.mypackage.MyLegacyEventClass">
  <legacy-type accessor-style="public"/>
</event-type>]]></programlisting>

				<para>
					When configuring an engine instance via Configuration API, the sample code below shows how to set the accessor style.
				</para>

				<programlisting><![CDATA[Configuration configuration = new Configuration();
ConfigurationEventTypeLegacy legacyDef = new ConfigurationEventTypeLegacy();
legacyDef.setAccessorStyle(ConfigurationEventTypeLegacy.AccessorStyle.PUBLIC);
config.addEventType("MyLegacyEvent", MyLegacyEventClass.class.getName(), legacyDef);

EPServiceProvider epService = EPServiceProviderManager.getProvider("sample", configuration);
]]></programlisting>

			</sect3>

			<sect3 id="config-java-spec-properties" revision="1">
				<title>Specifying Event Properties for Java Classes</title>
				
				<para>
					Sometimes it may be convenient to use event property names in pattern and EPL statements that are backed up by a given public method or member variable (field) in a Java class. And it can be useful to declare multiple event properties that each map to the same method or member variable.
				</para>

				<para>
					We can configure properties of events via <literal>method-property</literal> and <literal>field-property</literal> elements, as the next example shows.
				</para>

				<programlisting><![CDATA[<event-type name="StockTick" class="com.espertech.esper.example.stockticker.event.StockTickEvent">
	<legacy-type accessor-style="javabean" code-generation="enabled">
		<method-property name="price" accessor-method="getCurrentPrice" />
		<field-property name="volume" accessor-field="volumeField" />
	</legacy-type>
</event-type>]]></programlisting>

				<para>
					The XML configuration snippet above declared an event property named <literal>price</literal> backed by a getter-method named <literal>getCurrentPrice</literal>, and a second event property named <literal>volume</literal> that is backed by a public member variable named <literal>volumeField</literal>. Thus the price and volume properties can be used in a statement:
				</para>								
				<programlisting><![CDATA[select avg(price * volume) from StockTick]]></programlisting>

				<para>
					As with all configuration options, the API can also be used:
				</para>

				<programlisting><![CDATA[Configuration configuration = new Configuration();
ConfigurationEventTypeLegacy legacyDef = new ConfigurationEventTypeLegacy();
legacyDef.addMethodProperty("price", "getCurrentPrice");
legacyDef.addFieldProperty("volume", "volumeField");
config.addEventType("StockTick", StockTickEvent.class.getName(), legacyDef);]]></programlisting>
			</sect3>

			<sect3 id="config-java-codegen" revision="1">
				<title>Turning off Code Generation</title>
				
				<para>
					Esper employes the <literal>CGLIB</literal> library for very fast read access to event property values. For certain legacy Java classes it may be desirable to disable the use of this library and instead use Java reflection to obtain event property values from event objects.
				</para>
								
				<para>
					In the XML configuration, the optional <literal>code-generation</literal> attribute in the <literal>legacy-type</literal> section can be set to <literal>disabled</literal> as shown next.
				</para>
				<programlisting><![CDATA[<event-type name="MyLegacyEvent" class="com.mycompany.package.MyLegacyEventClass">
	<legacy-type accessor-style="javabean" code-generation="disabled" />
</event-type>
]]></programlisting>

				<para>
					The sample below shows how to configure this option via the API.
				</para>

				<programlisting><![CDATA[Configuration configuration = new Configuration();
ConfigurationEventTypeLegacy legacyDef = new ConfigurationEventTypeLegacy();
legacyDef.setCodeGeneration(ConfigurationEventTypeLegacy.CodeGeneration.DISABLED);
config.addEventType("MyLegacyEvent", MyLegacyEventClass.class.getName(), legacyDef);]]></programlisting>

			</sect3>

			<sect3 id="config-java-property-case-sensitivity" revision="1">
				<title>Case Sensitivity and Property Names</title>
				
				<para>
					By default the engine resolves Java event properties case sensitive. That is, property names in statements must match JavaBean-convention property names in name and case. This option controls case sensitivity per Java class.
				</para>
								
				<para>
					In the configuration XML, the optional <literal>property-resolution-style</literal> attribute in the <literal>legacy-type</literal> element can be set to any of these values:
				</para>

				<table frame="topbot">
					<title>Property Resolution Case Sensitivity Styles</title>
					<tgroup cols="2">
						<colspec colwidth="1.5*"/>
						<colspec colwidth="2*"/>
						<thead>
							<row>
								<entry>Style Name</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>case_sensitive (default)</literal></entry>
								<entry>As the default setting, the engine matches property names for the exact name and case only.</entry>
							</row>
							<row>
								<entry><literal>case_insensitive</literal></entry>
								<entry>Properties are matched if the names are identical.  A case insensitive search is used and will choose the first property that matches the name exactly 
											or the first property that matches case insensitively should no match be found.
								</entry>
							</row>
							<row>
								<entry><literal>distinct_case_insensitive</literal></entry>
								<entry>Properties are matched if the names are identical.  A case insensitive search is used and will choose the first property that matches the name exactly case insensitively.  If more than one 'name' can be mapped to the property an exception is thrown.</entry>
							</row>
						</tbody>
					</tgroup>
				</table>

				<para>
					The sample below shows this option in XML configuration, however the setting can also be changed via API:
				</para>
				<programlisting><![CDATA[<event-type name="MyLegacyEvent" class="com.mycompany.package.MyLegacyEventClass">
  <legacy-type property-resolution-style="case_insensitive"/>
</event-type>]]></programlisting>

			</sect3>

			<sect3 id="config-java-factory-copy-method" revision="1">
				<title>Factory and Copy Method</title>
				
				<para>
					The <literal>insert into</literal> clause and directly instantiate and populate your event object. By default the engine invokes the default constructor to instantiate an event object. To change this behavior, you may configure
					a factory method. The factory method is a method name or a class name plus a method name (in the format class.method) that returns an instance of the class.
				</para>
								
				<para>
					The <literal>update</literal> clause can change event properties on an event object. For the purpose of maintaining consistency, the engine may have to copy your event object via serialization (implement the <literal>java.io.Serializable</literal> interface). If instead you do not want any copy operations to occur, or your application needs to control the copy operation, you may configure a copy method. The copy method is the name of a method on the event object that copies the event object.
				</para>
				<para>
					The sample below shows this option in XML configuration, however the setting can also be changed via API:
				</para>
				<programlisting><![CDATA[<event-type name="MyLegacyEvent" class="com.mycompany.package.MyLegacyEventClass">
  <legacy-type factory-method="com.mycompany.myapp.MySampleEventFactory.createMyLegacyTypeEvent" copy-method="myCopyMethod"/>
</event-type>]]></programlisting>
			</sect3>

			<sect3 id="config-java-startendtimestamp" revision="1">
				<title>Start and End Timestamp</title>
				
				<para>
					For use with date-time interval methods, for example, you may let the engine know which property of your class carries the start and end timestamp value.
				</para>
								
				<para>
					The sample below shows this option in XML configuration, however the setting can also be changed via API. The sample sets the name of the property providing the start timestamp to <literal>startts</literal> and the name of the property providing the end timestamp <literal>endts</literal>:
				</para>
				<programlisting><![CDATA[<event-type name="MyLegacyEvent" class="com.mycompany.package.MyLegacyEventClass">
  <legacy-type start-timestamp-property-name="startts" end-timestamp-property-name="endts"/>
</event-type>
]]></programlisting>
			</sect3>

		</sect2>
			
		<sect2 id="config-java-util-map" revision="1">
			<title>Events represented by <literal>java.util.Map</literal></title>
			
			<para>
				The engine can process <literal>java.util.Map</literal> events via the <literal>sendEvent(Map map, String eventTypeName)</literal> method on the <literal>EPRuntime</literal> interface. Entries in the Map represent event properties. Keys must be of type <literal>java.util.String</literal> for the engine to be able to look up event property names in pattern or EPL statements. Values can be of any type. JavaBean-style objects as values in a <literal>Map</literal> can be processed by the engine, and strongly-typed nested maps are also supported. Please see the <xref linkend="event_representation"/> section for details on how to use <literal>Map</literal> events with the engine.
			</para>
			
			<para>
				Via configuration we provide an event type name for <literal>Map</literal> events for use in statements, and the event property names and types enabling the engine to validate properties in statements.
			</para>
			
			<para>
				The below snippet of XML configuration configures an event named <literal>MyMapEvent</literal>.
			</para>

			<programlisting><![CDATA[<event-type name="MyMapEvent">
  <java-util-map>
    <map-property name="carId" class="int"/>
    <map-property name="carType" class="string"/>
    <map-property name="assembly" class="com.mycompany.Assembly"/>    
  </java-util-map>
</event-type>]]></programlisting>

			<para>
				This configuration defines the <literal>carId</literal> property of <literal>MyMapEvent</literal> events to be of type <literal>int</literal>, and the <literal>carType</literal> property to be of type <literal>java.util.String</literal>. The <literal>assembly</literal> property of the Map event will contain instances of <literal>com.mycompany.Assembly</literal> for the engine to query.
			</para>

			<para>
				The valid types for the <literal>class</literal> attribute are listed in <xref linkend="configuration-type-names"/>. In addition, any fully-qualified Java class name that can be resolved via <literal>Class.forName</literal> is allowed.
			</para>

			<para>
				 You can also use the configuration API to configure <literal>Map</literal> event types, as the short code snippet below demonstrates:
			</para>

			<programlisting><![CDATA[Map<String, Object> properties = new Map<String, Object>();
properties.put("carId", "int");
properties.put("carType", "string");
properties.put("assembly", Assembly.class.getName());

Configuration configuration = new Configuration();
configuration.addEventType("MyMapEvent", properties);]]></programlisting>

			<para>
				 For strongly-typed nested maps (maps-within-maps), the configuration API method <literal>addEventType</literal> can also used to define the nested types. The XML configuration does not provide the capability to configure nested maps.
			</para>

			<para>
				Finally, here is a sample EPL statement that uses the configured <literal>MyMapEvent</literal> map event. This statement uses the <literal>chassisTag</literal> and <literal>numParts</literal> properties of <literal>Assembly</literal> objects in each map.
			</para>
			<programlisting>select carType, assembly.chassisTag, count(assembly.numParts) from MyMapEvent.win:time(60 sec)</programlisting>

			<para>
				A Map event type may also become a subtype of one or more supertypes that must also be Map event types. The <literal>java-util-map</literal> element provides an optional attribute <literal>supertype-names</literal> that accepts a comma-separated list of names of Map event types that are supertypes to the type:
			</para>
			<programlisting><![CDATA[<event-type name="AccountUpdate">
<java-util-map supertype-names="BaseUpdate, AccountEvent">
...]]></programlisting>			

			<para>
				For initialization time configuration, the <literal>addMapSuperType</literal> method can be used to add Map hierarchy information. For runtime configuration, pass the supertype names to the <literal>addEventType</literal> method in <literal>ConfigurationOperations</literal>.
			</para>

			<para>
				A Map event type may declare a start and end timestamp property name. The XML shown next instructs the engine that the <literal>startts</literal> property carries the event start timestamp and the <literal>endts</literal> property carries the event end timestamp:
			</para>
			<programlisting><![CDATA[<event-type name="AccountUpdate">
<java-util-map start-timestamp-property-name="startts" end-timestamp-property-name="endts">
...]]></programlisting>			
		</sect2>
		
		<sect2 id="config-xml-dom" revision="1">
			<title>Events represented by <literal>org.w3c.dom.Node</literal></title>
			
			<para>
				Via this configuration item the Esper engine can natively process <literal>org.w3c.dom.Node</literal> instances, i.e. XML document object model (DOM) nodes.
				Please see the <xref linkend="event_representation"/> section for details on how to use <literal>Node</literal> events with the engine.
			</para>
			
			<para>
				Esper allows configuring XPath expressions as event properties. You can specify arbitrary XPath functions or expressions and provide a property name by which their result values will be available for use in expressions. 
			</para>
				
			<para>
				For XML documents that follow a XML schema, Esper can load and interrogate your schema and validate event property names and types against the schema information. 
			</para>

			<para>
				Nested, mapped and indexed event properties are also supported in expressions against <literal>org.w3c.dom.Node</literal> events. Thus XML trees can conveniently be
				interrogated using the existing event property syntax for querying JavaBean objects, JavaBean object graphs or <literal>java.util.Map</literal> events.
			</para>

			<para>
				In the simplest form, the Esper engine only requires a configuration entry containing the root element name and the event type name in order to process <literal>org.w3c.dom.Node</literal> events:
			</para>
			<programlisting><![CDATA[<event-type name="MyXMLNodeEvent">
  <xml-dom root-element-name="myevent" />
</event-type>]]></programlisting>
			
			<para>
				 You can also use the configuration API to configure XML event types, as the short example below demonstrates. 
				 In fact, all configuration options available through XML configuration can 
				 also be provided via setter methods on the <literal>ConfigurationEventTypeXMLDOM</literal> class.
			</para>

			<programlisting><![CDATA[Configuration configuration = new Configuration();
ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setRootElementName("myevent");
desc.addXPathProperty("name1", "/element/@attribute", XPathConstants.STRING);
desc.addXPathProperty("name2", "/element/subelement", XPathConstants.NUMBER);
configuration.addEventType("MyXMLNodeEvent", desc);]]></programlisting>

			<para>
				 The next example presents configuration options in a sample configuration entry.
			</para>

			<programlisting><![CDATA[<event-type name="AutoIdRFIDEvent">
  <xml-dom root-element-name="Sensor" schema-resource="data/AutoIdPmlCore.xsd" 
       default-namespace="urn:autoid:specification:interchange:PMLCore:xml:schema:1">
    <namespace-prefix prefix="pmlcore" 
       namespace="urn:autoid:specification:interchange:PMLCore:xml:schema:1"/>
    <xpath-property property-name="countTags" 
       xpath="count(/pmlcore:Sensor/pmlcore:Observation/pmlcore:Tag)" type="number"/>
  </xml-dom>
</event-type>]]></programlisting>

			<para>
				 This example configures an event property named <literal>countTags</literal> whose value is computed by an XPath expression. The namespace prefixes
				 and default namespace are for use with XPath expressions and must also be made known to the engine in order for the engine to compile XPath expressions. 
				 Via the <literal>schema-resource</literal> attribute we instruct the engine to load a schema file. You may also use <literal>schema-text</literal> instead to 
				 provide the actual text of the schema.
			</para>
			
			<para>
				 Here is an example EPL statement using the configured event type named <literal>AutoIdRFIDEvent</literal>.
			</para>

			<programlisting><![CDATA[select ID, countTags from AutoIdRFIDEvent.win:time(30 sec)]]></programlisting>

			<sect3 id="config-xml-dom-schema" revision="1">
				<title>Schema Resource</title>
				<para>
					 The <literal>schema-resource</literal> attribute takes a schema resource URL or classpath-relative filename. 
					 The engine attempts to resolve the schema resource as an URL. If the schema resource name is not a valid URL, the engine attempts to resolve the resource from classpath via the <literal>ClassLoader.getResource</literal> method using the thread context class loader. If the name could not be resolved, the engine uses the Configuration class classloader. Use the <literal>schema-text</literal> attribute instead when it is more practical to provide the actual text of the schema. 
				</para>

				<para>
					 By configuring a schema file for the engine to load, the engine performs these additional services:
				</para>
				
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							Validates the event properties in a statement, ensuring the event property name matches an attribute or element in the XML
						</para>
					</listitem>
					<listitem>
						<para>
							Determines the type of the event property allowing event properties to be used in type-sensitive expressions such as expressions involving arithmetic (Note: XPath properties are also typed)
						</para>
					</listitem>
					<listitem>
						<para>
							Matches event property names to either element names or attributes
						</para>
					</listitem>
				</itemizedlist>

				<para>
					 If no schema resource is specified, none of the event properties specified in statements are validated at statement creation time and their type defaults to <literal>java.lang.String</literal>. Also, attributes are not supported
					 if no schema resource is specified and must thus be declared via XPath expression.
				</para>

		  </sect3>

			<sect3 id="config-xml-dom-xpathprop" revision="1">
				<title>Explicit XPath Property</title>
				<para>
					 The <literal>xpath-property</literal> element adds explicitly-names event properties to the event type that are computed via an XPath expression.
					 In order for the XPath expression to compile, be sure to specify the <literal>default-namespace</literal> attribute and use the 
					 <literal>namespace-prefix</literal> to declare namespace prefixes.
				</para>
					 
				<para>
					 XPath expression properties are strongly typed. The <literal>type</literal> attribute allows the following values. These values correspond to those declared by 
					 <literal>javax.xml.xpath.XPathConstants</literal>.
				</para>

				<itemizedlist spacing="compact">
					<listitem>
						<para>
							number (Note: resolves to a <literal>double</literal>)
						</para>
					</listitem>
					<listitem>
						<para>
							string
						</para>
					</listitem>
					<listitem>
						<para>
							boolean
						</para>
					</listitem>
					<listitem>
						<para>
							node
						</para>
					</listitem>
					<listitem>
						<para>
							nodeset
						</para>
					</listitem>
				</itemizedlist>
				
				<para>
					 In case you need your XPath expression to return a type other then the types listed above, an optional cast-to type can be specified. If specified, the operation firsts obtains the result of the XPath expression as the defined type (number, string, boolean) and then casts or parses the returned type to the specified cast-to-type. At runtime, a warning message is logged if the XPath expression returns a result object that cannot be casted or parsed.
				</para>

				<para>
					 The next line shows how to return a long-type property for an XPath expression that returns a string:
				</para>
				<programlisting><![CDATA[desc.addXPathProperty("name", "/element/sub", XPathConstants.STRING, "long");]]></programlisting>
	
				<para>
					 The equivalent configuration XML is:
				</para>
				<programlisting><![CDATA[<xpath-property property-name="name"  xpath="/element/sub" type="string" cast="long"/>]]></programlisting>

				<para>
				  See <xref linkend="configuration-type-names"/> for a list of cast-to type names.
				</para>
		  </sect3>
		  
			<sect3 id="config-xml-dom-absolute" revision="1">
				<title>Absolute or Deep Property Resolution</title>
				
				<para>
					This setting indicates that when properties are compiled to XPath expressions that the compilation should generate an absolute XPath expression or a deep (find element) XPath expression. 					
				</para>

				<para>
					For example, consider the following statement against an event type that is represented by a XML DOM document, assuming the event type GetQuote has been configured with the engine as a XML DOM event type:
				</para>
				<programlisting><![CDATA[select request, request.symbol from GetQuote]]></programlisting>

				<para>
					By default, the engine compiles the "request" property name to an XPath expression "/GetQuote/request". It compiles the nested property named "request.symbol" to an XPath expression "/GetQuote/request/symbol", wherein the root element node is "GetQuote".
				</para>

				<para>
					By setting absolute property resolution to false, the engine compiles the "request" property name to an XPath expression "//request". It compiles the nested property named "request.symbol" to an XPath expression "//request/symbol".
					This enables these elements to be located anywhere in the XML document.
				</para>

				<para>
					The setting is available in XML via the attribute <literal>resolve-properties-absolute</literal>.
				</para>

				<para>
					The configuration API provides the above settings as shown here in a sample code:
				</para>

				<programlisting><![CDATA[ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setRootElementName("GetQuote");
desc.setDefaultNamespace("http://services.samples/xsd");
desc.setRootElementNamespace("http://services.samples/xsd");
desc.addNamespacePrefix("m0", "http://services.samples/xsd");
desc.setResolvePropertiesAbsolute(false);
configuration.addEventType("GetQuote", desc);]]></programlisting>
			
		  </sect3>

			<sect3 id="config-xml-dom-xpathresolver" revision="1">
				<title>XPath Variable and Function Resolver</title>
				
				<para>
					If your XPath expressions require variables or functions, your application may provide the class name of an <literal>XPathVariableResolver</literal> and <literal>XPathFunctionResolver</literal>. At type initialization time 
					the engine instantiates the resolver instances and provides these to the XPathFactory.
				</para>

				<para>
					This example shows the API to set this configuration.
				</para>

				<programlisting><![CDATA[ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setXPathFunctionResolver(MyXPathFunctionResolver.class.getName());
desc.setXPathVariableResolver(MyXPathVariableResolver.class.getName());]]></programlisting>
						
		  </sect3>

			<sect3 id="config-xml-dom-autofragment" revision="1">
				<title>Auto Fragment</title>
				
				<para>
					This option is for use when a XSD schema is provided and determines whether the engine automatically creates an event type when a property expression transposes a property that is a complex type according to the schema.
				</para>

				<para>
					An example:
				</para>

				<programlisting><![CDATA[ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setAutoFragment(false);]]></programlisting>
						
		  </sect3>
		  
		  <sect3 id="config-xml-dom-xpathpropertyexpr" revision="1">
				<title>XPath Property Expression</title>
				
				<para>
					By default Esper employs the built-in DOM walker implementation to evaluate XPath expressions, which is not namespace-aware.
				</para>

				<para>
					This configuration setting, when set to true, instructs the engine to rewrite property expressions into XPath.
				</para>

				<para>
					An example:
				</para>

				<programlisting><![CDATA[ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setXPathPropertyExpr(true);]]></programlisting>
						
		  </sect3>

		  <sect3 id="config-xml-dom-eventsendervalidatesroot" revision="1">
				<title>Event Sender Setting</title>
				
				<para>
					By default an <literal>EventSender</literal> for a given XML event type validates the root element name for which the type has been declared against the one provided by the <literal>org.w3c.Node</literal> sent into the engine.
				</para>

				<para>
					This configuration setting, when set to false, instructs an <literal>EventSender</literal> to not validate.
				</para>

				<para>
					An example:
				</para>

				<programlisting><![CDATA[ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setEventSenderValidatesRoot(false);]]></programlisting>
						
		  </sect3>

		  <sect3 id="config-xml-dom-startendtimestamp" revision="1">
				<title>Start and End Timestamp</title>
				
				<para>
					You may configure the name of the properties that provides the event start timestamp and the event end timestamp as part of the configuration.
				</para>

				<para>
					An example that configures <literal>startts</literal> as the property name providing the start timestamp and <literal>endts</literal> as the property name providing the end timestamp:
				</para>

				<programlisting><![CDATA[ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setStartTimestampPropertyName("startts");
desc.setEndTimestampPropertyName("endts");]]></programlisting>
						
		  </sect3>
		</sect2>
					
		<sect2 id="config-plugineventrep" revision="1">
			<title>Events represented by Plug-in Event Representations</title>
			
			<para>
				As part of the extension API plug-in event representations allows an application to create new event types and event instances based on information available elsewhere. Please see <xref linkend="custom-event-representation"/> for details.
			</para>
				
			<para>
				The configuration examples shown next use the configuration API to select settings. All options are also configurable via XML, please refer to the sample configuration XML in file <literal>esper.sample.cfg.xml</literal>.
			</para>

			<sect3 id="config-plugineventrep-enable" revision="1">
				<title>Enabling an Custom Event Representation</title>
				
				<para>
					Use the method <literal>addPlugInEventRepresentation</literal> to enable a custom event representation, like this:
				</para>
				
				<programlisting><![CDATA[URI rootURI = new URI("type://mycompany/myproject/myname");
config.addPlugInEventRepresentation(rootURI, 
    MyEventRepresentation.class.getName(), null);]]></programlisting>

				<para>
					The <literal>type://</literal> part of the URI is an optional convention for the scheme part of an URI. 
				</para>

				<para>
					If your event representation takes initialization parameters, these are passed in as the last parameter. Initialization parameters can also be stored in the configuration XML, in which case
					they are passed as an XML string to the plug-in class.
				</para>

			</sect3>
			
			<sect3 id="config-plugineventrep-types" revision="1">
				<title>Adding Plug-in Event Types</title>
				
				<para>
					To register event types that your plug-in event representation creates in advance of creating an EPL statement (either at runtime or at configuration time), use the method <literal>addPlugInEventType</literal>:
				</para>
				
				<programlisting><![CDATA[URI childURI = new URI("type://mycompany/myproject/myname/MyEvent");
configuration.addPlugInEventType("MyEvent", new URI[] {childURI}, null);]]></programlisting>

				<para>
					Your plug-in event type may take initialization parameters, these are passed in as the last parameter. Initialization parameters can also be stored in the configuration XML.
				</para>
			</sect3>

			<sect3 id="config-plugineventrep-resolution" revision="1">
				<title>Setting Resolution URIs</title>
				
				<para>
					The engine can invoke your plug-in event representation when an EPL statement is created with an event type name that the engine has not seen before. Plug-in event representations can resolve such names to an actual event type. In order to do this, you need to supply a list of resolution URIs. Use the method <literal>setPlugInEventTypeNameResolutionURIs</literal>, at runtime or at configuration time:
				</para>				
				<programlisting><![CDATA[URI childURI = new URI("type://mycompany/myproject/myname");
configuration.setPlugInEventTypeNameResolutionURIs(new URI[] {childURI});]]></programlisting>

			</sect3>

		</sect2>

		<sect2 id="config-class--package-imports" revision="1">
			<title>Class and package imports</title>
			
			<para>
				Esper allows invocations of static Java library functions in expressions, as outlined in <xref linkend="epl-single-row-function-ref"/>. This configuration 
				item can be set to allow a partial rather than a fully qualified class name in such invocations. The imports work in the same way as in Java files, so both packages and classes can be imported.
			</para>
			
			<programlisting>select Math.max(priceOne, PriceTwo)
// via configuration equivalent to
select java.lang.Math.max(priceOne, priceTwo)</programlisting>

			<para>
				Esper auto-imports the following Java library packages if no other configuration is supplied.
				This list is replaced with any configuration specified in a configuration file or through the API.
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						java.lang.*
					</para>
				</listitem>
				<listitem>
					<para>
						java.math.*
					</para>
				</listitem>
				<listitem>
					<para>
						java.text.*
					</para>
				</listitem>
				<listitem>
					<para>
						java.util.*
					</para>
				</listitem>
			</itemizedlist>

			<para>
				In a XML configuration file the auto-import configuration may look as below:
			</para>

		<programlisting><![CDATA[<auto-import import-name="com.mycompany.mypackage.*"/>
<auto-import import-name="com.mycompany.myapp.MyUtilityClass"/>]]></programlisting>

			<para>
				Here is an example of providing imports via the API:
			</para>

		<programlisting><![CDATA[Configuration config = new Configuration();
config.addImport("com.mycompany.mypackage.*");	// package import
config.addImport("com.mycompany.mypackage.MyLib");   // class import]]></programlisting>
		</sect2>

		<sect2 id="config-method-invocations" revision="1">
			<title>Cache Settings for From-Clause Method Invocations</title>
			
			<para>
				Method invocations are allowed in the <literal>from</literal> clause in EPL, such that your application may join event streams to the data returned by a web service, or to data read from a distributed cache or object-oriented database, or obtain data by other means. A local cache may be placed in front of such method invocations through the configuration settings described herein.
			</para>
			
			<para>
				The LRU cache is described in detail in <xref linkend="config-database-cache-lru"/>. The expiry-time cache documentation can be found in <xref linkend="config-database-cache-expiry"/>
			</para>
			
			<para>
				The next XML snippet is a sample cache configuration that applies to methods provided by the classes 'MyFromClauseLookupLib'  and 'MyFromClauseWebServiceLib'. The XML and API configuration understand both the fully-qualified Java class name, as well as the simple class name:
			</para>			
			<programlisting><![CDATA[<method-reference class-name="com.mycompany.MyFromClauseLookupLib">
  <expiry-time-cache max-age-seconds="10" purge-interval-seconds="10" ref-type="weak"/>
</method-reference> 	
<method-reference class-name="MyFromClauseWebServiceLib">
  <lru-cache size="1000"/>
</method-reference> ]]></programlisting>
		</sect2>

		<sect2 id="config-variables" revision="1">
			<title>Variables</title>
			
			<para>
				Variables can be created dynamically in EPL via the <literal>create variable</literal> syntax but can also be configured at runtime and at configuration time.
			</para>
			
			<para>
				A variable is declared by specifying a variable name, the variable type and an optional initialization value. The initialization value can be of the same or compatible type as the variable type, or can also be a String value that, when parsed, is compatible to the type declared for the variable.
			</para>

			<para>
				In a XML configuration file the variable configuration may look as below. The <literal>Configuration</literal> API can also be used to configure variables.
			</para>

		<programlisting><![CDATA[<variable name="var_threshold" type="long" initialization-value="100"/>
<variable name="var_key" type="string"/>]]></programlisting>

			<para>
				Please find the list of valid values for the <literal>type</literal> attribute in <xref linkend="configuration-type-names"/>.
			</para>

		</sect2>

		<sect2 id="config-database-ref" revision="1">
			<title>Relational Database Access</title>
			
			<para>
				Esper has the capability to join event streams against historical data sources, such as a relational database. This section describes the configuration entries that the engine requires to access data stored in your database. Please see <xref linkend="histdata_overview"/> for information on the use of EPL queries that include historical data sources.
			</para>
			
			<para>
					EPL queries that poll data from a relational database specify the name of the database as part of the EPL statement. The engine uses the configuration information described here to resolve the database name in the statement to database settings. The required and optional database settings are summarized below. 
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Database connections can be obtained via JDBC <literal>javax.xml.DataSource</literal>, via <literal>java.sql.DriverManager</literal> and via data source factory. Either one of these methods to obtain database connections is a required configuration.
					</para>
				</listitem>
				<listitem>
					<para>
						Optionally, JDBC connection-level settings such as auto-commit, transaction isolation level, read-only and the catalog name can be defined.
					</para>
				</listitem>
				<listitem>
					<para>
						Optionally, a connection lifecycle can be set to indicate to the engine whether the engine must retain connections or must obtain a new connection for each lookup and close the connection when the lookup is done (pooled).
					</para>
				</listitem>
				<listitem>
					<para>
						Optionally, define a cache policy to allow the engine to retrieve data from a query cache, reducing the number of query executions.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Some of the settings can have important performance implications that need to be carefully considered in relationship to your database software, JDBC driver and runtime environment. This section attempts to outline such implications where appropriate.
			</para>

			<para>
				The sample XML configuration file in the "etc" folder can be used as a template for configuring database settings. All settings are also available by means of the configuration API through the classes <literal>Configuration</literal> and <literal>ConfigurationDBRef</literal>.
			</para>
						
			<sect3 id="config-database-datasource" revision="1">
				<title>Connections obtained via DataSource</title>

				<para>
					This configuration causes Esper to obtain a database connection from a <literal>javax.sql.DataSource</literal> available from your JNDI provider.
				</para>

				<para>
					The setting is most useful when running within an application server or when a JNDI directory is otherwise present in your Java VM. If your application environment does not provide an available <literal>DataSource</literal>, the next section outlines how to use Apache DBCP as a <literal>DataSource</literal> implementation with connection pooling options and outlines how to use a custom factory for <literal>DataSource</literal> implementations.
				</para>

				<para>
					If your <literal>DataSource</literal> provides connections out of a connection pool, your configuration should set the collection lifecycle setting to <literal>pooled</literal>.
				</para>

				<para>
				The snippet of XML below configures a database named <literal>mydb1</literal> to obtain connections via a <literal>javax.sql.DataSource</literal>. The <literal>datasource-connection</literal> element instructs the engine to obtain new connections to the database <literal>mydb1</literal> by performing a lookup via <literal>javax.naming.InitialContext</literal> for the given object lookup name. Optional environment properties for the <literal>InitialContext</literal> are also shown in the example.
				</para>

				<programlisting><![CDATA[<database-reference name="mydb1">
  <datasource-connection context-lookup-name="java:comp/env/jdbc/mydb">
    <env-property name="java.naming.factory.initial" value ="com.myclass.CtxFactory"/>
    <env-property name="java.naming.provider.url" value ="iiop://localhost:1050"/>
  </datasource-connection>
</database-reference>]]></programlisting>

				<para>
					To help you better understand how the engine uses this information to obtain connections, we have included the logic below.
				</para>
				<programlisting><![CDATA[if (envProperties.size() > 0) {
  initialContext = new InitialContext(envProperties);
}
else {
  initialContext = new InitialContext();
}
DataSource dataSource = (DataSource) initialContext.lookup(lookupName);
Connection connection = dataSource.getConnection();]]></programlisting>

				<para>
					In order to plug-in your own implementation of the <literal>DataSource</literal> interface, your application may use an existing JNDI provider as provided by an application server if running in a J2EE environment.
				</para>

				<para>
					In case your application does not have an existing JNDI implementation to register a <literal>DataSource</literal> to provide connections, you may set the <literal>java.naming.factory.initial</literal> property in the configuration to point to your application's own implementation of the <literal>javax.naming.spi.InitialContextFactory</literal> interface that can return your application <literal>DataSource</literal> though the <literal>javax.naming.Context</literal> provided by the factory implementation. Please see Java Naming and Directory Interface (JNDI) API documentation for further information.
				</para>
			</sect3>

			<sect3 id="config-database-datasourcefactory" revision="1">
				<title>Connections obtained via DataSource Factory</title>

				<para>
					This section describes how to use <ulink url="http://commons.apache.org/dbcp"><citetitle>Apache Commons Database Connection Pooling (Apache DBCP)</citetitle></ulink> with Esper. We also explain how to provide a custom application-specific <literal>DataSource</literal> factory if not using Apache DBCP.
				</para>

				<para>
					If your <literal>DataSource</literal> provides connections out of a connection pool, your configuration should set the collection lifecycle setting to <literal>pooled</literal>.
				</para>
					
				<para>
					Apache DBCP provides comprehensive means to test for dead connections or grow and shrik a connection pool. Configuration properties for Apache DBCP can be found at <ulink url="http://commons.apache.org/dbcp/configuration.html"><citetitle>Apache DBCP configuration</citetitle></ulink>. The listed properties are passed to Apache DBCP via the properties list provided as part of the Esper configuration.
				</para>

				<para>
				   The snippet of XML below is an example that configures a database named <literal>mydb3</literal> to obtain connections via the pooling <literal>DataSource</literal> provided by Apache DBCP <literal>BasicDataSourceFactory</literal>.
				</para>

				<para>
				   The listed properties are passed to DBCP to instruct DBCP how to manage the connection pool. The settings below initialize the connection pool to 2 connections and provide the validation query <literal>select 1 from dual</literal> for DBCP to validate a connection before providing a connection from the pool to Esper:
				</para>

				<programlisting><![CDATA[<database-reference name="mydb3">
  <!-- For a complete list of properties see Apache DBCP. -->
  <datasourcefactory-connection class-name="org.apache.commons.dbcp.BasicDataSourceFactory">	
    <env-property name="username" value ="myusername"/>
    <env-property name="password" value ="mypassword"/>
    <env-property name="driverClassName" value ="com.mysql.jdbc.Driver"/>
    <env-property name="url" value ="jdbc:mysql://localhost/test"/>
    <env-property name="initialSize" value ="2"/>
    <env-property name="validationQuery" value ="select 1 from dual"/>
  </datasourcefactory-connection>
  <connection-lifecycle value="pooled"/>
</database-reference>]]></programlisting>

				<para>
					The same configuration options provided through the API:
				</para>
				<programlisting><![CDATA[Properties props = new Properties();
props.put("username", "myusername");
props.put("password", "mypassword");
props.put("driverClassName", "com.mysql.jdbc.Driver");
props.put("url", "jdbc:mysql://localhost/test");
props.put("initialSize", 2);
props.put("validationQuery", "select 1 from dual");

ConfigurationDBRef configDB = new ConfigurationDBRef();
// BasicDataSourceFactory is an Apache DBCP import
configDB.setDataSourceFactory(props, BasicDataSourceFactory.class.getName());
configDB.setConnectionLifecycleEnum(ConfigurationDBRef.ConnectionLifecycleEnum.POOLED);

Configuration configuration = new Configuration();;
configuration.addDatabaseReference("mydb3", configDB);]]></programlisting>
				
				<para>
					Apache Commons DBCP is a separate download and not provided as part of the Esper distribution. The Apache Commons DBCP jar file requires the Apache Commons Pool jar file.
				</para>

				<para>
					Your application can provide its own factory implementation for <literal>DataSource</literal> instances: Set the class name to the name of the application class that provides a public static method named <literal>createDataSource</literal> which takes a single <literal>Properties</literal> object as parameter and returns a  <literal>DataSource</literal> implementation. For example:
				</para>
				
				<programlisting><![CDATA[configDB.setDataSourceFactory(props, MyOwnDataSourceFactory.class.getName());
...
class MyOwnDataSourceFactory {
  public static DataSource createDataSource(Properties properties) {
    return new MyDataSourceImpl(properties);
  }
}]]></programlisting>
			</sect3>

			<sect3 id="config-database-drivermanager" revision="1">
				<title>Connections obtained via DriverManager</title>

				<para>
				The next snippet of XML configures a database named <literal>mydb2</literal> to obtain connections via <literal>java.sql.DriverManager</literal>. The <literal>drivermanager-connection</literal> element instructs the engine to obtain new connections to the database <literal>mydb2</literal> by means of <literal>Class.forName</literal> and <literal>DriverManager.getConnection</literal> using the class name, URL and optional username, password and connection arguments.
				</para>

				<programlisting><![CDATA[<database-reference name="mydb2">
  <drivermanager-connection class-name="my.sql.Driver" 
        url="jdbc:mysql://localhost/test?user=root&amp;password=mypassword" 
        user="myuser" password="mypassword">
    <connection-arg name="user" value ="myuser"/>
    <connection-arg name="password" value ="mypassword"/>
    <connection-arg name="somearg" value ="someargvalue"/>
  </drivermanager-connection>
</database-reference>]]></programlisting>

				<para>
					The username and password are shown in multiple places in the XML only as an example. Please check with your database software on the required information in
					URL and connection arguments.
				</para>
			</sect3>

			<sect3 id="config-database-connections" revision="1">
				<title>Connections-level settings</title>

				<para>
					Additional connection-level settings can optionally be provided to the engine which the engine will apply to new connections. When the engine obtains a new connection, it applies only those settings to the connection that are explicitly configured. The engine leaves all other connection settings at default values.
				</para>

				<para>
					The below XML is a sample of all available configuration settings. Please refer to the Java API JavaDocs for <literal>java.sql.Connection</literal> for more information to each option or check the documentation of your JDBC driver and database software.
				</para>
				
				<programlisting><![CDATA[<database-reference name="mydb2">
... configure data source or driver manager settings...
  <connection-settings auto-commit="true" catalog="mycatalog" 
      read-only="true" transaction-isolation="1" />
</database-reference>]]></programlisting>

				<para>
					The <literal>read-only</literal> setting can be used to indicate to your database engine that SQL statements are read-only. The <literal>transaction-isolation</literal> and <literal>auto-commit</literal> help you database software perform the right level of locking and lock release. Consider setting these values to reduce transactional overhead in your database queries.
				</para>
			</sect3>

			<sect3 id="config-database-connections-lifecycle" revision="1">
				<title>Connections lifecycle settings</title>

				<para>
					By default the engine retains a separate database connection for each started EPL statement. However, it is possible to override this behavior and require the engine to obtain a new database connection for each lookup, and to close that database connection after the lookup is completed. This often makes sense when you have a large number of EPL statements and require pooling of connections via a connection pool.
				</para>

				<para>
					In the <literal>pooled</literal> setting, the engine obtains a database connection from the data source or driver manager for every query, and closes the connection when done, returning the database connection to the pool if using a pooling data source.
				</para>

				<para>
					In the <literal>retain</literal> setting, the engine retains a separate dedicated database connection for each statement and does not close the connection between uses.
				</para>

				<para>
					The XML for this option is below. The connection lifecycle allows the following values: <literal>pooled</literal> and <literal>retain</literal>.
				</para>
				
				<programlisting><![CDATA[<database-reference name="mydb2">
... configure data source or driver manager settings...
    <connection-lifecycle value="pooled"/>
</database-reference>]]></programlisting>
			</sect3>

			<sect3 id="config-database-cache" revision="1">
				<title>Cache settings</title>

				<para>
					Cache settings can dramatically reduce the number of database queries that the engine executes for EPL statements. If no cache setting is specified, the engine does not cache query results and executes a separate database query for every event.
				</para>
	
				<para>
					Caches store the results of database queries and make these results available to subsequent queries using the exact same query parameters as the query for which
					the result was stored. If your query returns one or more rows, the cache keep the result rows of the query keyed to the parameters of the query. If your query returns no rows, the cache also keeps the empty result. Query results are held by a cache until the cache entry is evicted. The strategies available for evicting cached 
					query results are listed next.
				</para>

				<sect4 id="config-database-cache-lru" revision="1">
					<title>LRU Cache</title>
					
					<para>
						The least-recently-used (LRU) cache is configured by a maximum size. The cache discards the least recently used query results first once the cache reaches the maximum size.
					</para>
					
					<para>
						The XML configuration entry for a LRU cache is as below. This entry configures an LRU cache holding up to 1000 query results.
					</para>

					<programlisting><![CDATA[<database-reference name="mydb">
... configure data source or driver manager settings...
    <lru-cache size="1000"/>
</database-reference>]]></programlisting>
				</sect4>

				<sect4 id="config-database-cache-expiry" revision="1">
					<title>Expiry-time Cache</title>
					
					<para>
						The expiry time cache is configured by a maximum age in seconds, a purge interval and an optional reference type. The cache discards (on the get operation) any query results that are older then the maximum age so that stale data is not used. If the cache is not empty, then every purge interval number of seconds the engine purges any expired entries from the cache.
					</para>
					
					<para>
						The XML configuration entry for an expiry-time cache is as follows. The example configures an expiry time cache in which prior query results are valid for 60 seconds and which the engine inspects every 2 minutes to remove query results older then 60 seconds.
					</para>

					<programlisting><![CDATA[<database-reference name="mydb">
... configure data source or driver manager settings...
    <expiry-time-cache max-age-seconds="60" purge-interval-seconds="120" />
</database-reference>]]></programlisting>

					<para>
						By default, the expiry-time cache is backed by a <literal>java.util.WeakHashMap</literal> and thus relies on weak references. That means that cached SQL results can be freed during garbage collection. 
					</para>

					<para>
						Via XML or using the configuration API the type of reference can be configured to not allow entries to be garbage collected, by setting the <literal>ref-type</literal> property to <literal>hard</literal>:
					</para>

					<programlisting><![CDATA[<database-reference name="mydb">
... configure data source or driver manager settings...
    <expiry-time-cache max-age-seconds="60" purge-interval-seconds="120" ref-type="hard"/>
</database-reference>]]></programlisting>
				</sect4>

					<para>
						The last setting for the cache reference type is <literal>soft</literal>: This strategy allows the garbage collection of cache entries only when all other weak references have been collected.
					</para>
			</sect3>

			<sect3 id="config-database-columnchangecase" revision="1">
				<title>Column Change Case</title>
				
				<para>
					This setting instructs the engine to convert to lower- or uppercase any output column names returned by your database system. When using Oracle relational database software, for example, column names
					can be changed to lowercase via this setting.
				</para>
				
				<para>
					A sample XML configuration entry for this setting is:
				</para>
				<programlisting><![CDATA[<column-change-case value="lowercase"/>]]></programlisting>				
			</sect3>

			<sect3 id="config-database-sqltypes" revision="1">
				<title>SQL Types Mapping</title>				
				<para>
					By providing a mapping of SQL types (<literal>java.sql.Types</literal>) to Java built-in types your code can avoid using sometimes awkward default database types and can easily change the way Esper
					returns Java types for columns returned by a SQL query.
				</para>
				
				<para>
					The mapping maps a constant as defined by <literal>java.sql.Types</literal> to a Java built-in type of any of the following Java type names: <literal>String, BigDecimal, Boolean, Byte, Short, Int, Long, Float, Double, ByteArray, SqlDate, SqlTime, SqlTimestamp</literal>.  The Java type names are not case-sensitive.
				</para>
				
				<para>
					A sample XML configuration entry for this setting is shown next. The sample maps <literal>Types.NUMERIC</literal> which is a constant value of <literal>2</literal> per JDBC API to the Java <literal>int</literal> type.
				</para>
				<programlisting><![CDATA[<sql-types-mapping sql-type="2" java-type="int" />]]></programlisting>				
			</sect3>

			<sect3 id="config-database-metadata" revision="1">
				<title>Metadata Origin</title>
				
				<para>
					This setting controls how the engine retrieves SQL statement metadata from JDBC prepared statements.
				</para>
				
				<table frame="topbot" id="epl-grouping-aggregate-func" revision="2">
					<title>Syntax and results of aggregate functions</title>
					<tgroup cols="2">
						<colspec colwidth="0.5*"/>
						<colspec colwidth="2.0*"/>
						<thead>
							<row>
								<entry>Option</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>default</entry>
								<entry>
									<para>
										By default, the engine detects the driver name and queries prepared statement metadata if the driver is not an Oracle database driver. For Oracle drivers, the engine uses
										lexical analysis of the SQL statement to construct a sample SQL statement and then fires that statement to retrieve statement metadata.
									</para>
								</entry>
							</row>
							<row>
								<entry>metadata</entry>
								<entry>
									<para>
										The engine always queries prepared statement metadata regardless of the database driver used.
									</para>
								</entry>
							</row>
							<row>
								<entry>sample</entry>
								<entry>
									<para>
										The engine always uses lexical analysis of the SQL statement to construct a sample SQL statement, and then fires that statement to retrieve statement metadata.
									</para>
								</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</sect3>
		</sect2>

		<sect2 id="config-engine-threading" revision="1">
			<title>Engine Settings related to Concurrency and Threading</title>
			
			<sect3 id="config-engine-threading-dispatch" revision="1">
				<title>Preserving the order of events delivered to listeners</title>

				<para>
					In multithreaded environments, this setting controls whether dispatches of statement result events to listeners preserve the ordering in which a statement processes events. By default the engine guarantees that it delivers a statement's result events to statement listeners in the order in which the result is generated. This behavior can be turned off via configuration as below. 
				</para>
				
				<para>
					The next code snippet shows how to control this feature:
				</para>
					<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getThreading().setListenerDispatchPreserveOrder(false);
engine = EPServiceProviderManager.getDefaultProvider(config);]]></programlisting>
				
				<para>
					And the XML configuration file can also control this feature by adding the following elements:
				</para>
					<programlisting><![CDATA[<engine-settings>
  <defaults>
    <threading>
      <listener-dispatch preserve-order="true" timeout-msec="1000" locking="spin"/>
    </threading>
  </defaults>
</engine-settings>]]></programlisting>

				<para>
					As discussed, by default the engine can temporarily block another processing thread when delivering result events to listeners in order to preserve the order in which results are delivered to a given statement. The maximum time the engine blocks a thread can also be configured, and by default is set to 1 second.
				</para>

				<para>
					As such delivery locks are typically held for a very short amount of time, the default blocking technique employs a spin lock (There are two techniques for implementing blocking; having the operating system suspend the thread until it is awakened later or using spin locks). While spin locks are CPU-intensive and appear inefficient, a spin lock can be more efficient than suspending the thread and subsequently waking it up, especially if the lock in question is held for a very short time. That is because there is significant overhead to suspending and rescheduling a thread.  
				</para>
				
				<para>
					The locking technique can be changed to use a blocking strategy that suspends the thread, by means of setting the locking property to 'suspend'.
				</para>
			</sect3>

			<sect3 id="config-engine-threading-insert-into" revision="1">
				<title>Preserving the order of events for insert-into streams</title>

				<para>
					In multithreaded environments, this setting controls whether statements producing events for other statements via insert-into preserve the order of delivery within the producing and consuming statements, allowing statements that consume other statement's events to behave deterministic in multithreaded applications, if the consuming statement requires such determinism. By default, the engine makes this guarantee (the setting is on).
				</para>

				<para>
					Take, for example, an application where a single statement (S1) inserts events into a stream that another statement (S2) further evaluates. A multithreaded application may have multiple threads processing events into statement S1. As statement S1 produces events for consumption by statement S2, such results may need to be delivered in the exact order produced as the consuming statement may rely on the order received. For example, if the first statement counts the number of events, the second statement may employ a pattern that inspects counts and thus expect the counts posted by statement S1 to continuously increase by 1 even though multiple threads process events. 
				</para>

				<para>
					The engine may need to block a thread such that order of delivery is maintained, and statements that require order (such as pattern detection, previous and prior functions) receive a deterministic order of events. The settings available control the blocking technique and parameters. As described in the section immediately prior, the default blocking technique employs spin locks per statement inserting events for consumption, as the locks in questions are typically held a very short time. The 'suspend' blocking technique can be configured and a timeout value can also defined.
				</para>
				
				<para>
					The XML configuration file may change settings via the following elements:
				</para>
					<programlisting><![CDATA[<engine-settings>
  <defaults>
    <threading>
      <insert-into-dispatch preserve-order="true" timeout-msec="100" locking="spin"/>
    </threading>
  </defaults>
</engine-settings>]]></programlisting>
			</sect3>

			<sect3 id="config-engine-threading-internal-timer" revision="1">
				<title>Internal Timer Settings</title>

				<para>
					This option can be used to disable the internal timer thread and such have the application supply external time events, as well as to set a timer resolution.
				</para>

				<para>
					The next code snippet shows how to disable the internal timer thread via the configuration API:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
  config.getEngineDefaults().getThreading().setInternalTimerEnabled(false);]]></programlisting>
  
				<para>
					This snippet of XML configuration leaves the internal timer enabled (the default) and sets a resolution of 200 milliseconds (the default is 100 milliseconds):
				</para>
				<programlisting><![CDATA[<engine-settings>
  <defaults>
    <threading>
      <internal-timer enabled="true" msec-resolution="200"/>
    </threading>
  </defaults>
</engine-settings>]]></programlisting>

				<para>
					We recommend that when disabling the internal timer, applications send an external timer event setting the start time before creating statements,
					such that statement start time is well-defined.
				</para>
			</sect3>
			
			<sect3 id="config-engine-threading-advanced" revision="1">
				<title>Advanced Threading Options</title>

				<para>
					The settings described herein are for enabling advanced threading options for inbound, outbound, timer and route executions.
				</para>

				<para>
					Take the next snippet of XML configuration as an example. It configures all threading options to 2 threads, which may not be suitable to your application, however demonstrates the configuration:
				</para>
				<programlisting><![CDATA[<engine-settings>
  <defaults>
    <threading>
      <threadpool-inbound enabled="true" num-threads="2"/>
      <threadpool-outbound enabled="true" num-threads="2" capacity="1000"/>
      <threadpool-timerexec enabled="true" num-threads="2"/>
      <threadpool-routeexec enabled="true" num-threads="2"/>
    </threading>
  </defaults>
</engine-settings>]]></programlisting>

				<para>
					By default, queues are unbound and backed by <literal>java.util.concurrent.LinkedBlockingQueue</literal>. 
					The optional <literal>capacity</literal> attribute can be set to instruct the threading option to configure a capacity-bound queue with a sender-wait (blocking put) policy, backed <literal>ArrayBlockingQueue</literal>.
				</para>

				<para>
					This example uses the API for configuring inbound threading :
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getThreading().setThreadPoolInbound(true);
config.getEngineDefaults().getThreading().setThreadPoolInboundNumThreads(2);]]></programlisting>

				<para>
					With a bounded work queue, the queue size and pool size should be tuned together. A large queue coupled with a small pool can help reduce memory usage, CPU usage, and context switching, at the cost of potentially constraining throughput.
				</para>

			</sect3>
		</sect2>

		<sect2 id="config-engine-eventmeta" revision="1">
			<title>Engine Settings related to Event Metadata</title>
			
			<sect3 id="config-engine-eventmeta-propertyreso" revision="1">
				<title>Java Class Property Names, Case Sensitivity and Accessor Style</title>

				<para>
					The engine-wide settings discussed here are used when you want to control case sensitivity or accessor style for all event classes as a default. The two settings are found under <literal>class-property-resolution</literal> under <literal>event-meta</literal> in the XML configuration.
				</para>
				
				<para>
				  To control the case sensitivity as discussed in <xref linkend="config-java-property-case-sensitivity"/>, add the <literal>style</literal> attribute in the XML configuration to set a default case sensitivity applicable to all event classes unless specifically overridden by class-specific configuration. 
				  The default case sensitivity is <literal>case_sensitive</literal> (case sensitivity turned on).
				</para>

				<para>
				  To control the accessor style as discussed in <xref linkend="config-java-legacy"/>, add the <literal>accessor-style</literal> attribute in the XML configuration to set a default accessor style applicable to all event classes unless specifically overridden by class-specific configuration. The default accessor style is <literal>javabean</literal> JavaBean accessor style.
				</para>

				<para>
					The next code snippet shows how to control this feature via the API:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getEventMeta().setClassPropertyResolutionStyle(
    Configuration.PropertyResolutionStyle.CASE_INSENSITIVE);
config.getEngineDefaults().getEventMeta().setDefaultAccessorStyle(
    ConfigurationEventTypeLegacy.AccessorStyle.PUBLIC);]]></programlisting>
			</sect3>
		</sect2>

		<sect2 id="config-engine-viewresources" revision="1">
			<title>Engine Settings related to View Resources</title>
			
			<sect3 id="config-engine-viewresources-sharing" revision="1">
				<title>Sharing View Resources between Statements</title>

				<para>
				   The engine by default attempts to optimize resource usage and thus re-uses or shares views between statements that declare same views. However, in multi-threaded environments, this can lead to reduced concurrency as 
				   locking for shared view resources must take place. Via this setting this behavior can be turned off for higher concurrency in multi-threaded processing.
				</para>

				<para>
					The next code snippet outlines the API to turn off view resource sharing between statements:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getViewResources().setShareViews(false);]]></programlisting>
			</sect3>

			<sect3 id="config-engine-viewresources-multipolicy" revision="1">
				<title>Configuring Multi-Expiry Policy Defaults</title>

				<para>
				   By default, when combining multiple data window views, Esper applies an intersection of the data windows unless the <literal>retain-union</literal> keyword is provided which instructs to apply an union. The setting described herein may be used primarily for backward compatibility to instruct that intersection should not be the default.
				</para>
								
				<para>
				   Here is a sample statement that specifies multiple expiry policies:
				</para>
				<programlisting><![CDATA[select * from MyEvent.std:unique(price).std:unique(quantity)]]></programlisting>

				<para>
				   By default Esper applies intersection as described in <xref linkend="epl-from-clause-view-multidatawindow"/>. 
				</para>
				
				<para>
				   Here is the setting to allow multiple data windows without the intersection default:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getViewResources().setAllowMultipleExpiryPolicies(true);]]></programlisting>

				<para>
				   When setting this option to true, and when using multiple data window views for a given stream, the behavior is as follows: The top-most data window receives an insert stream of events. It passes each insert stream event to each further data window view in the chain. Each data window view may remove events according to its expiry policy. Such remove stream events are only passed to data window views further in the chain, and are not made available to data window views earlier in the chain.
				</para>

				<para>
				   It is recommended to leave the default setting at false.
				</para>

			</sect3>
		</sect2>

		<sect2 id="config-engine-logging" revision="1">
			<title>Engine Settings related to Logging</title>
			
			<sect3 id="config-engine-logging-execpath" revision="1">
				<title>Execution Path Debug Logging</title>

				<para>
				   By default, the engine does not produce debug output for the event processing execution paths even when Log4j or Logger configurations have been set to output debug level logs.
				   To enable debug level logging, set this option in the configuration as well as in your Log4j configuration file.
				</para>

				<para>
					Statement-level processing information can be output via the <literal>@Audit</literal> annotation, please see <xref linkend="devlifecycle-debugging-audit"/>.
				</para>

				<para>
				   When debug-level logging is enabled by setting the flag as below and by setting DEBUG in the Log4j configuration file, then the timer processing may produce extensive debug output that
				   you may not want to have in the log file. The <literal>timer-debug</literal> setting in the XML or via API as below disables timer debug output which is enabled by default.
				</para>

				<para>
					The API to use to enable debug logging and disable timer event output is shown here:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getLogging().setEnableExecutionDebug(true);
config.getEngineDefaults().getLogging().setEnableTimerDebug(false);]]></programlisting>

				<para>
					Note: this is a configuration option that applies to all engine instances of a given Java module or VM.
				</para>

				<para>
					The XML snippet is:
				</para>
				<programlisting><![CDATA[<esper-configuration>
  <engine-settings>
    <defaults>
      <logging>
        <execution-path enabled="true"/>
        <timer-debug enabled="false"/>
    </logging>
    </defaults>
  </engine-settings>
</esper-configuration>]]></programlisting>
			</sect3>

			<sect3 id="config-engine-logging-queryplan" revision="1">
				<title>Query Plan Logging</title>

				<para>
				   By default, the engine does not produce query plan output unless logging at debug-level. 
				   To enable query plan logging, set this option in the configuration. When enabled, the engine reports, at INFO level, any query plans under the log name <literal>com.espertech.esper.queryplan</literal>.
				</para>

				<para>
					The API to use to enable query plan logging is shown here:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getLogging().setEnableQueryPlan(true);]]></programlisting>

				<para>
					The XML snippet is:
				</para>
				<programlisting><![CDATA[<esper-configuration>
  <engine-settings>
    <defaults>
      <logging>
        <query-plan enabled="true"/>
    </logging>
    </defaults>
  </engine-settings>
</esper-configuration>]]></programlisting>
			</sect3>

			<sect3 id="config-engine-logging-jdbc" revision="1">
				<title>JDBC Logging</title>

				<para>
				   By default, the engine does not measure JDBC query execution times or report the number of rows returned from a JDBC query through logging. 
				   To enable JDBC logging, set this option in the configuration. When enabled, the engine reports, at INFO level, any JDBC query performance and number of rows returned under the log name <literal>com.espertech.esper.jdbc</literal>.
				</para>

				<para>
					The API to use to enable query plan logging is shown here:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getLogging().setEnableJDBC(true);]]></programlisting>

				<para>
					The XML snippet is:
				</para>
				<programlisting><![CDATA[<esper-configuration>
  <engine-settings>
    <defaults>
      <logging>
        <jdbc enabled="true"/>
    </logging>
    </defaults>
  </engine-settings>
</esper-configuration>]]></programlisting>
			</sect3>
		</sect2>

		<sect2 id="config-engine-variables" revision="1">
			<title>Engine Settings related to Variables</title>
			
			<sect3 id="config-engine-variables-lifetimeold" revision="1">
				<title>Variable Version Release Interval</title>

				<para>
				   This setting controls the length of time that the engine retains variable versions for use by statements that use variables and that execute, within the same statement for the same event, longer then the time interval.
				   By default, the engine retains 15 seconds of variable versions.
				</para>

				<para>
				   For statements that use variables and that execute (in response to a single timer or other event) longer then the time period, the engine returns the current variable version at the time the statement executes, thereby softening the guarantee of consistency of variable values within the long-running statement. Please see <xref linkend="variable_using"/> for more information.
				</para>

				<para>
					The XML configuration for this setting is shown below:
				</para>
					<programlisting><![CDATA[<engine-settings>
  <defaults>
    <variables>
      <msec-version-release value="15000"/>
    </variables>
  </defaults>
</engine-settings>]]></programlisting>

			</sect3>
		</sect2>

		<sect2 id="config-engine-stream-selection" revision="1">
			<title>Engine Settings related to Stream Selection</title>
			
			<sect3 id="config-engine-streamselect-choices" revision="1">
				<title>Default Statement Stream Selection</title>

				<para>
				   Statements can produce both insert stream (new data) and remove stream (old data) results. Remember that insert stream refers to arriving events and new aggregation values, while remove stream refers to events leaving data windows and prior aggregation values. By default, the engine delivers only the insert stream to listeners and observers of a statement.
				</para>
				   
				<para>
				   There are keywords in the <literal>select</literal> clause that instruct the engine to not generate insert stream and/or remove stream results if your application does not need either one of the streams. These keywords are the <literal>istream</literal>, <literal>rstream</literal> and the <literal>irstream</literal> keywords. 
				</para>

				<para>
				   By default, the engine only generates insert stream results equivalent to using the optional <literal>istream</literal> keyword in the <literal>select</literal> clause.
				   If you application requires insert and remove stream results for many statements, your application can add the <literal>irstream</literal> keyword to the <literal>select</literal> clause of each statement,
				   or you can set a new default stream selector via this setting.
				</para>

				<para>
					The XML configuration for this setting is shown below:
				</para>
					<programlisting><![CDATA[<engine-settings>
  <defaults>
    <stream-selection>
      <stream-selector value="irstream" />
    </stream-selection>
  </defaults>
</engine-settings>]]></programlisting>

				<para>
					The equivalent code snippet using the configuration API is here:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getStreamSelection()
    .setDefaultStreamSelector(StreamSelector.RSTREAM_ISTREAM_BOTH);]]></programlisting>
			</sect3>
		</sect2>

		<sect2 id="config-engine-time-source" revision="1">
			<title>Engine Settings related to Time Source</title>
			
			<sect3 id="config-engine-timesource-choices" revision="1">
				<title>Default Time Source</title>

				<para>
				   This setting only applies if internal timer events control engine time (default). If external timer events provide engine clocking, the setting does not apply.
				</para>

				<para>
				   By default, the internal timer uses the call <literal>System.currentTimeMillis()</literal> to determine engine time in milliseconds. Via this setting the internal timer can be instructed to use <literal>System.nanoTime()</literal> instead. Please see <xref linkend="api-time-resolution"/> for more information. 
				</para>
				   
				<para>
					Note: This is a Java VM global setting. If running multiple engine instances in a Java VM, the timer setting is global and applies to all engine instances in the same Java VM, for performance reasons.
				</para>

				<para>
					A sample XML configuration for this setting is shown below, whereas the sample setting sets the time source to the nanosecond time provider:
				</para>
					<programlisting><![CDATA[<engine-settings>
  <defaults>
    <time-source>
      <time-source-type value="nano" />
    </time-source>
  </defaults>
</engine-settings>]]></programlisting>

				<para>
					The equivalent code snippet using the configuration API is here:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getTimeSource().
      setTimeSourceType(ConfigurationEngineDefaults.TimeSourceType.NANO);]]></programlisting>
			</sect3>
		</sect2>

		<sect2 id="config-engine-instrumentation" revision="1">
			<title>Engine Settings related to Metrics Reporting</title>

			<para>
				This section explains how to enable and configure metrics reporting, which is by default disabled. Please see <xref linkend="api-instrumentation"/> for more information on the metrics data reported to your application.
			</para>

			<para>
				The flag that enables metrics reporting is global to a Java virtual machine. If metrics reporting is enabled, the overhead incurred for reporting metrics is carried by all engine instances per Java VM.
			</para>

			<para>
				Metrics reporting occurs by an engine-controlled separate daemon thread that each engine instance starts at engine initialization time, if metrics reporting and threading is enabled (threading enabled is the default).
			</para>
			
			<para>
			    Engine and statement metric intervals are in milliseconds. A negative or zero millisecond interval value may be provided to disable reporting.
			</para>

			<para>
			    To control statement metric reporting for individual statements or groups of statements, the engine provides a facility that groups statements by statement name. 
			    Each such statement group may have different reporting intervals configured, and intervals can be
			    changed at runtime through runtime configuration. A statement group is assigned a group name at configuration time to identify the group.
			</para>

			<para>
			    Metrics reporting configuration is part of the engine default settings. All configuration options are also available via the <literal>Configuration</literal> API.
			</para>

			<para>
			    A sample XML configuration is shown below:
			</para>
			<programlisting><![CDATA[<engine-settings>
  <defaults>
    <metrics-reporting enabled="true" engine-interval="1000" statement-interval="1000" 
        threading="true"/>
  </defaults>
</engine-settings>]]></programlisting>

			<para>
			    The <literal>engine-interval</literal> setting (defaults to 10 seconds) determines the frequency in milliseconds at which the engine reports engine metrics, in this example every 1 second. The <literal>statement-interval</literal> is for statement metrics. The <literal>threading</literal> flag is true by default since reporting takes place by a dedicated engine thread and can be set to false to use the external or internal timer thread instead.
			</para>

			<para>
			    The next example XML declares a statement group: The statements that have statement names that fall within the group follow a different reporting frequency:
			</para>

			<programlisting><![CDATA[<metrics-reporting enabled="true" statement-interval="0">
  <stmtgroup name="MyStmtGroup" interval="2000" default-include="true" num-stmts="100" 
        report-inactive="true">
    <exclude-regex>.*test.*</exclude-regex>
  </stmtgroup>
</metrics-reporting>]]></programlisting>

			<para>
			    The above example configuration sets the <literal>statement-interval</literal> to zero to disable reporting for all statements. It defines a statement group by name <literal>MyStmtGroup</literal> and specifies a 2-second interval. The example sets the <literal>default-include</literal> flag to true (by default false) to include all statements in the statement group. The example also sets <literal>report-inactive</literal> to true (by default false) to report inactive statements.
			</para>
			
			<para>
			  The <literal>exclude-regex</literal> element may be used to specify a regular expression that serves to exclude statements from the group. Any statement whose statement name matches the exclude regular expression is not included in the group. In the above example, all statements with the characters 'test' inside their statement name are excluded from the group.
			</para>

			<para>
			  Any statement not belonging to any of the statement groups follow the configured statement interval. 
			</para>

			<para>
			 There are additional elements available to include and exclude statements: <literal>include-regex</literal>, <literal>include-like</literal> and <literal>exclude-like</literal>. The latter two apply SQL-like matching. All patterns are case-sensitive.
			</para>

			<para>
			 Here is a further example of a possible statement group definition, which includes statements whose statement name have the characters <literal>@REPORT</literal> or <literal>@STREAM</literal>, and excludes statements whose statement name have the characters <literal>@IGNORE</literal> or <literal>@METRICS</literal> inside.
			</para>

			<programlisting><![CDATA[<metrics-reporting enabled="true">
  <stmtgroup name="MyStmtGroup" interval="1000">
    <include-like>%@REPORT%</include-like>
    <include-regex>.*@STREAM.*</include-like>
    <exclude-like>%@IGNORE%</exclude-like>
    <exclude-regex>.*@METRICS.*</exclude-regex>
  </stmtgroup>
</metrics-reporting>]]></programlisting>
		</sect2>

		<sect2 id="config-engine-language" revision="1">
			<title>Engine Settings related to Language and Locale</title>
			
			<para>
				Locale-dependence in Esper can be present in the sort order of string values by the <literal>order by</literal> clause and by the sort view.
			</para>

			<para>
				By default, Esper sorts string values using the <literal>compare</literal> method that is not locale dependent. To enable local dependent sorting you must set the configuration flag as described below.
			</para>
			
			<para>
			 The XML configuration sets the locale dependent sorting as shown below:
			</para>

			<programlisting><![CDATA[<engine-settings>
  <defaults>
    <language sort-using-collator="true"/>
  </defaults>
</engine-settings>]]></programlisting>
			
			<para>
			 The API to change the setting:
			</para>

			<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getLanguage().setSortUsingCollator(true);]]></programlisting>

		</sect2>

		<sect2 id="config-engine-expression" revision="1">
			<title>Engine Settings related to Expression Evaluation</title>
			
			<sect3 id="config-engine-expression-division" revision="1">
				<title>Integer Division and Division by Zero</title>
				<para>
					By default Esper returns double-typed values for divisions regardless of operand types. Division by zero returns positive or negative double infinity.
				</para>
	
				<para>
					To have Esper use Java-standard integer division instead, use this setting as described here. In Java integer division, when dividing integer types, the result is an integer type. This means that if you divide an integer unevenly by another integer, it returns the whole number part of the result, does not perform any rounding and the fraction part is dropped. If Java-standard integer division is enabled, when dividing an integer numerator by an integer denominator, the result is an integer number. Thus the expression <literal>1 / 4</literal> results in an integer zero. Your EPL must then convert at least one of the numbers to a double value before the division, for example by specifying <literal>1.0 / 4</literal> or by using <literal>cast(myint, double)</literal>.
				</para>
				
				<para>
					When using Java integer division, division by zero for integer-typed operands always returns null. However division by zero for double-type operands still returns positive or negative double infinity. To also return null upon division by zero for double-type operands, set the flag to true as below (default is false).
				</para>
	
				<para>
				 The XML configuration is as follows:
				</para>
	
				<programlisting><![CDATA[<engine-settings>
  <defaults>
    <expression integer-division="false" division-by-zero-is-null="false"/>
  </defaults>
</engine-settings>]]></programlisting>
			
				<para>
				 The API to change the setting:
				</para>
	
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getExpression().setIntegerDivision(true);
config.getEngineDefaults().getExpression().setDivisionByZeroReturnsNull(true);]]></programlisting>
			</sect3>

			<sect3 id="config-engine-expression-subselecteval" revision="1">
				<title>Subselect Evaluation Order</title>
				<para>
					By default Esper updates sub-selects with new events before evaluating the enclosing statement. This is relevant for statements that look for the same event in both the <literal>from</literal> clause and subselects.
				</para>
	
				<para>
					To have Esper evaluate the enclosing clauses before updating the subselect in a subselect expression, set the flag as indicated herein.
				</para>
				
				<para>
					 The XML configuration as below sets the same as the default value:
				</para>
	
				<programlisting><![CDATA[<engine-settings>
  <defaults>
    <expression self-subselect-preeval="true"/>
  </defaults>
</engine-settings>]]></programlisting>
			
				<para>
					 Here is a sample statement that utilitzes a sub-select against the same-events:
				</para>
	
				<programlisting><![CDATA[select * from MyEvent where prop not in (select prop from MyEvent.std:unique(otherProp))]]></programlisting>

				<para>
					 By default the subselect data window updates first before the <literal>where</literal> clause is evaluated, thereby above statement never returns results.
				</para>

				<para>
					 Changing the setting described here causes the <literal>where</literal> clause to evaluate before the subselect data window updates, thereby the statement does post results.
				</para>
			</sect3>

			<sect3 id="config-engine-expression-udfcache" revision="1">
				<title>User-Defined Function or Static Method Cache</title>
				<para>
					By default Esper caches the result of an user-defined function if the parameter set to that function is empty or all parameters are constant values. Custom plug-in single-row function results are not cached.
				</para>
	
				<para>
					To have Esper evaluate the user-defined function regardless of constant parameters, set the flag as indicated herein.
				</para>
				
				<para>
					 The XML configuration as below sets the same as the default value:
				</para>
	
				<programlisting><![CDATA[<engine-settings>
  <defaults>
    <expression udf-cache="true"/>
  </defaults>
</engine-settings>]]></programlisting>			
			</sect3>

			<sect3 id="config-engine-expression-extendedagg" revision="1">
				<title>Extended Built-in Aggregation Functions</title>
				<para>
					By default Esper provides a number of additional aggregation functions over the SQL standards. To have Esper only allow the standard SQL aggregation functions and not the additional ones,
					disable the setting as described here.
				</para>
	
				<para>
					 The XML configuration as below sets the same as the default value:
				</para>
	
				<programlisting><![CDATA[<engine-settings>
  <defaults>
    <expression extend-agg="true"/>
  </defaults>
</engine-settings>]]></programlisting>			
			</sect3>

			<sect3 id="config-engine-expression-ducktype" revision="1">
				<title>Duck Typing</title>
				<para>
					By default Esper validates method references when using the dot operator syntax at time of statement creation. With duck typing, the engine resolves method references at runtime.
				</para>
	
				<para>
					 The XML configuration as below sets the same as the default value:
				</para>
	
				<programlisting><![CDATA[<engine-settings>
  <defaults>
    <expression ducktyping="false"/>
  </defaults>
</engine-settings>]]></programlisting>			
			</sect3>
		</sect2>

		<sect2 id="config-engine-execution" revision="1">
			<title>Engine Settings related to Execution of Statements</title>
			
			<sect3 id="config-engine-execution-prioritized" revision="1">
				<title>Prioritized Execution</title>
				<para>
					By default Esper ignores @Priority and @Drop annotations and executes unprioritized, that is the engine does not attempt to interpret assigned priorities and reorder executions based on priority. Use this setting if your application requires prioritized execution.
				</para>
		
				<para>
					By setting this configuration, the engine executes statements, when an event or schedule matches multiple statements, according to the assigned priority, starting from the highest priority value. See built-in EPL annotations in <xref linkend="epl-syntax-annotation-priority"/>.
				</para>

				<para>
					By enabling this setting view sharing between statements as described in <xref linkend="config-engine-viewresources-sharing"/> is disabled.
				</para>

				<para>
					 The XML configuration to enable the flag, which is disabled by default, is as follows:
				</para>
	
				<programlisting><![CDATA[<engine-settings>
  <defaults>
    <execution prioritized="true"/>
  </defaults>
</engine-settings>]]></programlisting>
			
				<para>
				 The API to change the setting:
				</para>
	
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getExecution().setPrioritized(true);]]></programlisting>
			</sect3>

			<sect3 id="config-engine-execution-fairlock" revision="1">
				<title>Fair Locking</title>
				<para>
					By default Esper configures statement-level locks without fair locking. If your application is multi-threaded and performs very frequent reads via iterator or fire-and-forget queries, you may need to set this flag to prevent lock starvation in the face of concurrent reads and writes. Please consult the Java API documentation under <literal>ReentrantReadWriteLock</literal> and <emphasis>Fair Mode</emphasis> for more information.
				</para>
		
				<para>
					 The XML configuration to enable fair locking, which is disabled by default, is as follows:
				</para>
	
				<programlisting><![CDATA[<engine-settings>
  <defaults>
    <execution fairlock="true"/>
  </defaults>
</engine-settings>]]></programlisting>
			
				<para>
				 The API to change the setting:
				</para>
	
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getExecution().setFairlock(true);]]></programlisting>
			</sect3>
		</sect2>

		<sect2 id="config-engine-exceptionhandling" revision="1">
			<title>Engine Settings related to Exception Handling</title>
			
			<para>
				Use the settings as described here to register an exception handler factory class that provides an exception handler. The engine invokes exception handlers in the order they are listed to handle a continues-query unchecked exception, as further described in <xref linkend="api-exception"/>.
			</para>

			<para>
				Please provide the full-qualified class name of each class that implements the <literal>com.espertech.esper.client.hook.ExceptionHandlerFactory</literal> interface in the engine defaults configuration as below.
			</para>
	
			<para>
				 The XML configuration is as follows:
			</para>

			<programlisting><![CDATA[<engine-settings>
  <defaults>
    <exceptionHandling>
      <handlerFactory class="my.company.cep.MyCEPEngineExceptionHandlerFactory"/>
    </exceptionHandling>
  </defaults>
</engine-settings>]]></programlisting>
		
			<para>
			 The API calls to register an exception handler factory are as follows:
			</para>
			<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getExceptionHandling().addClass(MyCEPEngineExceptionHandlerFactory.class);]]></programlisting>
	
		</sect2>

		<sect2 id="config-engine-conditionhandling" revision="1">
			<title>Engine Settings related to Condition Handling</title>
			
			<para>
				Use the settings as described here to register a condition handler factory class that provides a condition handler. The engine invokes condition handlers in the order they are listed to indicate conditions, which is the term used for notification when certain predefined limits are reached, as further described in <xref linkend="api-condition"/>.
			</para>

			<para>
				Please provide the full-qualified class name of each class that implements the <literal>com.espertech.esper.client.hook.ConditionHandlerFactory</literal> interface in the engine defaults configuration as below.
			</para>
	
			<para>
				 The XML configuration is as follows:
			</para>

			<programlisting><![CDATA[<engine-settings>
  <defaults>
    <conditionHandling>
      <handlerFactory class="my.company.cep.MyCEPEngineConditionHandlerFactory"/>
    </conditionHandling>
  </defaults>
</engine-settings>]]></programlisting>
		
			<para>
			 The API calls to register a condition handler factory are as follows:
			</para>
			<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getConditionHandling().addClass(MyCEPEngineConditionHandlerFactory.class);]]></programlisting>
	
		</sect2>

		<sect2 id="config-revisionevent" revision="1">
			<title>Revision Event Type</title>
			
			<para>
			   Revision event types reflect a versioning relationship between events of same or different event types. Please refer to <xref linkend="eventrep-update"/> and <xref linkend="named_versioning"/>.
			</para>

			<para>
				The configuration consists of the following:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						An name of an event type whose events are <emphasis>base</emphasis> events.
					</para>
				</listitem>
				<listitem>
					<para>
						Zero, one or more names of event types whose events are <emphasis>delta</emphasis> events.
					</para>
				</listitem>
				<listitem>
					<para>
						One or more property names that supply the key values that tie base and delta events to existing revision events. Properties must exist on the event type as simple properties. Nested, indexed or mapped properties are not allowed.
					</para>
				</listitem>
				<listitem>
					<para>
						Optionally, a strategy for overlaying or merging properties. The default strategy is <emphasis>Overlay Declared</emphasis> as described below.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				The XML configuration for this setting is shown below:
			</para>
				<programlisting><![CDATA[<revision-event-type name="UserProfileRevisions">
  <base-event-type name="ProfileCreation"/>
  <delta-event-type name="ProfileUpdate"/>
  <key-property name="userid"/>
</revision-event-type>]]></programlisting>

			<para>
				If configuring via runtime or initialization-time API, this code snippet explains how:
			</para>
			<programlisting><![CDATA[Configuration config = new Configuration();
ConfigurationRevisionEventType configRev = new ConfigurationRevisionEventType();
configRev.setNameBaseEventType("ProfileCreation");
configRev.addNameDeltaEventType("ProfileUpdate");
configRev.setKeyPropertyNames(new String[] {"userid"});
config.addRevisionEventType("UserProfileRevisions", configRev);]]></programlisting>

			<para>
				As the configuration provides names of base and delta event types, such names must be configured for JavaBean, Map or XML events as the previous sections outline.
			</para>

			<para>
				The next table outlines the available strategies:
			</para>

			<table frame="topbot">
				<title>Property Revision Strategies</title>
				<tgroup cols="2">
					<colspec colwidth="0.5*"/>
					<colspec colwidth="2*"/>
					<thead>
						<row>
							<entry>Name</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>Overlay Declared (default)</entry>
							<entry>
								<para>A fast strategy for revising events that groups properties provided by base and delta events and overlays contributed properties to compute a revision.</para>
								<para>For use when there is a limited number of combinations of properties that change on an event, and such combinations are known in advance.</para>
							    <para>The properties available on the output revision events are all properties of the base event type. Delta event types do not add any additional properties that are not present on the base event type.</para>
								<para>Any null values or non-existing property on a delta (or base) event results in a null values for the same property on the output revision event.</para>
							</entry>
						</row>
						<row>
							<entry>Merge Declared</entry>
							<entry> 
							    <para>A strategy for revising events by merging properties provided by base and delta events, considering null values and non-existing (dynamic) properties as well.</para>
							    <para>For use when there is a limited number of combinations of properties that change on an event, and such combinations are known in advance.</para>
							    <para>The properties available on the output revision events are all properties of the base event type plus all additional properties that any of the delta event types provide.</para>
								<para>Any null values or non-existing property on a delta (or base) event results in a null values for the same property on the output revision event.</para>
							</entry>
						</row>
						<row>
							<entry>Merge Non-null</entry>
							<entry>
							    <para>A strategy for revising events by merging properties provided by base and delta events, considering only non-null values.</para>
								<para>For use when there is an unlimited number of combinations of properties that change on an event, or combinations are not known in advance.</para>
							    <para>The properties available on the output revision events are all properties of the base event type plus all additional properties that any of the delta event types provide.</para>
								<para>Null values returned by delta (or base) event properties provide no value to output revision events, i.e. null values are not merged.</para>
							</entry>
						</row>
						<row>
							<entry>Merge Exists</entry>
							<entry>
								 <para>A strategy for revising events by merging properties provided by base and delta events, considering only values supplied by event properties that exist.</para>
								 <para>For use when there is an unlimited number of combinations of properties that change on an event, or combinations are not known in advance.</para>
							    <para>The properties available on the output revision events are all properties of the base event type plus all additional properties that any of the delta event types provide.</para>
								 <para>All properties are treated as dynamic properties: If an event property does not exist on a delta event (or base) event the property provides no value to output revision events, i.e. non-existing property values are not merged.</para>
							</entry>							
						</row>
					</tbody>
				</tgroup>
			</table>

		</sect2>

		<sect2 id="config-variantstream" revision="1">
			<title>Variant Stream</title>
			
			<para>
			   A <emphasis>variant stream</emphasis> is a predefined stream into which events of multiple disparate event types can be inserted, and which can be selected from in patterns and the <literal>from</literal> clause.
			</para>

			<para>
				The name of the variant stream and, optionally, the type of events that the stream may accept, are part of the stream definition. By default, the variant stream accepts only the predefined event types. The engine validates your <literal>insert into</literal> clause which inserts into the variant stream against the predefined types.
			</para>
			
			<para>
				A variant stream can be set to accept any type of event, in which case all properties of the variant stream are effectively dynamic properties. Set the <literal>type variance</literal> flag to <literal>ANY</literal> to indicate the variant stream accepts any type  of event.
			</para>

			<para>
				The following XML configuration defines a variant stream by name <literal>OrderStream</literal> that carries only <literal>PartsOrder</literal> and <literal>ServiceOrder</literal> events:
			</para>
			<programlisting><![CDATA[<variant-stream name="OrderStream">
  <variant-event-type name="PartsOrder"/>
  <variant-event-type name="ServiceOrder"/>
</variant-stream>]]></programlisting>

			<para>
				This code snippet sets up a variant stream by name <literal>OutgoingEvent</literal>:
			</para>
			<programlisting><![CDATA[Configuration config = new Configuration();
ConfigurationVariantStream variant = new ConfigurationVariantStream();
variant.setTypeVariance(ConfigurationVariantStream.TypeVariance.ANY);
config.addVariantStream("OutgoingEvent", variant);]]></programlisting>

			<para>
				If specifying variant event type names, make sure such names have been configured for JavaBean, Map or XML events.
			</para>

		</sect2>

    </sect1>
    
	<sect1 id="configuration-type-names" revision="1">
        <title>Type Names</title>
        
        <para>
			Certain configuration values accept type names. Type names can occur in the configuration of variable types, Map-event property types as well as XPath cast types, for example. Types names are not case-sensitive.
		</para>
        
        <para>
			The table below outlines all possible type names:
		</para>

		<table frame="topbot">
			<title>Variable Type Names</title>
			<tgroup cols="2">
				<colspec colwidth="1.5*"/>
				<colspec colwidth="2*"/>
				<thead>
					<row>
						<entry>Type Name</entry>
						<entry>Type</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry><literal>string</literal>, <literal>varchar</literal>, <literal>varchar2</literal> or <literal>java.lang.String</literal></entry>
						<entry>A string value</entry>
					</row>
					<row>
						<entry><literal>int</literal>, <literal>integer</literal> or <literal>java.lang.Integer</literal></entry>
						<entry>An integer value</entry>
					</row>
					<row>
						<entry><literal>long</literal> or <literal>java.lang.Long</literal></entry>
						<entry>A long value</entry>
					</row>
					<row>
						<entry><literal>bool</literal>, <literal>boolean</literal> or <literal>java.lang.Boolean</literal></entry>
						<entry>A boolean value</entry>
					</row>
					<row>
						<entry><literal>double</literal> or <literal>java.lang.Double</literal></entry>
						<entry>A double value</entry>
					</row>
					<row>
						<entry><literal>float</literal> or <literal>java.lang.Float</literal></entry>
						<entry>A float value</entry>
					</row>
					<row>
						<entry><literal>short</literal> or <literal>java.lang.Short</literal></entry>
						<entry>A short value</entry>
					</row>
					<row>
						<entry><literal>char</literal>, <literal>character</literal> or <literal>java.lang.Character</literal></entry>
						<entry>A character value</entry>
					</row>
					<row>
						<entry><literal>byte</literal> or <literal>java.lang.Byte</literal></entry>
						<entry>A byte value</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
		    
    </sect1>

	<sect1 id="configuration-runtime">		
		<title>Runtime Configuration</title>

		<indexterm><primary>configuration</primary><secondary>runtime</secondary></indexterm>
		<para>
			Certain configuration changes are available to perform on an engine instance while in operation. Such configuration operations are available via the <literal>getConfiguration</literal> method on <literal>EPAdministrator</literal>,
			which returns an <literal>ConfigurationOperations</literal> object. Please consult the JavaDoc documentation for more detail.
		</para>
	</sect1>

	<sect1 id="configuration-logging">		
		<title>Logging Configuration</title>

		<indexterm><primary>configuration</primary><secondary>logging</secondary></indexterm>
		<para>
		   Esper logs all messages to Apache commons logging under an appropriate log level. To output log messages you can add Log4j to classpath and configure Log4j as below.
		</para>
		
		<para>
			Esper's only direct dependency for logging is the Apache Commons Logging interfaces. You may use Log4j as described here, or you may use SLF4J instead (for example) as described in http://www.slf4j.org/legacy.html. You can also redirect SLF4J to any backend you want - nop, logback, jul as needed.
		</para>
		
		<para>
			Statement-level processing information can be output, please see <xref linkend="devlifecycle-debugging-audit"/>.
		</para>

		<para>
		   For performance reasons, Esper does not log any debug-level or informational-level messages for event execution unless explicitly configured via <xref linkend="config-engine-logging-execpath"/>.
		</para>

		<para>
			A callback API for receiving certain critical engine reports is available as described in <xref linkend="api-exception"/>.
		</para>
		
		<para>
		  More information on configuring engine-level settings for logging are at <xref linkend="config-engine-logging"/>.
		</para>

		<para>
			Apache Commons Logging uses an automatic discovery mechanism to find a log framework that it will delegate to.  If your application has another component using logback, please inspect you logback configuration and add <literal>com.espertech</literal>.
		</para>

		<para>
		   The next table explains the log levels:
		</para>

		<table frame="topbot">
			<title>Log Levels</title>
			<tgroup cols="2">
				<colspec colwidth=".5*"/>
				<colspec colwidth="1*"/>
				<thead>
					<row>
						<entry>Log Level</entry>
						<entry>Use</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Debug</entry>
						<entry>Displays detailed engine-internal information that may not be easy to understand for application developers but are useful for engine support.</entry>
					</row>
					<row>
						<entry>Info</entry>
						<entry>Used for a few critical engine-level log messages.</entry>
					</row>
					<row>
						<entry>Warn</entry>
						<entry>Certain important warning or informational messages are displayed under the warning level.</entry>
					</row>
					<row>
						<entry>Error</entry>
						<entry>Exceptions reported within the engine or by plug-in components are reported under the error level. When users enter invalid EPL statements such validation errors are not reported as error logs and are indicated via API exception instead.</entry>
					</row>
				</tbody>
			</tgroup>
			
		</table>
		
		<sect2 id="configuration-logging-log4j">		
			<title>Log4j Logging Configuration</title>
			
			<para>
				Log4j is the default logging component. Please find additional information for Log4j configuration and extension in <ulink url="http://logging.apache.org/log4j">http://logging.apache.org/log4j</ulink>.
			</para>
			
			<para>
				The easiest way to configure Log4j is by providing a Log4J configuration file, similar to the <literal>log4j.xml</literal> file shipped in the <literal>etc</literal> folder of the distribution.
			</para>

			<para>
				Add the <literal>log4j.configuration</literal> system property to the <literal>java</literal> command line and provide the file name of the Log4j configuration file, making sure your classpath also includes the directory of the file:
			</para>
			<programlisting><![CDATA[java -Dlog4j.configuration=log4j.xml ...]]></programlisting>
		</sect2>
	</sect1>

</chapter>
