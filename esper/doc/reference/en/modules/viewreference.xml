<chapter id="epl-views">
    <title>EPL Reference: Views</title>
        
		<indexterm><primary>views</primary><secondary>overview</secondary></indexterm>
		<indexterm><primary>data window views</primary><secondary>overview</secondary></indexterm>

        <para>
            This chapter outlines the views that are built into Esper. All views can be arbitrarily combined as many of the examples below show. 
			The section on <xref linkend="processingmodel"/> provides additional information on the relationship of views, filtering and aggregation. Please also see <xref linkend="epl-from-clause-view-spec"/> for the use of views in the <literal>from</literal> clause with streams, patterns and named windows.
        </para>
        
        <para>
            Esper organizes built-in views in namespaces and names. Views that provide sliding or tumbling data windows are in the <literal>win</literal> namespace. Other most commonly used views are in the <literal>std</literal> namespace. The <literal>ext</literal> namespace are views that order events. The <literal>stat</literal> namespace is used for views that derive statistical data.
        </para>

        <para>
            Esper distinguishes between data window views and derived-value views. Data windows, or data window views, are views that retain incoming events until an expiry policy indicates to release events. Derived-value views derive a new value from event streams and post the result as events of a new type.
        </para>
                
        <para>
            Two or more data window views can be combined. This allows a sets of events retained by one data window to be placed into a union or an intersection with the set of events retained by one or more other data windows. Please see <xref linkend="epl-from-clause-view-multidatawindow"/> for more detail.
        </para>

        <para>
			The keep-all data window counts as a data window but has no expiry policy: it retains all events received. The group-by data window allocates a new data window per group and thereby counts as a data window, but cannot appear alone.
        </para>

        <para>
            The next table summarizes data window views:
        </para>

	   <table frame="topbot">
			<title>Built-in Data Window Views</title>
			<tgroup cols="3">
				<colspec colwidth="1.5*"/>
				<colspec colwidth="2.0*"/>
				<colspec colwidth="2.0*"/>
				<thead>
					<row>
						<entry>View</entry>
						<entry>Syntax</entry>
						<entry>Description</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Length window</entry>
						<entry>win:length(<emphasis>size</emphasis>)</entry>
						<entry>Sliding length window extending the specified number of elements into the past.</entry>
					</row>
					<row>
						<entry>Length batch window</entry>
						<entry>win:length_batch(<emphasis>size</emphasis>)</entry>
						<entry>Tumbling window that batches events and releases them when a given minimum number of events has been collected.</entry>
					</row>
					<row>
						<entry>Time window</entry>
						<entry>win:time(<emphasis>time period</emphasis>)</entry>
						<entry>Sliding time window extending the specified time interval into the past.</entry>
					</row>
					<row>
						<entry>Externally-timed window</entry>
						<entry>win:ext_timed(<emphasis>timestamp expression</emphasis>, <emphasis>time period</emphasis>)</entry>
						<entry>Sliding time window, based on the millisecond time value supplied by an expression.</entry>
					</row>
					<row>
						<entry>Time batch window</entry>
						<entry>win:time_batch(<emphasis>time period</emphasis>[,<emphasis>optional reference point</emphasis>] [, <emphasis>flow control</emphasis>])</entry>
						<entry>Tumbling window that batches events and releases them every specified time interval, with flow control options.</entry>
					</row>
					<row>
						<entry>Time-Length combination batch window</entry>
						<entry>win:time_length_batch(<emphasis>time period, size [, flow control]</emphasis>)</entry>
						<entry>Tumbling multi-policy time and length batch window with flow control options.</entry>
					</row>
					<row>
						<entry>Time-Accumulating window</entry>
						<entry>win:time_accum(<emphasis>time period</emphasis>)</entry>
						<entry>Sliding time window accumulates events until no more events arrive within a given time interval.</entry>
					</row>
					<row>
						<entry>Keep-All window</entry>
						<entry>win:keepall()</entry>
						<entry>The keep-all data window view simply retains all events.</entry>
					</row>
					<row>
						<entry>Sorted window</entry>
						<entry>ext:sort(<emphasis>size, sort criteria</emphasis>)</entry>
						<entry>Sorts by values returned by sort criteria expressions and keeps only the top events up to the given size.</entry>
					</row>
					<row>
						<entry>Time-Order View</entry>
						<entry>ext:time_order(<emphasis>timestamp expression, time period</emphasis>)</entry>
						<entry>Orders events that arrive out-of-order, using an expression providing timestamps to be ordered.</entry>
					</row>
					<row>
						<entry>Unique</entry>
						<entry>std:unique(<emphasis>unique criteria(s)</emphasis>)</entry>
						<entry>Retains only the most recent among events having the same value for the criteria expression(s). Acts as a length window of size 1 for each distinct expression value.</entry>
					</row>
					<row>
						<entry>Group By</entry>
						<entry>std:groupby(<emphasis>grouping criteria(s)</emphasis>)</entry>
						<entry>Groups events into sub-views by the value of the specified expression(s), generally used to provide a separate data window per group.</entry>
					</row>
					<row>
						<entry>Last Event</entry>
						<entry>std:lastevent()</entry>
						<entry>Retains the last event, acts as a length window of size 1.</entry>
					</row>
					<row>
						<entry>First Event</entry>
						<entry>std:firstevent()</entry>
						<entry>Retains the very first arriving event, disregarding all subsequent events.</entry>
					</row>
					<row>
						<entry>First Unique</entry>
						<entry>std:firstunique(<emphasis>unique criteria(s)</emphasis>)</entry>
						<entry>Retains only the very first among events having the same value for the criteria expression(s), disregarding all subsequent events for same value(s).</entry>
					</row>
					<row>
						<entry>First Length</entry>
						<entry>win:firstlength(<emphasis>size</emphasis>)</entry>
						<entry>Retains the first <emphasis>size</emphasis> events, disregarding all subsequent events.</entry>
					</row>
					<row>
						<entry>First Time</entry>
						<entry>win:firsttime(<emphasis>time period</emphasis>)</entry>
						<entry>Retains the events arriving until the time interval has passed, disregarding all subsequent events.</entry>
					</row>
				</tbody>
			</tgroup>
		</table> 
		
		<indexterm><primary>derived-value views</primary><secondary>overview</secondary></indexterm>

        <para>
			The table below summarizes views that derive information from received events and present the derived information as an insert and remove stream of events that are typed specifically to carry the result of the computations: 
        </para>

	   <table frame="topbot">
			<title>Built-in Derived-Value Views</title>
			<tgroup cols="3">
				<colspec colwidth="1.5*"/>
				<colspec colwidth="2.0*"/>
				<colspec colwidth="2.0*"/>
				<thead>
					<row>
						<entry>View</entry>
						<entry>Syntax</entry>
						<entry>Description</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Size</entry>
						<entry>std:size()</entry>
						<entry>Derives a count of the number of events in a data window, or in an insert stream if used without a data window.</entry>
					</row>
					<row>
						<entry>Univariate statistics</entry>
						<entry>stat:uni(<emphasis>value expression</emphasis>)</entry>
						<entry>Calculates univariate statistics on the values returned by the expression.</entry>
					</row>
					<row>
						<entry>Regression</entry>
						<entry>stat:linest(<emphasis>value expression, value expression</emphasis>)</entry>
						<entry>Calculates regression on the values returned by two expressions.</entry>
					</row>
					<row>
						<entry>Correlation</entry>
						<entry>stat:correl(<emphasis>value expression, value expression</emphasis>)</entry>
						<entry>Calculates the correlation value on the values returned by two expressions.</entry>
					</row>
					<row>
						<entry>Weighted average</entry>
						<entry>stat:weighted_avg(<emphasis>value expression, value expression</emphasis>)</entry>
						<entry>Calculates weighted average given a weight expression and an expression to compute the average for.</entry>
					</row>
				</tbody>
			</tgroup>
		</table> 
        
		<sect3 id="view-parameters" >
		   <title>A Note on View Parameters</title>
		   
		   <para>
			   The syntax for view specifications starts with the namespace name and the name and is followed by optional view parameter expressions in parenthesis:
		   </para>
		   <synopsis><emphasis>namespace</emphasis>:<emphasis>name</emphasis>(<emphasis>view_parameters</emphasis>)</synopsis>

		   <para>
			   This example specifies a time window of 5 seconds:
		   </para>
			<programlisting><![CDATA[select * from StockTickEvent.win:time(5 sec)]]></programlisting>

		   <para>
			   All expressions are allowed as parameters to views, including expressions that contain variables or substitution parameters for prepared statements.
		   </para>

		   <para>
			   For example, assuming a variable by name <literal>VAR_WINDOW_SIZE</literal> is defined:
		   </para>
			<programlisting><![CDATA[select * from StockTickEvent.win:time(VAR_WINDOW_SIZE)]]></programlisting>

		   <para>
			   Expression parameters for views are evaluated at the time the view is first created. They are not continuously re-evaluated by built-in views. For applications that provide a custom plug-in view, such custom views may re-evaluate parameter expressions.
		   </para>

		   <para>
			   If a view takes no parameters, use empty parenthesis <literal>()</literal>.
		   </para>
		</sect3>

        <sect1 id="win-views" >
           <title>Window views</title>

			<para>
				All the views explained below are data window views, as are <literal>std:unique</literal>, <literal>std:firstunique</literal>, <literal>std:lastevent</literal> and <literal>std:firstevent</literal>.
			</para>
			
			<sect2 id="view-win-length" >
			   <title>Length window (<literal>win:length</literal>)</title>
		
				<indexterm><primary>length window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>length window</secondary></indexterm>
				<indexterm><primary>data window views</primary><secondary>length window</secondary></indexterm>

				<para>
					This view is a moving (sliding) length window extending the specified number of elements into the past. The view takes a single expression as a parameter providing a numeric size value that defines the window size:
				</para>
				<synopsis>win:length(<emphasis>size_expression</emphasis>)</synopsis>

				<para>
					The below example sums the price for the last 5 stock ticks for symbol GE.
				</para>
	
				<programlisting><![CDATA[select sum(price) from StockTickEvent(symbol='GE').win:length(5)]]></programlisting>

				<para>
					The next example keeps a length window of 10 events of stock trade events, with a separate window for each symbol. The
					sum of price is calculated only for the last 10 events for each symbol and aggregates per symbol:
				</para>
	
				<programlisting><![CDATA[select sum(price) from StockTickEvent.std:groupby(symbol).win:length(10) group by symbol]]></programlisting>
			</sect2>

			<sect2 id="view-win-length-batch" >
			   <title>Length batch window (<literal>win:length_batch</literal>)</title>
		
				<indexterm><primary>length batch window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>length batch window</secondary></indexterm>
				<indexterm><primary>data window views</primary><secondary>length batch window</secondary></indexterm>

				<para>
					This window view buffers events (tumbling window) and releases them when a given minimum number of events has been collected. Provide an expression defining the number of events to batch as a parameter:
				</para>
				<synopsis>win:length_batch(<emphasis>size_expression</emphasis>)</synopsis>

				<para>
					The next statement buffers events until a minimum of 10 events have collected. Listeners to updates posted by this view receive updated information only when 10 or more events have collected.
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent.win:length_batch(10)]]></programlisting>
			</sect2>

			<sect2 id="view-win-time" >
			   <title>Time window (<literal>win:time</literal>)</title>
		
				<indexterm><primary>time window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>time window</secondary></indexterm>
				<indexterm><primary>data window views</primary><secondary>time window</secondary></indexterm>

				<para>
					This view is a moving (sliding) time window extending the specified time interval into the past based on the system time.
					Provide a time period (see <xref linkend="epl-syntax-time-periods"/>) or an expression defining the number of seconds as a parameter:
				</para>

				<synopsis>win:time(<emphasis>time period</emphasis>)</synopsis>
				<synopsis>win:time(<emphasis>seconds_interval_expression</emphasis>)</synopsis>

				<para>
					For the GE stock tick events in the last 1 second, calculate a sum of price.
				</para>
	
				<programlisting><![CDATA[select sum(price) from StockTickEvent(symbol='GE').win:time(1 sec)]]></programlisting>

				<para>
					The following time windows are equivalent specifications:
				</para>
	
				<programlisting><![CDATA[]]>win:time(2 minutes 5 seconds)
win:time(125 sec)
win:time(125)
win:time(MYINTERVAL)  // MYINTERVAL defined as a variable</programlisting>
			</sect2>

			<sect2 id="view-win-ext_time" >
			   <title>Externally-timed window (<literal>win:ext_timed</literal>)</title>
		
				<indexterm><primary>externally-timed window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>externally-timed window</secondary></indexterm>
				<indexterm><primary>data window views</primary><secondary>externally-timed window</secondary></indexterm>

				<para>
					Similar to the time window, this view is a moving (sliding) time window extending the specified time interval into the past, but based on the millisecond
					time value supplied by a timestamp expression. The view takes two parameters: the expression to return long-typed timestamp values,
					and a time period or expression that provides a number of seconds:
				</para>

				<synopsis>win:ext_timed(<emphasis>timestamp_expression</emphasis>, <emphasis>time_period</emphasis>)</synopsis>
				<synopsis>win:ext_timed(<emphasis>timestamp_expression</emphasis>, <emphasis>seconds_interval_expression</emphasis>)</synopsis>

				<para>
					The key difference comparing the externally-timed window to the regular time window is that the window slides not based on the engine time, 
					but strictly based on the result of the timestamp expression when evaluated against the events entering the window.
				</para>

				<para>
					The algorithm underlying the view compares the timestamp value returned by the expression when the oldest event arrived with the timestamp value returned by the expression for the newest arriving event on event arrival. 
					If the time interval between the timestamp values is larger then the timer period parameter, 
					then the algorithm removes all oldest events tail-first until the difference between the oldest and newest event is within the time interval. The window
					therefore slides only when events arrive and only considers each event's timestamp property (or other expression value returned) and not engine time.
				</para>

				<para>
					This view holds stock tick events of the last 10 seconds based on the timestamp property in <literal>StockTickEvent</literal>.
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent.win:ext_timed(timestamp, 10 seconds)]]></programlisting>

				<para>
					The externally-timed data window expects strict ordering of the timestamp values returned by the timestamp expression. The view is not useful for ordering events in time order, please us the time-order view instead.
				</para>

			</sect2>

			<sect2 id="view-win-time-batch" >
			   <title>Time batch window (<literal>win:time_batch</literal>)</title>
		
				<indexterm><primary>time batch window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>time batch window</secondary></indexterm>
				<indexterm><primary>data window views</primary><secondary>time batch window</secondary></indexterm>

				<para>
					This window view buffers events (tumbling window) and releases them every specified time interval in one update. The view takes a time period or an expression providing a number of seconds as a parameter, plus optional parameters described next.
				</para>

				<synopsis>win:time_batch(<emphasis>time_period</emphasis> [,<emphasis>optional_reference_point</emphasis>] [,<emphasis>flow_control</emphasis>])</synopsis>
				<synopsis>win:time_batch(<emphasis>seconds_interval_expression</emphasis> [,<emphasis>optional_reference_point</emphasis>] [,<emphasis>flow_control</emphasis>])</synopsis>

				<para>
					The time batch window takes a second, optional parameter that serves as a reference point to batch flush times. If not specified, the arrival of the first event into the batch window sets the 
					reference point. Therefore if the reference point is not specified and the first event arrives at time t<subscript>1</subscript>, then the batch flushes at time t<subscript>1</subscript> plus <emphasis>time_period</emphasis> and every <emphasis>time_period</emphasis> thereafter.
				</para>

				<para>
					The below example batches events into a 5 second window releasing new batches every 5 seconds. Listeners to updates
					posted by this view receive updated information only every 5 seconds.
				</para>	
				<programlisting><![CDATA[select * from StockTickEvent.win:time_batch(5 sec)]]></programlisting>
				
				<para>
					By default, if there are no events arriving in the current interval (insert stream), and no events remain from the prior batch (remove stream), then the view does not post results to listeners. The view allows overriding this
					default behavior via flow control keywords.
				</para>

				<para>
					The synopsis with flow control parameters is:
				</para>
				<synopsis>win:time_batch(<emphasis>time_period or seconds_interval_expr</emphasis> [,<emphasis>optional_reference_point</emphasis>] 
    [, "flow-control-keyword [, keyword...]"] )</synopsis>

				<para>
					The FORCE_UPDATE flow control keyword instructs the view to post an empty result set to listeners if there is no
					data to post for an interval. When using this keyword the <literal>irstream</literal> keyword should be used in the <literal>select</literal> clause to ensure the remove stream is also output. 
				</para>
				
				<para>
					The START_EAGER flow control keyword instructs the view to post empty result sets even before the first event
					arrives, starting a time interval at statement creation time. As when using FORCE_UPDATE, the view also posts an
					empty result set to listeners if there is no data to post for an interval, however it starts doing so at time of statement
					creation rather then at the time of arrival of the first event.
				</para>

				<para>
					Taking the two flow control keywords in one sample statement, this example presents a view that waits for 10
					seconds. It posts empty result sets after one interval after the statement is created, and keeps posting an empty result set as no events arrive during intervals:					
				</para>
				<programlisting><![CDATA[select * from MyEvent.win:time_batch(10 sec, "FORCE_UPDATE, START_EAGER")]]></programlisting>				
			</sect2>

			<sect2 id="view-win-time-length-batch" >
			   <title>Time-Length combination batch window (<literal>win:time_length_batch</literal>)</title>
		
				<indexterm><primary>time length batch window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>time length batch window</secondary></indexterm>
				<indexterm><primary>data window views</primary><secondary>time length batch window</secondary></indexterm>

				<para>
					This data window view is a combination of time and length batch (tumbling) windows. Similar to the time and length batch windows, this view batches events and releases the batched events when either one of the 
following conditions occurs, whichever occurs first: the data window has collected a given number of events, or a given time interval has passed.
				</para>

				<para>
					The view parameters take 2 forms. The first form accepts a time period or an expression providing a number of seconds, and an expression for the number of events:
				</para>				
				<synopsis>win:time_length_batch(<emphasis>time_period</emphasis>, <emphasis>number_of_events_expression</emphasis>)</synopsis>
				<synopsis>win:time_length_batch(<emphasis>seconds_interval_expression</emphasis>, <emphasis>number_of_events_expression</emphasis>)</synopsis>

				<para>
					The next example shows a time-length combination batch window that batches up to 100 events or all events arriving within a 1-second time interval, whichever condition occurs first:
				</para>
				<programlisting><![CDATA[ select * from MyEvent.win:time_length_batch(1 sec, 100)]]></programlisting>

				<para>
					In this example, if 100 events arrive into the window before a 1-second time interval passes, the view posts the batch of 100 events. If less then 100 events arrive within a 1-second interval,
					the view posts all events that arrived within the 1-second interval at the end of the interval.
				</para>

				<para>
					By default, if there are no events arriving in the current interval (insert stream), and no events remain from the prior batch (remove stream), then the view does not post results to listeners. This
					view allows overriding this default behavior via flow control keywords.
				</para>

				<para>
					The synopsis of the view with flow control parameters is:
				</para>				
				<synopsis>win:time_length_batch(<emphasis>time_period or seconds_interval_expression</emphasis>, <emphasis>number_of_events_expression</emphasis>, 
    "<emphasis>flow control keyword [, keyword...]</emphasis>")</synopsis>

				<para>
					The <literal>FORCE_UPDATE</literal> flow control keyword instructs the view to post an empty result set to listeners if there is no data to post for an interval. The view begins posting no later then after one time interval passed after the first event arrives. When using this keyword the <literal>irstream</literal> keyword should be used in the <literal>select</literal> clause to ensure the remove stream is also output. 
				</para>				

				<para>
					The <literal>START_EAGER</literal> flow control keyword instructs the view to post empty result sets even before the first event arrives, starting a time interval at statement creation time. As when using <literal>FORCE_UPDATE</literal>, the view also posts an empty result set to listeners if there is no data to post for an interval, however it starts doing so at time of statement creation rather then at the time of arrival of the first event.
				</para>				

				<para>
					Taking the two flow control keywords in one sample statement, this example presents a view that waits for 10 seconds or reacts when the 5th event arrives, whichever comes first. It posts empty result sets after one interval after the statement is created, and keeps posting an empty result set as no events arrive during intervals: 
				</para>
				<programlisting><![CDATA[ select * from MyEvent.win:time_length_batch(10 sec, 5, "FORCE_UPDATE, START_EAGER")]]></programlisting>
			</sect2>

			<sect2 id="view-win-time-accumulating" >
			   <title>Time-Accumulating window (<literal>win:time_accum</literal>)</title>
		
				<indexterm><primary>time-accumulating window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>time-accumulating window</secondary></indexterm>
				<indexterm><primary>data window views</primary><secondary>time-accumulating window</secondary></indexterm>

				<para>
					This data window view is a specialized moving (sliding) time window that differs from the regular time window in that it accumulates events until no more events arrive within a given time interval, and only then releases the accumulated events as a remove stream.
				</para>

				<para>
					The view accepts a single parameter: the time period or seconds-expression specifying the length of the time interval during which no events must arrive until the view releases accumulated events. The synopsis is as follows:
				</para>				
				<synopsis>win:time_accum(<emphasis>time_period</emphasis>)</synopsis>
				<synopsis>win:time_accum(<emphasis>seconds_interval_expression</emphasis>)</synopsis>

				<para>
					The next example shows a time-accumulating window that accumulates events, and then releases events if within the time interval no more events arrive:
				</para>
				<programlisting><![CDATA[ select * from MyEvent.win:time_accum(10 sec)]]></programlisting>

				<para>
					This example accumulates events, until when for a period of 10 seconds no more MyEvent events arrive, at which time it posts all accumulated MyEvent events.
				</para>

				<para>
					Your application may only be interested in the batches of events as events leave the data window. This can be done simply by selecting the remove stream of this data window, populated by the engine as accumulated events leave the data window all-at-once when no events arrive during the time interval following the time the last event arrived:
				</para>
				<programlisting><![CDATA[ select rstream * from MyEvent.win:time_accum(10 sec)]]></programlisting>

				<para>
					If there are no events arriving, then the view does not post results to listeners. 
				</para>
			</sect2>

			<sect2 id="view-win-keepall" >
			   <title>Keep-All window (<literal>win:keepall</literal>)</title>
		
				<indexterm><primary>keep-all window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>keep-all window</secondary></indexterm>
				<indexterm><primary>data window views</primary><secondary>keep-all window</secondary></indexterm>

				<para>
					This keep-all data window view simply retains all events. The view does not remove events from the data window, unless used with a named window and the <literal>on delete</literal> clause.
				</para>

				<para>
					The view accepts no parameters. The synopsis is as follows:
				</para>				
				<synopsis>win:keepall()</synopsis>

				<para>
					The next example shows a keep-all window that accumulates all events received into the window:
				</para>
				<programlisting><![CDATA[ select * from MyEvent.win:keepall()]]></programlisting>

				<para>
					Note that since the view does not release events, care must be taken to prevent retained events from using all available memory.
				</para>
			</sect2>

			<sect2 id="view-win-firstlength" >
			   <title>First Length (<literal>win:firstlength</literal>)</title>
		
				<indexterm><primary>first length window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>first length window</secondary></indexterm>

				<para>
					The <literal>firstlength</literal> view retains the very first <emphasis>size_expression</emphasis> events.
				</para>
				
				<para>
					The synopsis is:
				</para>
				<synopsis>win:firstlength(<emphasis>size_expression</emphasis>)</synopsis>

				<para>
					If used within a named window and an <literal>on-delete</literal> clause deletes events, the view accepts further arriving events until the number of retained events reaches the size of <emphasis>size_expression</emphasis>.
				</para>

				<para>
					The below example creates a view that retains only the first 10 events:
				</para>
				<programlisting><![CDATA[select * from MyEvent.win:firstlength(10)]]></programlisting>				
			</sect2>
			
			<sect2 id="view-win-firsttime" >
			   <title>First Time (<literal>win:firsttime</literal>)</title>
		
				<indexterm><primary>first time window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>first time window</secondary></indexterm>

				<para>
					The <literal>firsttime</literal> view retains all events arriving within a given time interval after statement start.
				</para>
				
				<para>
					The synopsis is:
				</para>
				<synopsis>win:firsttime(<emphasis>time_period</emphasis>)</synopsis>
				<synopsis>win:firsttime(<emphasis>seconds_interval_expression</emphasis>)</synopsis>

				<para>
					The below example creates a view that retains only those events arriving within 1 minute and 10 seconds of statement start:
				</para>
				<programlisting><![CDATA[select * from MyEvent.win:firsttime(1 minute 10 seconds)]]></programlisting>				
			</sect2>

	   </sect1>

        <sect1 id="std-views" >
           <title>Standard view set</title>

			<sect2 id="view-std-unique" >
			   <title>Unique (<literal>std:unique</literal>)</title>
		
				<indexterm><primary>unique window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>unique window</secondary></indexterm>
				<indexterm><primary>data window views</primary><secondary>unique window</secondary></indexterm>

				<para>
					The <literal>unique</literal> view is a view that includes only the most recent among events having the same value(s) for the result of the specified expression or list of expressions.
				</para>
				
				<para>
					The synopsis is:
				</para>
				<synopsis>std:unique(<emphasis>unique_expression</emphasis> [, <emphasis>unique_expression</emphasis> ...])</synopsis>

				<para>
					The view acts as a length window of size 1 for each distinct value returned by an expression, or combination of values returned by multiple expressions. It thus posts as old events the prior event of the same value(s), if any.
				</para>

				<para>
					An expression may return a <literal>null</literal> value. The engine treats a <literal>null</literal> value as any other value. An expression can also return a custom application object, whereby the application class should implement the <literal>hashCode</literal> and <literal>equals</literal> methods.
				</para>

				<para>
					The below example creates a view that retains only the last event per symbol.
				</para>
				<programlisting><![CDATA[select * from StockTickEvent.std:unique(symbol)]]></programlisting>
				
				<para>
					The next example creates a view that retains the last event per symbol and feed.
				</para>
				<programlisting><![CDATA[select * from StockTickEvent.std:unique(symbol, feed)]]></programlisting>
			</sect2>

			<sect2 id="view-std-groupby" >
			   <title>Group-By (<literal>std:groupby</literal>)</title>
		
				<indexterm><primary>group-by window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>group-by window</secondary></indexterm>
				<indexterm><primary>data window views</primary><secondary>group-by window</secondary></indexterm>
				
				<para>
					This view groups events into sub-views by the value returned by the specified expression or the combination of values returned by a list of expressions. The view takes a single expression to supply the group-by values, or a list of expressions as parameters, as the synopsis shows:
				</para>

				<synopsis>std:groupby(<emphasis>grouping_expression</emphasis> [, <emphasis>grouping_expression</emphasis> ...])</synopsis>

				<para>
					The <emphasis>grouping_expression</emphasis> expression(s) return one or more group keys, by which the view creates sub-views for each distinct group key. Note that the expression should not return an unlimited number of values: the grouping expression should not
					return a time value or otherwise unlimited key. 
				</para>

				<para>
					An expression may return a <literal>null</literal> value. The engine treats a <literal>null</literal> value as any other value. An expression can also return a custom application object, whereby the application class should implement the <literal>hashCode</literal> and <literal>equals</literal> methods.
				</para>

				<para>
					This example computes the total price for the last 5 events considering the last 5 events per each symbol, aggregating the price across all symbols (since no <literal>group by</literal> clause is specified the aggregation is across all symbols):
				</para>
	
				<programlisting><![CDATA[select symbol, sum(price) from StockTickEvent.std:groupby(symbol).win:length(5)]]></programlisting>

				<para>
					To compute the total price for the last 5 events considering the last 5 events per each symbol and outputting a price per symbol, add the <literal>group by</literal> clause:
				</para>
	
				<programlisting><![CDATA[select symbol, sum(price) from StockTickEvent.std:groupby(symbol).win:length(5) group by symbol]]></programlisting>

				<para>
					The group-by view can also take multiple expressions that provide values to group by. This example computes the total price for each symbol and feed for the last 10 events per symbol and feed combination:
				</para>
	
				<programlisting><![CDATA[select sum(price) from StockTickEvent.std:groupby(symbol, feed).win:length(10)]]></programlisting>

				<para>
					The order in which the group-by view appears within sub-views of a stream controls the data the engine derives from events for each group. The next 2 statements demonstrate this using a length window.
				</para>

				<para>
					By putting the group-by view in position after the length window, we can change the semantics of the query. The query now returns the total price per symbol for only the last 10 events across all symbols. Here the engine allocates only one length window for all events:
				</para>
	
				<programlisting><![CDATA[select sum(price) from StockTickEvent.win:length(10).std:groupby(symbol)]]></programlisting>

				<para>
					We have learned that by placing the group-by view before other views, these other views become part of the grouped set of views. The engine dynamically allocates a new view instance for each subview, every time it encounters a new group key such as a new value for symbol. Therefore, in <literal>std:groupby(symbol).win:length(10)</literal> the engine allocates a new length window for each distinct symbol. However in <literal>win:length(10).std:groupby(symbol)</literal> the engine maintains a single length window.
				</para>

				<para>
					Multiple group-by views can also be used in the same statement. The statement below groups by symbol and feed. As the statement declares the length window after the group-by view for symbols, the engine allocates a new length window per symbol however reports total price per symbol and feed. The query results are total price per symbol and feed for the last 100 events per symbol (and not per feed).
				</para>

				<programlisting><![CDATA[select sum(price) from StockTickEvent.std:groupby(symbol).win:length(100)
    .std:groupby(feed)]]></programlisting>

				<para>
					Last, we consider the permutation where the length window is declared after the group-by. Here, the query results are total price per symbol and feed for the last 100 events per symbol and feed.
				</para>

				<programlisting><![CDATA[select sum(price) from StockTickEvent.std:groupby(symbol, feed)
    .win:length(100)]]></programlisting>
    
				<para>
					For advanced users: There is an optional view that can control how the group-by view gets evaluated and that view is the <literal>std:merge</literal> view. 
					The merge view can only occur after a group-by view in a view chain and controls
					at what point in the view chain the merge of the data stream occurs from view-instance-per-criteria to single view.
				</para>

				<para>
					Compare the following statements:
				</para>
				
				<programlisting><![CDATA[select * from Market.std:groupby(ticker).win:length(1000000)
    .stat:weighted_avg(price, volume).std:merge(ticker)
// ... and ...
select * from Market.std:groupby(ticker).win:length(1000000).std:merge(ticker)
    .stat:weighted_avg(price, volume)]]></programlisting>

				<para>
					If your statement does not specify the optional <literal>std:merge</literal> view, the semantics are the same as the first statement.
				</para>

				<para>
					The first statement, in which the merge-view is added to the end (same as no merge view), computes weighted average per ticker, considering, per-ticker, the last 1M Market events for each ticker.
					The second statement, in which the merge view is added to the middle, computes weighted average considering, per-ticker, the last 1M Market events, computing the weighted average for all such events using a single view rather then multiple view instances with one view per ticker. 
				</para>
			</sect2>

			<sect2 id="view-std-size" >
			   <title>Size (<literal>std:size</literal>)</title>
		
				<indexterm><primary>size window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>size window</secondary></indexterm>
				<indexterm><primary>data window views</primary><secondary>size window</secondary></indexterm>

				<para>
					This view posts the number of events received from a stream or view. The synopsis is:
				</para>

				<synopsis>std:size()</synopsis>

				<para>					
					The view posts a single long-typed property named <literal>size</literal>. The view posts the prior size as old data, and the current size as new data to update listeners of the view. Via the <literal>iterator</literal> method of the statement the size value can also be polled (read).
				</para>

				<para>					
					This view provides only a single property named <literal>size</literal> and no other properties of your selected stream are available. Use the <literal>count(...)</literal> aggregation function to select other properties of your stream.
				</para>

				<para>
					When combined with a data window view, the size view reports the current and prior number of events in the data window. This example reports the number of tick events within the last 1 minute:
				</para>
				<programlisting><![CDATA[select size from StockTickEvent.win:time(1 min).std:size()]]></programlisting>

				<para>
					The size view is also useful in conjunction with a group-by view to count the number of events per group. The EPL below returns the number of events per symbol.
				</para>
				<programlisting><![CDATA[select size from StockTickEvent.std:groupby(symbol).std:size()]]></programlisting>

				<para>
					When used without a data window, the view simply counts the number of events:
				</para>
				<programlisting><![CDATA[select size from StockTickEvent.std:size()]]></programlisting>

				<para>
					All views can be used with pattern statements as well. The next EPL snippet shows a pattern where we look for tick events followed by trade events for the same symbol. The size view counts the number of occurances of the pattern.
				</para>
				<programlisting><![CDATA[select size from pattern[every s=StockTickEvent -> TradeEvent(symbol=s.symbol)].std:size()]]></programlisting>
			</sect2>

			<sect2 id="view-std-last" >
			   <title>Last Event (<literal>std:lastevent</literal>)</title>
		
				<indexterm><primary>last event window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>last event window</secondary></indexterm>
				<indexterm><primary>data window views</primary><secondary>last event window</secondary></indexterm>

				<para>
					This view exposes the last element of its parent view:
				</para>
				<synopsis>std:lastevent()</synopsis>

				<para>
					The view acts as a length window of size 1. It thus posts as old events the prior event in the stream, if any.
				</para>

				<para>
					This example statement retains the last stock tick event for the symbol GE. 
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent(symbol='GE').std:lastevent()]]></programlisting>

				<para>
					If you want to output the last event within a sliding window, please see <xref linkend="epl-single-row-function-ref-previous"/>. That function accepts a relative (count) or absolute index and returns event properties or an event in the context of the specified data window.
				</para>
			</sect2>

			<sect2 id="view-std-first" >
			   <title>First Event (<literal>std:firstevent</literal>)</title>
		
				<indexterm><primary>first event</primary></indexterm>
				<indexterm><primary>views</primary><secondary>first event</secondary></indexterm>

				<para>
					This view retains only the first arriving event:
				</para>
				<synopsis>std:firstevent()</synopsis>

				<para>
					All events arriving after the first event are discarded.
				</para>

				<para>
					If used within a named window and an <literal>on-delete</literal> clause deletes the first event, the view resets and will retain the next arriving event.
				</para>

				<para>
					An example of a statement that retains the first <literal>ReferenceData</literal> event arriving is:
				</para>
	
				<programlisting><![CDATA[select * from ReferenceData.std:firstevent()]]></programlisting>

				<para>
					If you want to output the first event within a sliding window, please see <xref linkend="epl-single-row-function-ref-previous"/>. That function accepts a relative (count) or absolute index and returns event properties or an event in the context of the specified data window.
				</para>
			</sect2>

			<sect2 id="view-std-firstunique" >
			   <title>First Unique (<literal>std:firstunique</literal>)</title>
		
				<indexterm><primary>first unique window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>first unique window</secondary></indexterm>

				<para>
					The <literal>firstunique</literal> view retains only the very first among events having the same value for the specified expression or list of expressions.
				</para>
				
				<para>
					The synopsis is:
				</para>
				<synopsis>std:firstunique(<emphasis>unique_expression</emphasis> [, <emphasis>unique_expression</emphasis> ...])</synopsis>

				<para>
					If used within a named window and an <literal>on-delete</literal> clause deletes events, the view resets and will retain the next arriving event for the expression result value(s) of the deleted events.
				</para>

				<para>
					The below example creates a view that retains only the first event per category:
				</para>
				<programlisting><![CDATA[select * from ReferenceData.std:firstunique(category)]]></programlisting>
				
			</sect2>
	   </sect1>
  
        <sect1 id="stat-views" >
           <title>Statistics views</title>
           
			<sect2 id="view-stat-uni" >
			   <title>Univariate statistics (<literal>stat:uni</literal>)</title>
		
				<indexterm><primary>univariate statistics view</primary></indexterm>
				<indexterm><primary>views</primary><secondary>univariate statistics</secondary></indexterm>
				<indexterm><primary>derived-value views</primary><secondary>univariate statistics</secondary></indexterm>

				<para>
					This view calculates univariate statistics on a numeric expression. The view takes a single expression as a parameter. The expression must return a numeric value:
				</para>
				<synopsis>stat:uni(<emphasis>value_expression</emphasis>)</synopsis>
				
				<table frame="topbot" id="view-stat-uni-table" revision="2">
					<title>Univariate statistics derived properties</title>
					<tgroup cols="2">
						<colspec colwidth="1*"/>
						<colspec colwidth="2.5*"/>
						<thead>
							<row>
								<entry>Property Name</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>datapoints</literal></entry>
								<entry>Number of values, equivalent to <literal>count(*)</literal> for the stream</entry>
							</row>
							<row>
								<entry><literal>total</literal></entry>
								<entry>Sum of values</entry>
							</row>
							<row>
								<entry><literal>average</literal></entry>
								<entry>Average of values</entry>
							</row>
							<row>
								<entry><literal>variance</literal></entry>
								<entry>Variance</entry>
							</row>
							<row>
								<entry><literal>stddev</literal></entry>
								<entry>Sample standard deviation (square root of variance) </entry>
							</row>
							<row>
								<entry><literal>stddevpa</literal></entry>
								<entry>Population standard deviation</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
	
				<para>
					The below example selects the standard deviation on price for stock tick events for the last 10 events.
				</para>
	
				<programlisting><![CDATA[select stddev from StockTickEvent.win:length(10).stat:uni(price)]]></programlisting>
			</sect2>

			<sect2 id="view-stat-linest" >
			   <title>Regression (<literal>stat:linest</literal>)</title>
		
				<indexterm><primary>regression view</primary></indexterm>
				<indexterm><primary>views</primary><secondary>regression</secondary></indexterm>
				<indexterm><primary>derived-value views</primary><secondary>regression</secondary></indexterm>
				<para>
					This view calculates regression and related intermediate results on the values returned by two expressions. The view takes two expressions as parameters. The expressions must return a numeric value:
				</para>
				
				<synopsis>stat:linest(<emphasis>value_expression</emphasis>, <emphasis>value_expression</emphasis>)</synopsis>

				<table frame="topbot" id="view-stat-linest-table" revision="2">
					<title>Regression derived properties</title>
					<tgroup cols="2">
						<colspec colwidth="1*"/>
						<colspec colwidth="2.5*"/>
						<thead>
							<row>
								<entry>Property Name</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>slope</literal></entry>
								<entry>Slope.</entry>
							</row>
							<row>
								<entry><literal>YIntercept</literal></entry>
								<entry>Y intercept.</entry>
							</row>
							<row>
								<entry><literal>XAverage</literal></entry>
								<entry>X average.</entry>
							</row>
							<row>
								<entry><literal>XStandardDeviationPop</literal></entry>
								<entry>X standard deviation population.</entry>
							</row>
							<row>
								<entry><literal>XStandardDeviationSample</literal></entry>
								<entry>X standard deviation sample.</entry>
							</row>
							<row>
								<entry><literal>XSum</literal></entry>
								<entry>X sum.</entry>
							</row>
							<row>
								<entry><literal>XVariance</literal></entry>
								<entry>X variance.</entry>
							</row>
							<row>
								<entry><literal>YAverage</literal></entry>
								<entry>X average.</entry>
							</row>
							<row>
								<entry><literal>YStandardDeviationPop</literal></entry>
								<entry>Y standard deviation population.</entry>
							</row>
							<row>
								<entry><literal>YStandardDeviationSample</literal></entry>
								<entry>Y standard deviation sample.</entry>
							</row>
							<row>
								<entry><literal>YSum</literal></entry>
								<entry>Y sum.</entry>
							</row>
							<row>
								<entry><literal>YVariance</literal></entry>
								<entry>Y variance.</entry>
							</row>
							<row>
								<entry><literal>dataPoints</literal></entry>
								<entry>Number of data points.</entry>
							</row>
							<row>
								<entry><literal>n</literal></entry>
								<entry>Number of data points.</entry>
							</row>
							<row>
								<entry><literal>sumX</literal></entry>
								<entry>Sum of X (same as X Sum).</entry>
							</row>
							<row>
								<entry><literal>sumXSq</literal></entry>
								<entry>Sum of X squared.</entry>
							</row>
							<row>
								<entry><literal>sumXY</literal></entry>
								<entry>Sum of X times Y.</entry>
							</row>
							<row>
								<entry><literal>sumY</literal></entry>
								<entry>Sum of Y (same as Y Sum).</entry>
							</row>
							<row>
								<entry><literal>sumYSq</literal></entry>
								<entry>Sum of Y squared.</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
				
				<para>
					Calculate regression and return the slope and y-intercept on price and offer for all events in the last 10 seconds.
				</para>
	
				<programlisting><![CDATA[select slope, YIntercept from StockTickEvent.win:time(10 seconds).stat:linest(price, offer)]]></programlisting>	
			</sect2>
				
			<sect2 id="view-stat-correl" >
			   <title>Correlation (<literal>stat:correl</literal>)</title>
		
				<indexterm><primary>correlation view</primary></indexterm>
				<indexterm><primary>views</primary><secondary>correlation</secondary></indexterm>
				<indexterm><primary>derived-value views</primary><secondary>correlation</secondary></indexterm>

				<para>
					This view calculates the correlation value on the value returned by two expressions. The view takes two expressions as parameters. The expressions must be return a numeric value:
				</para>
				
				<synopsis>stat:correl(<emphasis>value_expression</emphasis>, <emphasis>value_expression</emphasis>)</synopsis>
				
				<table frame="topbot" id="view-stat-correl-table" revision="2">
					<title>Correlation derived properties</title>
					<tgroup cols="2">
						<colspec colwidth="1*"/>
						<colspec colwidth="2.5*"/>
						<thead>
							<row>
								<entry>Property Name</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>correlation</literal></entry>
								<entry>Correlation between two event properties</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
	
				<para>
					Calculate correlation on price and offer over all stock tick events for GE.
				</para>
	
				<programlisting><![CDATA[select correlation from StockTickEvent(symbol='GE').stat:correl(price, offer)]]></programlisting>            
			</sect2>
						
			<sect2 id="view-stat-weightedavg" >
			   <title>Weighted average (<literal>stat:weighted_avg</literal>)</title>
		
				<indexterm><primary>weighted average view</primary></indexterm>
				<indexterm><primary>views</primary><secondary>weighted average</secondary></indexterm>
				<indexterm><primary>derived-value views</primary><secondary>weighted average</secondary></indexterm>

				<para>
					This view returns the weighted average given an expression returning values to compute the average for and an expression returning weight. The view takes two expressions as parameters. The expressions must return numeric values:
				</para>				
				<synopsis>stat:weighted_avg(<emphasis>value_expression_field</emphasis>, <emphasis>value_expression_weight</emphasis>)</synopsis>
				
				<table frame="topbot" id="view-stat-weightedavg-table" revision="2">
					<title>Weighted average derived properties</title>
					<tgroup cols="2">
						<colspec colwidth="1*"/>
						<colspec colwidth="2.5*"/>
						<thead>
							<row>
								<entry>Property Name</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>average</literal></entry>
								<entry>Weighted average</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
	
				<para>
					A statement that derives the volume-weighted average price for the last 3 seconds:
				</para>
	
				<programlisting><![CDATA[select average 
from StockTickEvent(symbol='GE').win:time(3 seconds).stat:weighted_avg(price, volume)]]></programlisting>            
			</sect2> 
			
		</sect1>

        <sect1 id="ext-views" >
           <title>Extension View Set</title>

			<sect2 id="view-ext-sort" >
			   <title>Sorted Window View (<literal>ext:sort</literal>)</title>
		
				<indexterm><primary>sorted window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>sorted window</secondary></indexterm>
				<indexterm><primary>data window views</primary><secondary>sorted window</secondary></indexterm>

				<para>					
					This view sorts by values returned by the specified expressionor list of expressions and keeps only the top (or bottom) events up to the given size. 
				</para>

				<para>
					The syntax is as follows:
				</para>
				<synopsis>ext:sort(<emphasis>size_expression</emphasis>, 
    <emphasis>sort_criteria_expression</emphasis> [asc/desc][, <emphasis>sort_criteria_expression</emphasis> [asc/desc]...]) </synopsis>

				<para>					
					An expression may be followed by the optional <literal>asc</literal> or <literal>desc</literal> keywords to indicate that the values returned by that expression are sorted in ascending or descending sort order.
				</para>

				<para>
					The view below retains only those events that have the highest 10 prices and reports a total price:
				</para>
				<programlisting><![CDATA[select sum(price) from StockTickEvent.ext:sort(10, price desc)]]></programlisting>				

				<para>
					The following example sorts events first by price in descending order, and then by symbol name in ascending (alphabetical) order, keeping only the 10
events with the highest price (with ties resolved by alphabetical order of symbol).
				</para>
				<programlisting><![CDATA[select * from StockTickEvent.ext:sort(10, price desc, symbol asc)]]></programlisting>				
			</sect2>
			
			<sect2 id="view-time-order" >
			   <title>Time-Order View (<literal>ext:time_order</literal>)</title>
		
				<indexterm><primary>time-order window</primary></indexterm>
				<indexterm><primary>views</primary><secondary>time-order window</secondary></indexterm>
				<indexterm><primary>data window views</primary><secondary>time-order window</secondary></indexterm>

				<para>
					This view orders events that arrive out-of-order, using timestamp-values provided by an expression, and by comparing that timestamp value to engine system time.
				</para>

				<para>
					The syntax for this view is as follows.
				</para>
				<synopsis>ext:time_order(<emphasis>timestamp_expression</emphasis>, <emphasis>time_period</emphasis>)</synopsis>
				<synopsis>ext:time_order(<emphasis>timestamp_expression</emphasis>, <emphasis>seconds_interval_expression</emphasis>)</synopsis>

				<para>
					The first parameter to the view is the expression that supplies timestamp values. The timestamp is expected to be a long-typed millisecond value that denotes an event's time of consideration by the view (or other expression). This is typically the time of arrival. The second parameter is a number-of-seconds expression or the time period specifying the time interval that an arriving event should maximally be held, in order to consider older events arriving at a later time.
				</para>

				<para>
					Since the view compares timestamp values to engine time, the view requires that the timestamp values and current engine time are both following the same clock. Therefore, to the extend that the clocks that originated both timestamps differ, the view may produce inaccurate results.
				</para>

				<para>
					As an example, the next statement uses the <literal>arrival_time</literal> property of <literal>MyTimestampedEvent</literal> events to order and release events by arrival time:
				</para>
				<programlisting><![CDATA[insert rstream into ArrivalTimeOrderedStream
select rstream * from MyTimestampedEvent.ext:time_order(arrival_time, 10 sec)]]></programlisting>

				<para>
					In the example above, the <literal>arrival_time</literal> property holds a long-typed timestamp value in milliseconds. On arrival of an event, the engine compares the timestamp value of each event to the tail-time of the window. The tail-time of the window is, in this example, 10 seconds before engine time (continuously sliding). If the timestamp value indicates that the event is older then the tail-time of the time window, the event is released immediately in the remove stream. If the timestamp value indicates that the event is newer then the tail-time of the window, the view retains the event until engine time moves such that the event timestamp is older then tail-time.
				</para> 

				<para>
					The examples thus holds each arriving event in memory anywhere from zero seconds to 10 seconds, to allow for older events (considering arrival time timestamp) to arrive. In other words, the view holds an event with an arrival time equal to engine time for 10 seconds. The view holds an event with an arrival time that is 2 seconds older then engine time for 8 seconds. The view holds an event with an arrival time that is 10 or more seconds older then engine time for zero seconds, and releases such (old) events immediately into the remove stream. 
				</para> 

				<para>
					The insert stream of this sliding window consists of all arriving events. The remove stream of the view is ordered by timestamp value: The event that has the oldest timestamp value is released first, followed by the next newer events. Note the statement above uses the <literal>rstream</literal> keyword in both the <literal>insert into</literal> clause and the <literal>select</literal> clause to select ordered events only. It uses the <literal>insert into</literal> clause to makes such ordered stream available for subsequent statements to use.
				</para> 

				<para>
					It is up to your application to populate the timestamp property into your events or use a sensible expression that returns timestamp values for consideration by the view. The view also works well if you use externally-provided time via timer events. 
				</para> 
			</sect2>

		</sect1>
</chapter>
