<chapter id="packaging_deployment">
    <title>Packaging and Deploying</title>

    <sect1 id="deploy-intro">
        <title>Overview</title>

		<para>
			Please consider Esper Enterprise Edition as a target deployment platform. Esper alone does not ship with a server as it is designed as a core CEP engine.
		</para>

        <para>
			To support packaging and deploying event-driven applications, Esper offers infrastructure as outlined herein:
        </para>
        
		<itemizedlist>
			<listitem>
				<para>
                    EPL modules to build a cohesive deployment unit out of related statements as described in <xref linkend="deploy-eplmodule"/>.
                </para>
			</listitem>
			<listitem>
				<para>
                    The deployment administrative interface is described in <xref linkend="deploy-admin"/>.
                </para>
			</listitem>
			<listitem>
				<para>
			        Instructions and code for use when the deployment target is a J2EE web application server or servlet runtime, please see <xref linkend="deploy-j2ee"/>.
                </para>
			</listitem>
		</itemizedlist>

    </sect1>
    
    <sect1 id="deploy-eplmodule">
        <title>EPL Modules</title>

		<indexterm><primary>packaging</primary><secondary>EPL module</secondary></indexterm>
		<indexterm><primary>deployment</primary><secondary>EPL module</secondary></indexterm>
		
		<para>
			An EPL module file is a plain text file in which EPL statements appear separated by the semicolon (;) character. It bundles EPL statements with optional deployment instructions. A service provider instance keeps track of the deployed EPL modules and makes it easy to deploy and undeploy EPL modules.
		</para>

		<para>
			The synopsis of an EPL module file is:
		</para>
		
		<synopsis>[module <emphasis>module_name</emphasis>;]
[uses <emphasis>module_name</emphasis>; | import <emphasis>import_name</emphasis>;] [uses <emphasis>module_name</emphasis>; | import <emphasis>import_name</emphasis>;] [...]
[<emphasis>epl_statement</emphasis>;] [<emphasis>epl_statement</emphasis>;] [...]</synopsis>

		<para>
			Use the <literal>module</literal> keyword followed a <emphasis>module_name</emphasis> identifier or a package (identifiers separated by dots) to declare the name of the module. The module name declaration must be at the beginning of the file, comments and whitespace excluded. The module name 
			serves to check uses-dependences of other modules.  
		 </para>
		 
		 <para>
			If a module file requires certain constructs that may be shared by other module files, such as named windows, variables, event types, variant streams or inserted-into streams required by statements,
			a module file may specify zero to many dependent modules with the <literal>uses</literal> keyword. At deployment time the engine checks the uses-dependencies
			and ensures that a module of that name is already deployed or will be deployed as part of the deployments. The deployment API supports ordering modules according to their uses-relationship.
		 </para>
		 
		 <para>
			 If the EPL statements in the module require Java classes such as for underlying events or user-defined functions, use the <literal>import</literal> keyword followed by the fully-qualified class name or package name in the format <literal>package.*</literal>.
			 The <literal>uses</literal> and <literal>import</literal> keywords are optional and must occur after the <literal>module</literal> declaration.
		 </para>
		 
		 <para>
			 Following the optional deployment instructions are any number of <emphasis>epl_statement</emphasis> EPL statements that are separated by semicolon (<literal>;</literal>).
		 </para>
		 
		 <para>
			 The following is a sample EPL module file explained in detail thereafter:
		 </para>

		<programlisting><![CDATA[// Declare the name for the module
module org.myorganization.switchmonitor;

// Declare other module(s) that this module depends on
uses org.myorganization.common;

// Import any Java/.NET classes in an application package 
import org.myorganization.events.*;

// Declare an event type based on a Java class in the package that was imported as above
create schema MySwitchEvent as MySwitchEventPOJO;

// Sample statement
@Name('Off-On-Detector')
insert into MyOffOnStream
select * from pattern[every-distinct(id) a=MySwitchEvent(status='off') 
  -> b=MySwitchEvent(id=a.id, status='on')];

// Sample statement
@Name('Count-Switched-On')
@Description('Count per switch id of the number of Off-to-On switches in the last 1 hour')
select id, count(*) from MyOffOnStream.win:time(1 hour) group by id;]]></programlisting>

        <para>
			The example above declares a module name of <literal>org.myorganization.switchmonitor</literal>. As defined by the <literal>uses</literal> keyword, it ensures that the <literal>org.myorganization.common</literal> module is already deployed.
			The example demonstrates the <literal>import</literal> keyword to make a package name known to the engine for resolving POJO class names, as the example assumes that <literal>MySwitchEventPOJO</literal> is a POJO event class.
			In addition the example module contains two statements separated by semicolon characters.
        </para>

        <para>
			Your application code may, after deployment, look up a statement and attach listeners as shown here:
        </para>
			<programlisting><![CDATA[epService.getEPAdministrator().getStatement("Count-Switched-On").addListener(...);]]></programlisting>
    </sect1>

    <sect1 id="deploy-admin">
        <title>The Deployment Administrative Interface</title>

		<indexterm><primary>packaging</primary><secondary>EPDeploymentAdmin interface</secondary></indexterm>
		<indexterm><primary>deployment</primary><secondary>EPDeploymentAdmin interface</secondary></indexterm>
		
		<para>
			The <literal>com.espertech.esper.client.deploy.EPDeploymentAdmin</literal> service available from the <literal>EPAdministrator</literal> interface by method <literal>getDeploymentAdmin</literal> provides the functionality available to manage packaging and deployment.
			Please consult the JavaDoc documentation for more information.
		</para>
		
		<para>
		  We provide additional sample code to read and deploy modules as part of the J2EE considerations below.
		</para>

		<sect2 id="deploy-admin-readparse">
        <title>Reading Module Content</title>
			<para>
				Read and parse module files via the <literal>EPDeploymentAdmin</literal> interface <literal>read</literal> and <literal>parse</literal> methods, which returns a <literal>Module</literal> instance to represent the module information. 
			</para>
	
			<para>
				This code snippet demonstrates reading and parsing a module given a file name:
			</para>
			<programlisting><![CDATA[EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPDeploymentAdmin deployAdmin = epService.getEPAdministrator().getDeploymentAdmin();
Module module = deployAdmin.read(new File("switchmonitor.epl"));]]></programlisting>

			<para>
				The service provides additional read and parse methods to read from a URL, classpath, input stream or string.
			</para>
	  </sect2>

		<sect2 id="deploy-admin-order">
        <title>Ordering Multiple Modules</title>
			<para>
				Since modules may have inter-dependencies as discussed under the <literal>uses</literal> declaration,  the deployment interface provides the <literal>getDeploymentOrder</literal> method to order a collection of modules before deployment.
			</para>
			
			<para>
				Assuming your application reads multiple modules into a <literal>mymodules</literal> module list, this code snippet orders the modules for deployment and validates dependency declarations for each module:
			</para>
			<programlisting><![CDATA[List<Module> mymodules =  ... read modules...;  
DeploymentOrder order = deployAdmin.getDeploymentOrder(mymodules, new DeploymentOrderOptions());]]></programlisting>
	  </sect2>

		<sect2 id="deploy-admin-deploy-undeploy">
        <title>Deploying and Undeploying</title>
			<para>
				The deployment interface returns a deployment id for each deployed module. To undeploy the module your application must provide the deployment id.
			</para>
			
			<para>
				The next code snippet deploys a module:
			</para>
			<programlisting><![CDATA[for (Module mymodule : order.getOrdered()) {
  DeploymentResult deployResult = deployAdmin.deploy(mymodule, new DeploymentOptions());
}]]></programlisting>
			
			<para>
				To undeploy the module pass the deployment id:
			</para>
			<programlisting><![CDATA[deployAdmin.undeploy(deployResult.getDeploymentId());]]></programlisting>
	  </sect2>
	  
	   <sect2 id="deploy-admin-list">
        <title>Listing Deployments</title>
			<para>
				The deployment interface returns deployed module information that allows your application to determine which modules are currently deployed. 
			</para>
			
			<para>
				To obtain a list of all deployed modules, the call is:
			</para>
			<programlisting><![CDATA[DeploymentInformation[] info = deployAdmin.getDeploymentInformation();]]></programlisting>			
	  </sect2>
	</sect1>

    <sect1 id="deploy-j2ee">
        <title>J2EE Packaging and Deployment</title>

		<indexterm><primary>packaging</primary><secondary>J2EE</secondary></indexterm>
		<indexterm><primary>deployment</primary><secondary>J2EE</secondary></indexterm>

		<para>
			Esper can well be deployed as part of a J2EE web or enterprise application archive to a web application server. 
			When designing for deployment into a J2EE web application server, please consider the items discussed here.
		</para>

		<para>
			We provide a sample servlet context listener in this section that uses the deployment API to deploy and undeploy modules as part of the servlet lifecycle. 
		</para>
		
		<para>
			The distribution provides a message-driven bean (MDB) example that you may find useful.
		</para>
		
		<para>
			Esper does not have a dependency on any J2EE or Servlet APIs to allow the engine to run in any environment or container.
		</para>

		<sect2 id="deploy-j2ee-considerations">
			<title>J2EE Deployment Considerations</title>
			
			<para>
			  As multiple web applications deployed to a J2EE web application server typically have a separate classloader per application, you should consider whether engine instances need to be shared between applications or can remain separate engine instances. Consider the <literal>EPServiceProviderManager</literal> a Singleton. 
			  When deploying multiple web applications, your J2EE container classloader may provide a separate instance of the Singleton <literal>EPServiceProviderManager</literal> to each web application resulting in multiple independent engine instances.
			</para>
			
			<para>
			  To share <literal>EPServiceProvider</literal> instances between web applications, one approach is to add the Esper jar files to the system classpath. A second approach can be to have multiple web applications share the same servet context and have your application place the <literal>EPServiceProvider</literal> instance into a servlet context attribute for sharing. Architecturally you may also consider a single archived application (such as an message-driven bean) that all your web applications communicate to via the JMS broker provided by your application server or an external JMS broker. 
			</para>
			
			<para> 
			  As per J2EE standards there are restrictions in regards to starting new threads in J2EE application code. Esper adheres to these restrictions: It allows to be driven entirely by external events. To remove all Esper threads, set the internal timer off and leave the advanced threading options turned off.
			  To provide timer events when the internal timer is turned off, you should check with your J2EE application container for support of the Java system timer or for support of batch or work loading to send timer events to an engine instance.
			</para>

			<para> 
			  As per J2EE standards there are restrictions in regards to input and output by J2EE application code. Esper adheres to these restrictions: By itself it does not start socket listeners or performs any file IO.
			</para>
		</sect2>

		<sect2 id="deploy-j2ee-servletcontextlistener">
			<title>Servlet Context Listener</title>
			<para>
				When deploying a J2EE archive that contains EPL modules files we provide sample code to read and deploy EPL modules files packaged with the enterprise or web application archive when the servlet initializes. The sample undeploys EPL modules when the servlet context gets destroyed.
			</para>
			
			<para>
				A sample <literal>web.xml</literal> configuration extract is:
			</para>
			<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<web-app>
  <listener>
    <listener-class>SampleServletListener</listener-class>
  </listener>
  <context-param>
    <param-name>eplmodules</param-name>
    <param-value>switchmonitor.epl</param-value>
</context-param>
</web-app>]]></programlisting>			

			<para>
				A servet listener that deploys EPL module files packaged into the archive on context initialization and that undeploys when the application server destroys the context is shown here:
			</para>
			<programlisting><![CDATA[public class SampleServletListener implements ServletContextListener {

  private List<String> deploymentIds = new ArrayList<String>();
  
  public void contextInitialized(ServletContextEvent servletContextEvent) {
    try {
      EPServiceProvider epServiceProvider = EPServiceProviderManager.getDefaultProvider();
      String modulesList = servletContextEvent.getServletContext().getInitParameter("eplmodules");
      List<Module> modules = new ArrayList<Module>();
      if (modulesList != null) {
        String[] split = modulesList.split(",");
        for (int i = 0; i < split.length; i++) {
          String resourceName = split[i].trim();
          if (resourceName.length() == 0) {
            continue;
          }
          String realPath = servletContextEvent.getServletContext().getRealPath(resourceName);
  		Module module = epServiceProvider.getEPAdministrator()
  		        .getDeploymentAdmin().read(new File(realPath));
          modules.add(module);
        }
      }
    
      // Determine deployment order
      DeploymentOrder order = epServiceProvider.getEPAdministrator()
                  .getDeploymentAdmin().getDeploymentOrder(modules, null);
  
      // Deploy
      for (Module module : order.getOrdered()) {
        DeploymentResult result = epServiceProvider.getEPAdministrator()
                  .getDeploymentAdmin().deploy(module, new DeploymentOptions());
        deploymentIds.add(result.getDeploymentId());
      }
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
  }
  
  public void contextDestroyed(ServletContextEvent servletContextEvent) {
    EPServiceProvider epServiceProvider = EPServiceProviderManager.getDefaultProvider();
    for (String deploymentId : deploymentIds) {
       epServiceProvider.getEPAdministrator().getDeploymentAdmin().undeploy(deploymentId);
    }
  }
}]]></programlisting>			
		</sect2>
	</sect1>
</chapter>
