<chapter id="functionreference">
    <title>EPL Reference: Functions</title>
        
	<sect1 id="epl-single-row-function-ref">
		<title>Single-row Function Reference</title>
		
		<para>
			Single-row functions return a single value for every single result row generated by your statement. These functions can appear anywhere where expressions are allowed.
		</para>

		<indexterm><primary>user-defined single-row function</primary></indexterm>
		<indexterm><primary>functions</primary><secondary>user-defined</secondary></indexterm>
		<indexterm><primary>static Java methods</primary></indexterm>
		<para>
			Esper allows static Java library methods as single-row functions, and also features built-in single-row functions. In addition, Esper allows instance method invocations on named streams.
		</para>
			
		<para>
			You may also register your own single-row function name with the engine so that your EPL statements become less cluttered. This is described in detail in <xref linkend="custom-singlerow-function"/>. Single-row functions that return an object can be chained.
		</para>

		<para>
			Esper auto-imports the following Java library packages:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
					java.lang.*
				</para>
			</listitem>
			<listitem>
				<para>
					java.math.*
				</para>
			</listitem>
			<listitem>
				<para>
					java.text.*
				</para>
			</listitem>
			<listitem>
				<para>
					java.util.*
				</para>
			</listitem>
		</itemizedlist>

		<para>
			Thus Java static library methods can be used in all expressions as shown in below example:
		</para>

		<programlisting>select symbol, Math.round(volume/1000)
from StockTickEvent.win:time(30 sec)</programlisting>
			
		<para>
			In general, arbitrary Java class names have to be fully qualified (e.g. java.lang.Math) but Esper provides a mechanism 
for user-controlled imports of classes and packages as outlined in <xref linkend="config-class--package-imports"/>.
		</para>

		<para>
			The below table outlines the built-in single-row functions available.
		</para>

		<table frame="topbot" id="epl-single-row-func" revision="2">
			<title>Syntax and results of single-row functions</title>
			<tgroup cols="2">
				<colspec colwidth="2.0*"/>
				<colspec colwidth="1.5*"/>
				<thead>
					<row>
						<entry>Single-row Function</entry>
						<entry>Result</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry><synopsis>case <emphasis>value</emphasis> 
  when <emphasis>compare_value</emphasis> then <emphasis>result</emphasis>
  [when <emphasis>compare_value</emphasis> then <emphasis>result</emphasis> ...] 
  [else <emphasis>result</emphasis>] 
  end </synopsis></entry>
						<entry>
							<para>
								Returns <literal>result</literal> where the first <literal>value</literal> equals <literal>compare_value</literal>. 
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>case 
  when <emphasis>condition</emphasis> then <emphasis>result</emphasis>
  [when <emphasis>condition</emphasis> then <emphasis>result</emphasis> ...] 
  [else <emphasis>result</emphasis>] 
  end</synopsis></entry>
						<entry>
							<para>
								Returns the <literal>result</literal> for the first condition that is true.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>cast(<emphasis>expression</emphasis>, <emphasis>type_name</emphasis>)</synopsis></entry>
						<entry>
							<para>
								Casts the result of an expression to the given type. 
							</para>
						</entry>
					</row>
					<row>
					  <entry><synopsis>coalesce(<emphasis>expression</emphasis>, <emphasis>expression</emphasis> [, <emphasis>expression</emphasis> ...])</synopsis></entry>
						<entry>
							<para>
								Returns the first non-<literal>null</literal> value in the list, or <literal>null</literal> if there are no non-<literal>null</literal> values.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>current_timestamp[()]</synopsis></entry>
						<entry>
							<para>
								Returns the current engine time as a <literal>long</literal> millisecond value. Reserved keyword with optional parenthesis.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>exists(<emphasis>dynamic_property_name</emphasis>)</synopsis></entry>
						<entry>
							<para>
								Returns true if the dynamic property exists for the event, or false if the property does not exist.
							</para>
						</entry>
					</row>
					<row>
					  <entry><synopsis>instanceof(<emphasis>expression</emphasis>, <emphasis>type_name</emphasis> [, <emphasis>type_name</emphasis> ...])</synopsis></entry>
						<entry>
							<para>
								Returns true if the expression returns an object whose type is one of the types listed.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>max(<emphasis>expression</emphasis>, <emphasis>expression</emphasis> [, <emphasis>expression</emphasis> ...])</synopsis></entry>
						<entry>
							<para>
								Returns the highest numeric value among the 2 or more comma-separated expressions.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>min(<emphasis>expression</emphasis>, <emphasis>expression</emphasis> [, <emphasis>expression</emphasis> ...])</synopsis></entry>
						<entry>
							<para>
								Returns the lowest numeric value among the 2 or more comma-separated expressions.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>prev(<emphasis>expression</emphasis>, <emphasis>event_property)</emphasis></synopsis></entry>
						<entry>
							<para>
								Returns a property value or all properties of a previous event, relative to the event order within a data window, or according to an optional index parameter (N) the positional Nth-from-last value.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>prevtail(<emphasis>expression</emphasis>, <emphasis>event_property)</emphasis></synopsis></entry>
						<entry>
							<para>
								Returns a property value or all properties of the first event in a data window relative to the event order within a data window, or according to an optional index parameter (N) the positional Nth-from-first value.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>prevwindow(<emphasis>event_property</emphasis>)</synopsis></entry>
						<entry>
							<para>
								Returns a single property value of all events or all properties of all events in a data window in the order that reflects the sort order of the data window.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>prevcount(<emphasis>event_property</emphasis>)</synopsis></entry>
						<entry>
							<para>
								Returns the count of events (number of data points) in a data window.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>prior(<emphasis>integer</emphasis>, <emphasis>event_property)</emphasis></synopsis></entry>
						<entry>
							<para>
								Returns a property value of a prior event, relative to the natural order of arrival of events
							</para>
						</entry>
					</row>
					<row>
					  <entry><synopsis>typeof(<emphasis>expression</emphasis>)</synopsis></entry>
						<entry>
							<para>
								If expression is a stream name, returns the event type name of the evaluated event, often used with variant streams. 
								If expression is a property name or expression, returns the name of the expression result type.
							</para>
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>

		<sect2 id="epl-single-row-function-ref-case">
			<title>The <literal>Case</literal> Control Flow Function</title>

			<indexterm><primary>case control flow function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>case control flow</secondary></indexterm>
			<para>
				The <literal>case</literal> control flow function has two versions. The first version takes a value and a list of compare values to compare against, and returns the result where the first value equals the compare value. The second version takes a list of conditions and returns the result for the first condition that is true.
			</para>

			<para>
				The return type of a <literal>case</literal> expression is the compatible aggregated type of all return values.
			</para>
			
			<para>
				The <literal>case</literal> expression is sometimes used with the <literal>new</literal> operator to return multiple results, see <xref linkend="epl-operator-new"/>.
			</para>

			<para>
				The example below shows the first version of a <literal>case</literal> statement. It has a <literal>String</literal> return type and returns the value 'one'.
			</para>
			<programlisting>select case myexpression when 1 then 'one' when 2 then 'two' else 'more' end from ...</programlisting>
				
			<para>
				The second version of the <literal>case</literal> function takes a list of conditions. The next example has a <literal>Boolean</literal> return type and returns the boolean value true.
			</para>				
			<programlisting>select case when 1>0 then true else false end from ...</programlisting>
		</sect2>
		

		<sect2 id="epl-single-row-function-cast">
			<title>The <literal>Cast</literal> Function</title>

			<indexterm><primary>cast function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>cast</secondary></indexterm>
			<para>
				The <literal>cast</literal> function casts the return type of an expression to a designated type. The function accepts two parameters: The first parameter is the property name or expression that returns the 
				value to be casted. The second parameter is the type to cast to.
			</para>

			<para>
				Valid parameters for the second (type) parameter are:
			</para>
	
			<itemizedlist>
				<listitem>
					<para>
						Any of the Java built-in types: <literal>int, long, byte, short, char, double, float, string, BigInteger, BigDecimal</literal>, where <literal>string</literal>  is a short notation for <literal>java.lang.String</literal> and <literal>BigInteger</literal> as well as <literal>BigDecimal</literal> are the classes in <literal>java.math</literal>. The type name is not case-sensitive. For example:
						<synopsis>cast(price, double)</synopsis>
					</para>
				</listitem>
				<listitem>
					<para>
						The fully-qualified class name of the class to cast to, for example: <synopsis>cast(product, org.myproducer.Product)</synopsis>
					</para>
				</listitem>
			</itemizedlist>

			<para>
				The <literal>cast</literal> function is often used to provide a type for dynamic (unchecked) properties. Dynamic properties are properties whose type is not known at compile type. 
				These properties are always of type <literal>java.lang.Object</literal>. 
			</para>
			
			<para>
				The <literal>cast</literal> function as shown in the next statement casts the dynamic "price" property of an "item" in the OrderEvent to a double value.
			</para>
			<programlisting><![CDATA[select cast(item.price?, double) from OrderEvent]]></programlisting>

			<para>
				The <literal>cast</literal> function returns a <literal>null</literal> value if the expression result cannot be casted to the desired type, or if the expression result itself is <literal>null</literal>.
			</para>

			<para>
				The <literal>cast</literal> function adheres to the following type conversion rules:
			</para>

			<itemizedlist>
				<listitem>
					<para>
						For all numeric types, the <literal>cast</literal> function utilitzes <literal>java.lang.Number</literal> to convert numeric types, if required. 
					</para>
				</listitem>
				<listitem>
					<para>
						For casts to <literal>string</literal> or <literal>java.lang.String</literal>, the function calls <literal>toString</literal> on the expression result.
					</para>
				</listitem>
				<listitem>
					<para>
						For casts to other objects including application objects, the <literal>cast</literal> function considers a Java class's superclasses as well as all directly or indirectly-implemented interfaces by superclasses .
					</para>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="epl-single-row-function-ref-coalesce">
			<title>The <literal>Coalesce</literal> Function</title>

			<indexterm><primary>coalesce function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>coalesce</secondary></indexterm>
			<para>
				The result of the <literal>coalesce</literal> function is the first expression in a list of expressions that returns a non-null value. The return type is the compatible aggregated type of all return values.
			</para>
			
			<para>
				This example returns a String-typed result of value 'foo':
			</para>
			<programlisting>select coalesce(null, 'foo') from ...</programlisting>			
		</sect2>

		<sect2 id="epl-single-row-function-ref-currenttime">
			<title>The <literal>Current_Timestamp</literal> Function</title>

			<indexterm><primary>current_timestamp function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>current_timestamp</secondary></indexterm>
			<para>
				The <literal>current_timestamp</literal> function is a reserved keyword and requires no parameters. The result of the <literal>current_timestamp</literal> function is the <literal>long</literal>-type millisecond value of the current engine system time.
			</para>
			
			<para>
				The function returns the current engine timestamp at the time of expression evaluation. When using external-timer events, the function provides the last value of the externally-supplied time at the time of expression evaluation.
			</para>

			<para>
				This example selects the current engine time:
			</para>
			<programlisting><![CDATA[select current_timestamp from MyEvent
// equivalent to
select current_timestamp() from MyEvent]]></programlisting>
		</sect2>

		<sect2 id="epl-single-row-function-exists">
			<title>The <literal>Exists</literal> Function</title>

			<indexterm><primary>exists function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>exists</secondary></indexterm>
			<para>
				The <literal>exists</literal> function returns a boolean value indicating whether the dynamic property, provided as a parameter to the function, exists on the event. The <literal>exists</literal> function accepts a single dynamic property name as its only parameter. 
			</para>

			<para>
				The <literal>exists</literal> function is for use with dynamic (unchecked) properties. Dynamic properties are properties whose type is not known at compile type. Dynamic properties return a null value
				if the dynamic property does not exists on an event, or if the dynamic property exists but the value of the dynamic property is null. 
			</para>
			
			<para>
				The <literal>exists</literal> function as shown next returns true if the "item" property contains an object that has a "serviceName" property. It returns false if the "item" property is null, or if the "item" property does not 
				contain an object that has a property named "serviceName" :
			</para>
			<programlisting><![CDATA[select exists(item.serviceName?) from OrderEvent]]></programlisting> 
		</sect2>

		<sect2 id="epl-single-row-function-instanceof">
			<title>The <literal>Instance-Of</literal> Function</title>

			<indexterm><primary>instance-of function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>instance-of</secondary></indexterm>
			<para>
				The <literal>instanceof</literal> function returns a boolean value indicating whether the type of value returned by the expression is one of the given types. The first parameter to the <literal>instanceof</literal> function is an expression to evaluate. The second and subsequent parameters are Java type names.
			</para>

			<para>
				The function determines the return type of the expression at runtime by evaluating the expression, and compares the type of object returned by the expression to the defined types. 
				If the type of object returned by the expression matches any of the given types, the function returns <literal>true</literal>. If the expression returned <literal>null</literal> or a type that does not
				match any of the given types, the function returns <literal>false</literal>.
			</para>

			<para>
				The <literal>instanceof</literal> function is often used in conjunction with dynamic (unchecked) properties. Dynamic properties are properties whose type is not known at compile type. 
			</para>

			<para>
				This example uses the <literal>instanceof</literal> function to select different properties based on the type:
			</para>
			<programlisting>select case when instanceof(item, com.mycompany.Service) then serviceName?
  when instanceof(item, com.mycompany.Product) then productName? end 
  from OrderEvent</programlisting>

			<para>
				The <literal>instanceof</literal> function returns <literal>false</literal> if the expression tested by instanceof returned null.
			</para>

			<para>
				Valid parameters for the type parameter list are:
			</para>
	
			<itemizedlist>
				<listitem>
					<para>
						Any of the Java built-in types: <literal>int, long, byte, short, char, double, float, string</literal>, where <literal>string</literal>  is a short notation for <literal>java.lang.String</literal>. The type name is not case-sensitive. For example, the next function tests if the dynamic "price" property is either of type float or type double:
						<synopsis>instanceof(price?, double, float)</synopsis>
					</para>
				</listitem>
				<listitem>
					<para>
						The fully-qualified class name of the class to cast to, for example: <synopsis>instanceof(product, org.myproducer.Product)</synopsis>
					</para>
				</listitem>
			</itemizedlist>
			
			<para>
				The function considers an event class's superclasses as well as all the directly or indirectly-implemented interfaces by superclasses.
			</para>
		</sect2>

		<sect2 id="epl-single-row-function-ref-minmax">
			<title>The <literal>Min</literal> and <literal>Max</literal> Functions</title>

			<indexterm><primary>min function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>min</secondary></indexterm>
			<indexterm><primary>max function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>max</secondary></indexterm>
			<para>
				The <literal>min</literal> and <literal>max</literal> function take two or more parameters that itself can be expressions. The <literal>min</literal> function returns the lowest numeric value among the 2 or more comma-separated expressions, while the <literal>max</literal> function returns the highest numeric value.
				The return type is the compatible aggregated type of all return values.
			</para>

			<para>
				The next example shows the <literal>max</literal> function that has a <literal>Double</literal> return type and returns the value 1.1.
			</para>
			<programlisting>select max(1, 1.1, 2 * 0.5) from ...</programlisting>

			<para>
				The <literal>min</literal> function returns the lowest value. The statement below uses the function to determine the smaller of two timestamp values.
			</para>
	
			<programlisting>select symbol, min(ticks.timestamp, news.timestamp) as minT
	from StockTickEvent.win:time(30 sec) as ticks, NewsEvent.win:time(30 sec) as news
	where ticks.symbol = news.symbol</programlisting>
		</sect2>

		<sect2 id="epl-single-row-function-ref-previous">
			<title>The <literal>Previous</literal> Function</title>

			<indexterm><primary>previous function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>previous</secondary></indexterm>
			<para>
				The <literal>prev</literal> function returns the property value or all event properties of a previous event. For data windows that introduce a sort order other then the order of arrival, such as the sorted data window and the time order data window,  the function returns the event at the specified position.
			</para>

			<para>
				The <literal>prev</literal> function is not an aggregation function and therefore does not return results per group when used with <literal>group by</literal>. Please consider the <literal>last</literal>, <literal>lastever</literal> or <literal>nth</literal> aggregation functions instead as described in <xref linkend="epl-function-aggregation-dwtrack"/>. You must use an aggregation function instead of <literal>prev</literal> when querying a named window.
			</para>

			<para>
				The first parameter to the <literal>prev</literal> function is an index parameter and denotes the i-th previous event, in the order established by the data window. If no index is provided, the default index is 1 and the function returns the previous event.
				The second parameter is a property name or stream name. If specifying a property name, the function returns the value for the previous event property value. If specifying a stream name, the function returns the previous event underlying object.
			</para>

			<para>
				This example selects the value of the <literal>price</literal> property of the 2nd-previous event from the current Trade event:
			</para>
			<programlisting>select prev(2, price) from Trade.win:length(10)</programlisting>

			<para>
				By using the stream alias in the <literal>previous</literal> function, the next example selects the trade event itself that is immediately previous to the current Trade event
			</para>
			<programlisting>select prev(1, trade) from Trade.win:length(10) as trade</programlisting>

			<para>
				Since the <literal>prev</literal> function takes the order established by the data window into account, the function works well with sorted windows.
			</para>
			<para>
				In the following example the statement selects the symbol of the 3 Trade events that had the largest, second-largest and third-largest volume.
			</para>
			<programlisting>select prev(0, symbol), prev(1, symbol), prev(2, symbol)
  from Trade.ext:sort(3, volume desc)</programlisting>

			<para>
				The i-th previous event parameter can also be an expression returning an Integer-type value. The next statement joins the Trade data window with an <literal>RankSelectionEvent</literal> event that provides a <literal>rank</literal> property used to look up a certain position in the sorted Trade data window:
			</para>
			<programlisting>select prev(rank, symbol) from Trade.ext:sort(10, volume desc), RankSelectionEvent unidirectional</programlisting>

			<para>
				Use the <literal>prev</literal> function in combination with a grouped data window to access a previous event per grouping criteria.
			</para>			
			<para>
				The example below returns the price of the previous Trade event for the same symbol, or <literal>null</literal> if for that symbol there is no previous Trade event:
			</para>
			<programlisting>select prev(1, price) from Trade.std:groupwin(symbol).win:length(2)</programlisting>

			<para>
				The <literal>prev</literal> function returns a <literal>null</literal> value if the data window does not currently hold the i-th previous event. The example below illustrates this using a time batch window. Here the <literal>prev</literal>  
				function returns a null value for any events in which the previous event is not in the same batch of events. Note that the <literal>prior</literal> function as discussed below can be used if a null value is not the desired result.
			</para>
			<programlisting>select prev(1, symbol) from Trade.win:time_batch(1 min)</programlisting>			

			<para>
				An alternative form of the <literal>prev</literal> function allows the index to not appear or appear after the property name if the index value is a constant and not an expression:
			</para>
			<programlisting>select prev(1, symbol) from Trade
// ... equivalent to ...
select prev(symbol) from Trade
// ... and ...
select prev(symbol, 1) from Trade</programlisting>			

			<para>
				The combination of the <literal>prev</literal> function and <literal>std:groupwin</literal> view returns the property value for a previous event in the given data window group. 
			</para>

			<para>
				The following example returns for each event the current smallest price per symbol:
			</para>
			<programlisting>select symbol, prev(0, price) as topPricePerSymbol 
from Trade.std:groupwin(symbol).ext:sort(1, price asc)</programlisting>
			
			<sect3 id="epl-single-row-function-ref-prev-restrictions">
				<title>Restrictions</title>
				<para>
						The following restrictions apply to the <literal>prev</literal> functions and its results:
				</para>
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The function always returns a <literal>null</literal> value for remove stream (old data) events.
						</para>
					</listitem>
					<listitem>
						<para>
							The function requires a data window view, or a <literal>std:groupwin</literal> and data window view, without any additional sub-views. See <xref linkend=" epl-views"/> for built-in data window views.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>

			<sect3 id="epl-single-row-function-ref-prev-prior">
				<title>Comparison to the <literal>prior</literal> Function</title>
				<para>
					The <literal>prev</literal> function is similar to the <literal>prior</literal> function. The key differences between the two functions are as follows:				 
				</para>						
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The <literal>prev</literal> function returns previous events in the order provided by the data window, while the <literal>prior</literal> function returns prior events in the order of arrival as posted by a stream's declared views.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>prev</literal> function requires a data window view while the <literal>prior</literal> function does not have any view requirements.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>prev</literal> function returns the previous event grouped by a criteria by combining the <literal>std:groupwin</literal> view and a data window. The <literal>prior</literal> function returns prior events posted by the last view regardless of data window grouping.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>prev</literal> function returns a <literal>null</literal> value for remove stream events, i.e. for events leaving a data window. 
							The <literal>prior</literal> function does not have this restriction.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>
			
		</sect2>

		<sect2 id="epl-single-row-function-ref-previoustail">
			<title>The <literal>Previous-Tail</literal> Function</title>

			<indexterm><primary>previous tail function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>previous tail</secondary></indexterm>
			<para>
				The <literal>prevtail</literal> function returns the property value or all event properties of the positional-first event in a data window. For data windows that introduce a sort order other then the order of arrival, such as the sorted data window and the time order data window, the function returns the first event at the specified position.
			</para>

			<para>
				The <literal>prevtail</literal> function is not an aggregation function and therefore does not return results per group when used with <literal>group by</literal>. Please consider the <literal>first</literal>, <literal>firstever</literal> or <literal>window</literal> aggregation functions instead as described in <xref linkend="epl-function-aggregation-dwtrack"/>. You must use an aggregation function instead of <literal>prevtail</literal> when querying a named window.
			</para>

			<para>
				The first parameter is an index parameter and denotes the i-th from-first event in the order established by the data window. If no index is provided the default is zero and the function returns the first event in the data window.
				The second parameter is a property name or stream name. If specifying a property name, the function returns the value for the previous event property value. If specifying a stream name, the function returns the previous event underlying object.
			</para>

			<para>
				This example selects the value of the <literal>price</literal> property of the first (oldest) event held in the length window:
			</para>
			<programlisting>select prevtail(price) from Trade.win:length(10)</programlisting>

			<para>
				By using the stream alias in the <literal>prevtail</literal> function, the next example selects the trade event itself that is the second event held in the length window:
			</para>
			<programlisting>select prevtail(1, trade) from Trade.win:length(10) as trade</programlisting>

			<para>
				Since the <literal>prevtail</literal> function takes the order established by the data window into account, the function works well with sorted windows.
			</para>

			<para>
				In the following example the statement selects the symbol of the 3 Trade events that had the smallest, second-smallest and third-smallest volume.
			</para>
			<programlisting>select prevtail(0, symbol), prevtail(1, symbol), prevtail(2, symbol)
  from Trade.ext:sort(3, volume asc)</programlisting>

			<para>
				The i-th previous event parameter can also be an expression returning an Integer-type value. The next statement joins the Trade data window with an <literal>RankSelectionEvent</literal> event that provides a <literal>rank</literal> property used to look up a certain position in the sorted Trade data window:
			</para>
			<programlisting>select prevtail(rank, symbol) from Trade.ext:sort(10, volume asc), RankSelectionEvent unidirectional</programlisting>

			<para>
				The <literal>prev</literal> function returns a <literal>null</literal> value if the data window does not currently holds positional-first or the Nth-from-first event. For batch data windows the value returned is relative to the current batch.
			</para>

			<para>
				The following example returns the first and second symbol value in the batch:
			</para>
			<programlisting>select prevtail(0, symbol), prevtail(1, symbol) from Trade.win:time_batch(1 min)</programlisting>			

			<para>
				An alternative form of the <literal>prevtail</literal> function allows the index to not appear or appear after the property name if the index value is a constant and not an expression:
			</para>
			<programlisting>select prevtail(1, symbol) from Trade
// ... equivalent to ...
select prevtail(symbol) from Trade
// ... and ...
select prevtail(symbol, 1) from Trade</programlisting>			

			<para>
				The combination of the <literal>prevtail</literal> function and <literal>std:groupwin</literal> view returns the property value for a positional first event in the given data window group. 
			</para>

			<para>
				Let's look at an example. This statement outputs the oldest price per symbol retaining the last 10 prices per symbol:
			</para>
			<programlisting>select symbol, prevtail(0, price) as oldestPrice
from Trade.std:groupwin(symbol).win:length(10)</programlisting>
			
			<sect3 id="epl-single-row-function-ref-prevtail-restrictions">
				<title>Restrictions</title>
				<para>
						The following restrictions apply to the <literal>prev</literal> functions and its results:
				</para>
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The function always returns a <literal>null</literal> value for remove stream (old data) events.
						</para>
					</listitem>
					<listitem>
						<para>
							The function requires a data window view, or a <literal>std:groupwin</literal> and data window view, without any additional sub-views. See <xref linkend=" epl-views"/> for built-in data window views.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>			
		</sect2>

		<sect2 id="epl-single-row-function-ref-previouswindow">
			<title>The <literal>Previous-Window</literal> Function</title>

			<indexterm><primary>previous window function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>previous window</secondary></indexterm>
			<para>
				The <literal>prevwindow</literal> function returns property values or all event properties for all events in a data window. For data windows that introduce a sort order other then the order of arrival, such as the sorted data window and the time order data window, the function returns the event data sorted in that order, otherwise it returns the events sorted by order of arrival with the newest arriving event first.
			</para>

			<para>
				The <literal>prevwindow</literal> function is not an aggregation function and therefore does not return results per group when used with <literal>group by</literal>. Please consider the <literal>window</literal> aggregation function instead as described in <xref linkend="epl-function-aggregation-dwtrack"/>. You must use an aggregation function instead of <literal>prevwindow</literal> when querying a named window.
			</para>

			<para>
				The single parameter is a property name or stream name. If specifying a property name, the function returns the value of the event property for all events held by the data window. If specifying a stream name, the function returns the event underlying object for all events held by the data window.
			</para>

			<para>
				This example selects the value of the <literal>price</literal> property of all events held in the length window:
			</para>
			<programlisting>select prevwindow(price) from Trade.win:length(10)</programlisting>

			<para>
				By using the stream alias in the <literal>prevwindow</literal> function, the next example selects all trade events held in the length window:
			</para>
			<programlisting>select prevwindow(trade) from Trade.win:length(10) as trade</programlisting>

			<para>
				When used with a data window that introduces a certain sort order, the <literal>prevwindow</literal> function returns events sorted according to that sort order.
			</para>
			
			<para>
			  The next statement outputs for every arriving event the current 10 underying trade event objects that have the largest volume:
			</para>
			<programlisting>select prevwindow(trade) from Trade.ext:sort(10, volume desc) as trade</programlisting>

			<para>
				The <literal>prevwindow</literal> function returns a <literal>null</literal> value if the data window does not currently hold any events.
			</para>

			<para>
				The combination of the <literal>prevwindow</literal> function and <literal>std:groupwin</literal> view returns the property value(s) for all events in the given data window group. 
			</para>

			<para>
				This example statement outputs all prices per symbol retaining the last 10 prices per symbol:
			</para>
			<programlisting>select symbol, prevwindow(price) from Trade.std:groupwin(symbol).win:length(10)</programlisting>
			
			<sect3 id="epl-single-row-function-ref-prevwindow-restrictions">
				<title>Restrictions</title>
				<para>
					The following restrictions apply to the <literal>prev</literal> functions and its results:
				</para>
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The function always returns a <literal>null</literal> value for remove stream (old data) events.
						</para>
					</listitem>
					<listitem>
						<para>
							The function requires a data window view, or a <literal>std:groupwin</literal> and data window view, without any additional sub-views. See <xref linkend=" epl-views"/> for built-in data window views.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>			
		</sect2>

		<sect2 id="epl-single-row-function-ref-previouscount">
			<title>The <literal>Previous-Count</literal> Function</title>

			<indexterm><primary>previous count function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>previous count</secondary></indexterm>
			<para>
				The <literal>prevcount</literal> function returns the number of events held in a data window.
			</para>

			<para>
				The <literal>prevcount</literal> function is not an aggregation function and therefore does not return results per group when used with <literal>group by</literal>. Please consider the <literal>count(*)</literal> aggregation function instead as described in <xref linkend="epl-function-aggregation"/>. You must use an aggregation function instead of <literal>prevcount</literal> when querying a named window.
			</para>

			<para>
				The single parameter is a property name or stream name of the data window to return the count for.
			</para>

			<para>
				This example selects the number of data points for the <literal>price</literal> property held in the length window:
			</para>
			<programlisting>select prevcount(price) from Trade.win:length(10)</programlisting>

			<para>
				By using the stream alias in the <literal>prevcount</literal> function the next example selects the count of trade events held in the length window:
			</para>
			<programlisting>select prevcount(trade) from Trade.win:length(10) as trade</programlisting>

			<para>
				The combination of the <literal>prevcount</literal> function and <literal>std:groupwin</literal> view returns the count of events in the given data window group. 
			</para>

			<para>
				This example statement outputs the number of events retaining the last 10 events per symbol:
			</para>
			<programlisting>select symbol, prevcount(price) from Trade.std:groupwin(symbol).win:length(10)</programlisting>
			
			<sect3 id="epl-single-row-function-ref-prevcount-restrictions">
				<title>Restrictions</title>
				<para>
					The following restrictions apply to the <literal>prev</literal> functions and its results:
				</para>
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The function always returns a <literal>null</literal> value for remove stream (old data) events.
						</para>
					</listitem>
					<listitem>
						<para>
							The function requires a data window view, or a <literal>std:groupwin</literal> and data window view, without any additional sub-views. See <xref linkend=" epl-views"/> for built-in data window views.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>			
		</sect2>

		<sect2 id="epl-single-row-function-ref-prior">
			<title>The <literal>Prior</literal> Function</title>

			<indexterm><primary>prior function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>prior</secondary></indexterm>
			<para>
				The <literal>prior</literal> function returns the property value of a prior event. The first parameter is an integer value that denotes the i-th prior event in the natural order of arrival. 
				The second parameter is a property name for which the function returns the value for the prior event.
				The second parameter is a property name or stream name. If specifying a property name, the function returns the property value for the prior event. If specifying a stream name, the function returns the prior event underlying object.
			</para>

			<para>
				This example selects the value of the <literal>price</literal> property of the 2nd-prior event to the current Trade event.
			</para>
			<programlisting>select prior(2, price) from Trade</programlisting>

			<para>
				By using the stream alias in the <literal>prior</literal> function, the next example selects the trade event itself that is immediately prior to the current Trade event
			</para>
			<programlisting>select prior(1, trade) from Trade as trade</programlisting>

			<para>
				The <literal>prior</literal> function can be used on any event stream or view and does not have any specific view requirements.  The function operates on the order of arrival of events by the event stream or view that provides the events.
			</para>

			<para>
				The next statement uses a time batch window to compute an average volume for 1 minute of Trade events, posting results every minute. The select-clause 
				employs the <literal>prior</literal> function to select the current average and the average before the current average:
			</para>
			<programlisting>select average, prior(1, average) 
    from TradeAverages.win:time_batch(1 min).stat:uni(volume)</programlisting>
	
		</sect2>

		<sect2 id="epl-single-row-function-typeof">
			<title>The <literal>Type-Of</literal> Function</title>

			<indexterm><primary>type-of function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>type-of</secondary></indexterm>
			<para>
				The <literal>typeof</literal> function, when parameterized by a stream name, returns the event type name of the evaluated event which can be useful with variant streams. When parameterized by an expression or property name, the function returns the type name of the expression result or <literal>null</literal> if the expression result is null.
			</para>

			<para>
				In summary, the function determines the return type of the expression at runtime by evaluating the expression and returns the type name of the expression result.
			</para>

			<para>
				The <literal>typeof</literal> function is often used in conjunction with variant streams. A variant stream is a predefined stream into which events of multiple disparate event types can be inserted. The <literal>typeof</literal> function, when passed a stream name alias, returns the name of the event type of each event in the stream.
			</para>
			
			<para>
			    The following example elaborates on the use of variant streams with <literal>typeof</literal>. The first statement declares a variant stream <literal>SequencePatternStream</literal>:
			</para>
			<programlisting><![CDATA[create variant schema SequencePatternStream as *]]></programlisting>

			<para>
			    The next statement inserts all order events and is followed by a statement to insert all product events: 
			</para>
			<programlisting><![CDATA[insert into SequencePatternStream select * from OrderEvent;]]></programlisting>
			<programlisting><![CDATA[insert into SequencePatternStream select * from PriceEvent;]]></programlisting>
			
			<para>
				This example statement returns the event type name for each event in the variant stream:
			</para>
			<programlisting><![CDATA[select typeof(sps) from SequencePatternStream as sps]]></programlisting>

			<para>
				The next example statement detects a pattern by utilizing the <literal>typeof</literal> function to find pairs of order event immediately followed by product event:
			</para>
			<programlisting><![CDATA[select * from SequencePatternStream match_recognize(
  measures A as a, B as b
  pattern (A B)
  define A as typeof(A) = "OrderEvent",
         B as typeof(B) = "ProductEvent"
  )]]></programlisting>

			<para>
				When passing a property name to the <literal>typeof</literal> function, the function evaluates whether the property type is event type (a fragment event type). If the property type is event type, the function returns the type name of the event in the property value or <literal>null</literal> if not provided. 
				If the property type is not event type, the function returns the simple class name of the property value.
			</para>
			
			<para>
				When passing an expression to the <literal>typeof</literal> function, the function evaluates the expression and returns the simple class name of the expression result value or <literal>null</literal> if the expression result value is null.
			</para>
			<para>
				This example statement returns the simple class name of the value of the dynamic property <literal>prop</literal> of events in stream <literal>MyStream</literal>, or a <literal>null</literal> value if the property is not found for an event or the property value itself is <literal>null</literal>:
			</para>
			<programlisting><![CDATA[select typeof(prop?) from MyStream]]></programlisting>
			
			<para>
			    When using subclasses or interface implementations as event classes or when using Map-event type inheritance, the function returns the event type name provided when the class or Map-type event was registered, or if the event type was not registered, the function returns the fully-qualified class name.
			</para>
		</sect2>
	</sect1>		
	
	<sect1 id="epl-function-aggregation">
		<title>Aggregate Functions</title>

		<indexterm><primary>aggregation functions</primary><secondary>overview</secondary></indexterm>
		
		<para>
			Aggregation functions return a single value from a collection of input values. The <literal>group by</literal> keywords are often used in conjunction with aggregation functions to group the result-set by one or more columns.
		</para>

		<para>
			The EPL language extends the standard SQL aggregation functions by allowing filters and by further useful aggregation functions that can track a data window or compute event rates, for example. Your application may also add its own aggregation function as <xref linkend="custom-aggregation-function"/> describes.
		</para>
		
		<para>
			Aggregation values are always computed incrementally: Insert and remove streams result in aggregation value changes. The exceptions are on-demand queries and joins when using the <literal>unidirectional</literal> keyword. Aggregation functions are optimized to retain the minimal
				information necessary to compute the aggregated result. 
		</para>
		
		<para>
			Aggregation functions can also be used with unbound streams when no data window is specified.
		</para>

		<sect2 id="epl-function-aggregation-std">
			<title>SQL-Standard Functions</title>

			<para>
				The SQL-standard aggregation functions are shown in below table.
			</para>
	
			<table frame="topbot" id="epl-grouping-aggregate-func-table-SQL" revision="2">
				<title>Syntax and results of SQL-standard aggregation functions</title>
				<tgroup cols="2">
					<colspec colwidth="1*"/>
					<colspec colwidth="2.0*"/>
					<thead>
						<row>
							<entry>Aggregate Function</entry>
							<entry>Result</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>avedev([all|distinct] <emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</entry>
							<entry>
								<para>
									Mean deviation of the (distinct) values in the expression, returning a value of <literal>double</literal> type.
								</para>
								<para>
									The optional filter expression limits the values considered for computing the mean deviation.
								</para>
							</entry>
						</row>
						<row>
							<entry>avg([all|distinct] <emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</entry>
							<entry>
								<para>
									Average of the (distinct) values in the expression, returning a value of <literal>double</literal> type.
								</para>
								<para>
									The optional filter expression limits the values considered for computing the average.
								</para>
							</entry>
						</row>
						<row>
							<entry>count([all|distinct] <emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</entry>
							<entry>
								<para>
									Number of the (distinct) non-null values in the expression, returning a value of <literal>long</literal> type.
								</para>
								<para>
									The optional filter expression limits the values considered for the count.
								</para>
							</entry>
						</row>
						<row>
							<entry>count(* [, <emphasis>filter_expr</emphasis>])</entry>
							<entry>
								<para>
									Number of events, returning a value of <literal>long</literal> type.
								</para>
								<para>
									The optional filter expression limits the values considered for the count.
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									max([all|distinct] <emphasis>expression</emphasis>)
								</para>
								<para>
									fmax([all|distinct] <emphasis>expression</emphasis>, <emphasis>filter_expr</emphasis>)
								</para>
							</entry>
							<entry>
								<para>
									Highest (distinct) value in the expression, returning a value of the same type as the expression itself returns.
								</para>
								<para>
									Use <literal>fmax</literal> to provide a filter expression that limits the values considered for computing the maximum.
								</para>
							</entry>
						</row>
						<row>
							<entry>median([all|distinct] <emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</entry>
							<entry>
								<para>
									Median (distinct) value in the expression, returning a value of <literal>double</literal> type. Double Not-a-Number (NaN) values are ignored in the median computation.
								</para>
								<para>
									The optional filter expression limits the values considered for computing the median.
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									min([all|distinct] <emphasis>expression</emphasis>)
								</para>
								<para>
									fmin([all|distinct] <emphasis>expression</emphasis>, <emphasis>filter_expr</emphasis>)
								</para>
							</entry>
							<entry>
								<para>
									Lowest (distinct) value in the expression, returning a value of the same type as the expression itself returns.
								</para>
								<para>
									Use <literal>fmin</literal> to provide a filter expression that limits the values considered for computing the maximum.
								</para>
							</entry>
						</row>
						<row>
							<entry>stddev([all|distinct] <emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</entry>
							<entry>
								<para>
									Standard deviation of the (distinct) values in the expression, returning a value of <literal>double</literal> type.
								</para>
								<para>
									The optional filter expression limits the values considered for computing the standard deviation.
								</para>
							</entry>
						</row>
						<row>
							<entry>sum([all|distinct] <emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</entry>
							<entry>
								<para>
									Totals the (distinct) values in the expression, returning a value of <literal>long, double, float or integer</literal> type depending on the expression.
								</para>
								<para>
									The optional filter expression limits the values considered for computing the total.
								</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
	
			<para>
				If your application provides double-type values to an aggregation function, avoid using Not-a-Number (NaN) and infinity. Also when using double-type values, round-off errors (or rounding errors) may occur due to double-type precision. Consider rounding your result value to the desired precision.
			</para>
			
			<para>
			  Each of the aggregation functions above takes an optional filter expression as a parameter. The filter expression must return a boolean-type value and applies to the events considered for the aggregation. 
			  If a filter expression is provided, then only if the filter expression returns a value of true does the engine update the aggregation for that event or combination of events. 
			</para>
			
			<para>
			  Consider the following example, which computes the quantity fraction of buy orders among all orders:
			</para>
			<programlisting>select sum(quantity, side='buy') / sum(quantity) as buy_fraction from Orders</programlisting>

			<para>
				Use the <literal>fmin</literal> and <literal>fmax</literal> aggregation functions instead of the <literal>min</literal> and <literal>max</literal> aggregation functions when providing a filter expression (the <literal>min</literal> and <literal>max</literal> functions are also single-row functions).
			</para>

			<para>
			  The next example computes the minimum quantity for buy orders and a separate minimum quantity for sell orders:
			</para>
			<programlisting>select fmin(quantity, side='buy'), fmin(quantity, side = 'sell') from Orders</programlisting>
			
		</sect2>
	
		<sect2 id="epl-function-aggregation-dwtrack">
			<title>Data Window Aggregation Functions</title>

			<para>
				The <literal>first</literal>, <literal>last</literal> and <literal>window</literal> aggregation functions return event properties of events present in a stream's data window. They are useful when information about current data window contents is required.
			</para>
			
			<para>
				When comparing the <literal>last</literal> aggregation function to the <literal>prev</literal> function, the differences are as follows. The <literal>prev</literal> function is not an aggregation function and thereby not sensitive to the presence of <literal>group by</literal>. The <literal>prev</literal> function accesses data window contents directly and respects the sort order of the data window. The <literal>last</literal> aggregation function returns results based on arrival order and tracks data window contents in a separate shared data structure.
			</para>

			<para>
				When comparing the <literal>first</literal> aggregation function to the <literal>prevtail</literal> function, the differences are as follows. The <literal>prevtail</literal> function is not an aggregation function and thereby not sensitive to the presence of <literal>group by</literal>. The <literal>prevtail</literal> function accesses data window contents directly and respects the sort order of the data window. The <literal>first</literal> aggregation function returns results based on arrival order and tracks data window contents in a separate shared data structure.
			</para>

			<para>
				When comparing the <literal>window</literal> aggregation function to the <literal>prevwindow</literal> function, the differences are as follows. The <literal>prevwindow</literal> function is not an aggregation function and thereby not sensitive to the presence of <literal>group by</literal>. The <literal>prevwindow</literal> function accesses data window contents directly and respects the sort order of the data window. The <literal>window</literal> aggregation function returns results based on arrival order and tracks data window contents in a separate shared data structure.
			</para>

			<para>
				When comparing the <literal>count</literal> aggregation function to the <literal>prevcount</literal> function, the differences are as follows. The <literal>prevcount</literal> function is not an aggregation function and thereby not sensitive to the presence of <literal>group by</literal>.
			</para>

			<para>
				When comparing the <literal>last</literal> aggregation function to the <literal>nth</literal> aggregation function, the differences  are as follows. The <literal>nth</literal> aggregation function does not consider out-of-order deletes (for example with on-delete and sorted windows) and does not revert to the prior expression value when the last event or nth-event was deleted from a data window. The <literal>last</literal> aggregation function tracks the data window and reflects out-of-order deletes.
			</para>

			<para>
				From an implementation perspective, the <literal>first</literal>, <literal>last</literal> and <literal>window</literal> aggregation functions share a common data structure for each stream. 
			</para>
			
			<sect3 id="epl-function-aggregation-dwtrack-first">
				<title><literal>First</literal> Aggregation Function</title>
		
				<para>
					The synopsis for the <literal>first</literal> aggregation function is:
				</para>
				<synopsis><literal>first(</literal>*|<emphasis>stream</emphasis>.*|<emphasis>value_expression</emphasis> [, <emphasis>index_expression</emphasis>])</synopsis>

				<para>
					The <literal>first</literal> aggregation function returns properties of very first event in the data window. When used with <literal>group by</literal>, it returns properties of the first event in the data window for each group. When specifying an index expression, the function returns properties of the Nth-subsequent event to the first event, all according to order of arrival.
				</para>
				
				<para>
					The first parameter to the function is required and defines the event properties or expression result to return. The second parameter is an optional <emphasis>index_expression</emphasis> that must return an integer value used as an index to evaluate the Nth-subsequent event to the first event.
				</para>
				
				<para>
					You may specify the wildcard (<literal>*</literal>) character in which case the function returns the underlying event of the single selected stream. When selecting a single stream you may specify no parameter instead of wildcard. For joins and subqueries you must use the stream wildcard syntax below.
				</para>

				<para>
					You may specify the stream name and wildcard (<literal>*</literal>) character in the <emphasis>stream</emphasis><literal>.*</literal> syntax. This returns the underlying event for the specified stream.
				</para>

				<para>
					You may specify a <emphasis>value_expression</emphasis> to evaluate for the first event. The value expression may not select properties from multiple streams.
				</para>
				
				<para>
				    The <emphasis>index_expression</emphasis> is optional. If no index expression is provided, the function returns the first event. If present, the function evaluates the index expression to determine the value for N, and evaluates the Nth-subsequent event to the first event. A value of zero returns the first event and a value of 1 returns 
				    the event subsequent to the first event. You may not specify event properties in the index expression.
				</para>
				
				<para>
					The function returns <literal>null</literal> if there are no events in the data window or when the index is larger then the number of events held in the data window. If used with <literal>group by</literal>, it returns <literal>null</literal> if there are no events in the data window for that group or when the index is larger then the number of events held in the data window for that group.
				</para>

				<para>
					To explain, consider the statement below which selects the underlying event of the first sensor event held by the length window of 2 events.  
				</para>
				<programlisting>select first(*) from SensorEvent.win:length(2) </programlisting>
				
				<para>
				   Assume event E1, event E2 and event E3 are of type SensorEvent. When event E1 arrives the statement outputs the underlying event E1. When event E2 arrives the statement again outputs the underlying event E1. When event E3 arrives the statement outputs the underlying event E2, since 
				   event E1 has left the data window.
				</para>

				<para>
					The stream wildcard syntax is useful for joins and subqueries. This example demonstrates a subquery that returns the first SensorEvent when a DoorEvent arrives:
				</para>
				<programlisting>select (select first(se.*) from SensorEvent.win:length(2) as se) from DoorEvent </programlisting>
				
				<para>
					The following example shows the use of an index expression. The output value for <literal>f1</literal> is the temperature property value of the first event in the data window, the value for <literal>f2</literal> is the temperature property value of the second event in the data window:
				</para>
				<programlisting>select first(temperature, 0) as f1, first(temperature, 1) as f2
from SensorEvent.win:time(10 sec)</programlisting>

				<para>
					You may use dot-syntax to invoke a method on the first event. You may also append a property name using dot-syntax.
				</para>
			</sect3>

			<sect3 id="epl-function-aggregation-dwtrack-last">
				<title><literal>Last</literal> Aggregation Function</title>
		
				<para>
					The synopsis for the <literal>last</literal> aggregation function is:
				</para>
				<synopsis><literal>last(</literal>*|<emphasis>stream</emphasis>.*|<emphasis>value_expression</emphasis> [, <emphasis>index_expression</emphasis>])</synopsis>

				<para>
					The <literal>last</literal> aggregation function returns properties of the very last event in the data window. When used with <literal>group by</literal>, it returns properties of the last event in the data window for each group. When specifying an index expression, the function returns properties of the Nth-prior event to the last event, all according to order of arrival.
				</para>

				<para>
					Similar to the <literal>first</literal> aggregation function described above, you may specify the wildcard (<literal>*</literal>) character, no parameter or stream name and wildcard (<literal>*</literal>) character or a <emphasis>value_expression</emphasis> to evaluate for the last event.
				</para>

				<para>
				    The <emphasis>index_expression</emphasis> is optional. If no index expression is provided, the function returns the last event. If present, the function evaluates the index expression to determine the value for N, and evaluates the Nth-prior event to the last event.  A value of zero returns the last event and a value of 1 returns 
				    the event prior to  the last event.
				    You may not specify event properties in the index expression.
				</para>
				
				<para>
					The function returns <literal>null</literal> if there are no events in the data window or when the index is larger then the number of events held in the data window. If used with <literal>group by</literal>, it returns <literal>null</literal> if there are no events in the data window for that group or when the index is larger then the number of events held in the data window for that group.
				</para>

				<para>
					The next statement selects the underlying event of the first and last sensor event held by the time window of 10 seconds:
				</para>
				<programlisting>select first(*), last(*) from SensorEvent.win:time(10 sec) </programlisting>
				
				<para>
					The statement shown next selects the last temperature (<literal>f1</literal>) and the prior-to-last temperature (<literal>f1</literal>) of sensor events in the last 10 seconds:
				</para>
				<programlisting>select last(temperature, 0) as f1, select last(temperature, 1) as f2
from SensorEvent.win:time(10 sec)</programlisting>
			</sect3>

			<sect3 id="epl-function-aggregation-dwtrack-window">
				<title><literal>Window</literal> Aggregation Function</title>
		
				<para>
					The synopsis for the <literal>window</literal> aggregation function is:
				</para>
				<synopsis><literal>window(</literal>*|<emphasis>stream</emphasis>.*|<emphasis>value_expression</emphasis>)</synopsis>

				<para>
					The <literal>window</literal> aggregation function returns properties of all events in the data window. When used with <literal>group by</literal>, it returns properties of all events in the data window for each group.
				</para>

				<para>
					Similar to the <literal>first</literal> aggregation function described above, you may specify the wildcard (<literal>*</literal>) character or stream name and wildcard (<literal>*</literal>) character or a <emphasis>value_expression</emphasis> to evaluate for all events.
				</para>

				<para>
					The function returns <literal>null</literal> if there are no events in the data window. If used with <literal>group by</literal>, it returns <literal>null</literal> if there are no events in the data window for that group.
				</para>

				<para>
					The next statement selects the underlying event of all events held by the time window of 10 seconds:
				</para>
				<programlisting>select window(*) from SensorEvent.win:time(10 sec) </programlisting>
				
				<para>
					The <literal>window</literal> aggregation function requires that your stream is bound by a data window. You may not use the <literal>window</literal> aggregation function on unbound streams with the exception of on-demand queries.
				</para>
			</sect3>

		</sect2>
		
		<sect2 id="epl-function-aggregation-add">
			<title>Additional Aggregation Functions</title>

			<para>
				Esper provides the following additional aggregation functions beyond those in the SQL standard:
			</para>
		
			<table frame="topbot" id="epl-grouping-aggregate-func-table-ext" revision="2">
				<title>Syntax and results of EPL aggregation functions</title>
				<tgroup cols="2">
					<colspec colwidth="1*"/>
					<colspec colwidth="2.0*"/>
					<thead>
						<row>
							<entry>Aggregate Function</entry>
							<entry>Result</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>firstever(<emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</entry>
							<entry>
								<para>
									The <literal>firstever</literal> aggregation function returns the very first value ever. If used with <literal>group by</literal> it returns the first value ever for that group.
								</para>				
								<para>
									If used with a data window, the result of the function does not change as data points leave a data window. Use the <literal>first</literal> or <literal>prevtail</literal> function to return values relative to a data window.
								</para>
								<para>
									The optional filter expression limits the values considered for retaining the first-ever value.
								</para>
								<para>
									The next example statement outputs the first price ever for sell orders:
								</para>
								<programlisting>select firstever(price, side='sell') from Order</programlisting>
							</entry>
						</row>
						<row>
							<entry>lastever(<emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</entry>
							<entry>
								<para>
									Returns the last value or last value per group, if used with <literal>group by</literal>.
								</para>
								<para>
									This sample statement outputs the total price, the first price and the last price per symbol for the last 30 seconds of events and every 5 seconds:
								</para>
								<programlisting>select symbol, sum(price), lastever(price), firstever(price)
from StockTickEvent.win:time(30 sec) 
group by symbol
output every 5 sec</programlisting>
								<para>
									If used with a data window, the result of the function does not change as data points leave a data window (for example when all data points leave the data window). Use the <literal>last</literal> or <literal>prev</literal> function to return values relative to a data window.
								</para>
								<para>
									The optional filter expression limits the values considered for retaining the last-ever value.
								</para>
								<para>
									The next example statement outputs the last price (ever) for sell orders:
								</para>
								<programlisting>select lastever(price, side='sell') from Order</programlisting>
							</entry>
						</row>
						<row>
							<entry>leaving()</entry>
							<entry>
								<para>
									Returns true when any remove stream data has passed, for use in the <literal>having</literal> clause to output only when a data window has filled.
								</para>
								<para>
									The <literal>leaving</literal> aggregation function is useful when you want to trigger output after a data window has a remove stream data point. Use the <literal>output after</literal> syntax as an alternative to output after a time interval.
								</para>
								<para>
									This sample statement uses <literal>leaving()</literal> to output after the first data point leaves the data window, ignoring the first datapoint:
								</para>
								<programlisting>select symbol, sum(price) 
from StockTickEvent.win:time(30 sec) 
having leaving()</programlisting>
							</entry>
						</row>
						<row>
							<entry>nth(<emphasis>expression</emphasis>, <emphasis>N_index</emphasis>)</entry>
							<entry>
								<para>
									Returns the Nth oldest element; If N=0 returns the most recent value. If N=1 returns the value before the most recent value. If N is larger than the events held in the data window for this group, returns null.
								</para>
								<para>
									A maximum N historical values are stored, so it can be safely used to compare
									recent values in large views without incurring excessive overhead.
								</para>
								<para>
									As compared to the <literal>prev</literal> row function, this aggregation function works within the current <literal>group by</literal> group, see <xref linkend="processingmodel_aggregation_output"/>.
								</para>
								<para>
									This statement outputs every 2 seconds the groups that have new data and their last price and the previous-to-last price:
								</para>
								<programlisting>select symbol, nth(price, 1), last(price) 
from StockTickEvent 
group by symbol
output last every 2 sec</programlisting>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									rate(<emphasis>number_of_seconds</emphasis>)
								</para>
							</entry>
							<entry>
								<para>
									Returns an event arrival rate per second over the provided number of seconds, computed based on engine time.								
								</para>
								<para>
									Returns null until events fill the number of seconds. Useful with <literal>output snapshot</literal> to output a current rate. This function footprint is for use without a data window onto the stream(s).
								</para>
								<para>
									A sample statement to output, every 2 seconds, the arrival rate per second considering the last 10 seconds of events is shown here:
								</para>
								<programlisting>select rate(10) from StockTickEvent
output snapshot every 2 sec</programlisting>
								<para>
									The aggregation function retains an engine timestamp value for each arriving event.
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									rate(<emphasis>timestamp_property</emphasis>[, <emphasis>accumulator</emphasis>])
								</para>
							</entry>
							<entry>
								<para>
									Returns an event arrival rate over the data window including the last remove stream event. The <emphasis>timestamp_property</emphasis>
									is the name of a long-type property of the event that provides a timestamp value.
								</para>
								<para>
									The first parameter is a property name or expression providing millisecond timestamp values.
								</para>
								<para>
									The optional second parameter is a property or expression for computing an accumulation rate: If a value is provided as a second parameter then the accumulation rate for that quantity is returned (e.g. turnover in dollars per second).
								</para>
								<para>
									This footprint is designed for use with a data window and requires a data window declared onto the stream. Returns null until events start leaving the window.
								</para>
								<para>
									This sample statement outputs event rate for each group (symbol) with fixed sample size of four events 
									(and considering the last event that left). The <literal>timestamp</literal> event property must be part of the event for this to work.
								</para>
								<programlisting>select colour, rate(timestamp) as rate 
from StockTickEvent.std:groupwin(symbol).win:length(4) 
group by symbol</programlisting>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		
			<para>
				Built-in aggregation functions can be disabled via configuration (see <xref linkend="config-engine-expression-extendedagg"/>). A custom aggregation function of the same name as a built-on function may be registered to override the built-in function.
			</para>
		</sect2>
	</sect1>		

	<sect1 id="epl-function-user-defined">
		<title>User-Defined Functions</title>
		
		<indexterm><primary>user-defined function</primary></indexterm>
		<indexterm><primary>functions</primary><secondary>user-defined</secondary></indexterm>
		<indexterm><primary>UDF</primary><secondary>user-defined function</secondary></indexterm>
		 <para>
			 A user-defined function (UDF) is a single-row function that can be invoked anywhere as an expression itself or within an expresson. The function must simply be a public static method
			 that the classloader can resolve at statement creation time. The engine resolves the function reference at statement creation time and verifies parameter types.
		 </para>

		<para>
			You may register your own single-row function name for the user-defined function so that your EPL statements are less cluttered. This is described in detail in <xref linkend="custom-singlerow-function"/>. 
		</para>

		 <para>
			 User-defined functions can be also be invoked on instances of an event: Please see <xref linkend="epl-from-clause-stream-name"/> to invoke event instance methods on a named stream.
		 </para>
		 
		 <para>
			 Note that user-defined functions (not single-row functions) are candidate for caching their return result if the parameters passed are constants and they are not used chained. Please see below for details and configuration.
		 </para>

		 <para>
			 The example below assumes a class <literal>MyClass</literal> that exposes a public static method <literal>myFunction</literal> accepting 2 parameters, and
			 returing a numeric type such as <literal>double</literal>.
		 </para>
		 
<programlisting><![CDATA[select 3 * com.mycompany.MyClass.myFunction(price, volume) as myValue 
from StockTick.win:time(30 sec)]]></programlisting>

		 <para>
			 User-defined functions also take array parameters as this example shows. The section on <xref linkend="epl-operator-ref-array"/> outlines in more detail the types of arrays produced.
		 </para>		
		<programlisting><![CDATA[select * from RFIDEvent where com.mycompany.rfid.MyChecker.isInZone(zone, {10, 20, 30})]]></programlisting>

		<para>
			Java class names have to be fully qualified (e.g. java.lang.Math) but Esper provides a mechanism for user-controlled imports of classes and packages as outlined in <xref linkend="config-class--package-imports"/>.
		</para>

		 <para>
			 User-defined functions can return any value including <literal>null</literal>, Java objects or arrays. Therefore user-defined functions can serve to transform, convert or map events, or to extract information and assemble further events.
		 </para>

		 <para>
			 The following statement is a simple pattern that looks for events of type E1 that are followed by events of type E2. It assigns the tags "e1" and "e2" that the function can use to assemble a final event for output:
		 </para> 
		<programlisting><![CDATA[select MyLib.mapEvents(e1, e2) from pattern [every e1=E1 -> e2=E2]]]></programlisting>

		 <para>
			 User-defined functions may also be chained: If a user-defined function returns an object then the object can itself be the target of the next function call and so on.
		 </para> 

		 <para>
			 Assume that there is a <literal>calculator</literal> function in the <literal>MyLib</literal> class that returns a class which provides the <literal>search</literal> method taking two parameters. The EPL
			 that takes the result of the <literal>calculator</literal> function and that calls the <literal>search</literal> method on the result and returns its return value is shown below:
		 </para> 
		<programlisting><![CDATA[select MyLib.calculator().search(zonevariable, zone) from RFIDEvent]]]></programlisting>

		 <para>
			 A user-defined function should be implemented thread-safe. 
		 </para> 

		<sect3 id="epl-function-user-defined-converting">
			<title>Event Type Conversion via User-Defined Function</title>
			 <para>
				 A function that converts from one event type to another event type is shown in the next example. The first statement declares a stream that consists of MyEvent events. The second statement employs a conversion function to convert MyOtherEvent events to events of type MyEvent:
			 </para> 
			<programlisting><![CDATA[insert into MyStream select * from MyEvent
	insert into MyStream select MyLib.convert(other) from MyOtherEvent as other]]></programlisting>
	
			 <para>
				 In the example above, assuming the event classes MyEvent and MyOtherEvent are Java classes, the static method should have the following footprint:
			 </para> 
			 <programlisting><![CDATA[public static MyEvent convert(MyOtherEvent otherEvent)]]></programlisting>
		</sect3>
		
		<sect3 id="epl-function-user-defined-cached">
			<title>User-Defined Function Result Cache</title>
			 <para>
				 For user-defined functions that take no parameters or only constants as parameters the engine automatically caches the return result of the function, and invokes the function only once. This is beneficial to performance 
				 if your function indeed returns the same result for the same input parameters.
			</para>
			 <para>
				 You may disable caching of return values of user-defined functions via configuration as described in <xref linkend="config-engine-expression-udfcache"/>.
			</para>
		</sect3>

		<sect3 id="epl-function-user-defined-matching">
			<title>Parameter Matching</title>
			 <para>
				 EPL follows Java standards in terms of widening, performing widening automatically in cases where widening type conversion is allowed without loss of precision, for both boxed and primitive types.				 
			 </para> 
			 
			 <para>
				 When user-defined functions are overloaded, the function with the best match is selected based on how well the arguments to a function can match up with the parameters, giving preference to the function that requires the least number of widening conversions.
			 </para>

			 <para>
				 Boxing and unboxing of arrays is not supported in UDF as it is not supported in Java. For example, an array of <literal>Integer</literal> and an array of <literal>int</literal> are not compatible types.
			 </para>

			 <para>
				 When using <literal>{}</literal> array syntax in EPL, the resulting type is always a boxed type: <literal>"{1, 2}"</literal> is an array of <literal>Integer</literal> (and not <literal>int</literal> since it may contain null values), <literal>"{1.0, 2d}"</literal> is an array of <literal>Double</literal> and <literal>"{'A', "B"}"</literal> is an array of <literal>String</literal>, while <literal>"{1, "B", 2.0}"</literal> is an array of <literal>Object</literal> (<literal>Object[]</literal>).
			 </para>
		</sect3>

	</sect1>

	<sect1 id="functionreference-transpose">
		<title>Select-Clause <literal>transpose</literal> Function</title>
		
		<para>
		  The <literal>transpose</literal> function is only valid in the select-clause and indicates that the result of the parameter expression should become the underlying event object of the output event.
		</para>
		
		<para>
		  The <literal>transpose</literal> function takes a single expression as a parameter. The result object of the parameter expression is subject to transposing as described below.
		</para>

		<para>
		  The function can be useful with <literal>insert into</literal> to allow an object returned by an expression to become the event itself in the output stream.
		</para>
		
		<para>
		  Any expression returning a Java object can be used with the <literal>transpose</literal> function. Typical examples for expressions are a static method invocation, the result of an enumeration method, a plug-in single row function or a subquery. 
		</para>

		<para>
		  The examples herein assume that a single-row function by name <literal>makeEvent</literal> returns an <literal>OrderEvent</literal> instance (a POJO object, not shown).
		</para>
		
		<para>
		  The following EPL takes the result object of the invocation of the <literal>makeEvent</literal> method (assumed to be an OrderEvent instance) and returns the OrderEvent instance as the underlying event of the output event:
		</para>
		<programlisting><![CDATA[select transpose(makeEvent(oi)) from OrderIndication oi]]></programlisting>

		<para>
		  Your select-clause can select additional properties or expressions. In this case the output event underlying object is a pair of the expression result object and the additional properties.
		</para>
		
		<para>
		  The next EPL also selects the <literal>origin</literal> property of the order indication event. The output event is a pair of the OrderEvent instance and a map containing the property name and value of origin:
		</para>
		<programlisting><![CDATA[select origin, transpose(makeEvent(oi)) from OrderIndication oi]]></programlisting>

		<para>
		  If the <literal>transpose</literal> function is not a top-level function, i.e. if it occurs within another expression or within any other clause then the select-clause, the function simple returns the expression result of the parameter expression.
		</para>

		<sect2 id="functionreference-transpose-insert-into">
			<title>Transpose with Insert-Into</title>

			<para>
				  You may insert transposed output events into another stream.
			</para>
			
			<para>
				  If the stream name in the insert-into clause is already associated to an event type, the engine checks whether the event type associated to the stream name provided in the insert-into clause matches the event type associated to the object returned by the expression. If the stream name in the insert-into clause is not already associated to an existing event type the engine associates a new event type using the stream name provided in the insert-into clause.
			</para>

			<para>
				For example, the next statement associates the stream name <literal>OrderEvent</literal> with the class. Alternatively this association can be achieved via static or runtime configuration API:
			</para>
			<programlisting><![CDATA[create schema OrderEvent as com.mycompany.OrderEvent]]></programlisting>
			
			<para>
				An EPL statement can insert into the <literal>OrderEvent</literal> stream the <literal>OrderEvent</literal> instance returned by the <literal>makeEvent</literal> method, as follows:
			</para>
			<programlisting><![CDATA[insert into OrderEvent select transpose(makeEvent(oi)) from OrderIndication oi]]></programlisting>
			
			<para>
				It is not valid to select additional properties or expressions in this case, as they would not be part of the output event. The following is not valid:
			</para>
			<programlisting><![CDATA[// not valid
insert into OrderEvent select origin, transpose(makeEvent(oi)) from OrderIndication oi]]></programlisting>
		</sect2>
	</sect1>

</chapter>