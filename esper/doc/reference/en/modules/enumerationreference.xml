<chapter id="enumerationreference">
    <title>EPL Reference: Enumeration Methods</title>
        
	<sect1 id="enumeration-intro">
		<title>Overview</title>
		<indexterm><primary>methods</primary><secondary>enumeration</secondary></indexterm>
		
		<para>
			EPL provides enumeration methods that work with lambda expressions to perform common tasks on subquery results, named windows, event properties or inputs that are or can be projected to a collection of events, scalar values or objects.
		</para>

		<para>
			A lambda expression is an anonymous expression.  Lambda expressions are useful for encapsulating user-defined expressions that are applied to each element in a collection. This section discusses built-in enumeration methods and their lambda expression parameters.
		</para>
		
		<para>
			Lambda expressions use the lambda operator <literal>=&gt;</literal>, which is read as "goes to". The left side of the lambda operator specifies the lambda expression input parameter(s) (if any) and the right side holds the expression. The lambda expression x => x * x is read "x goes to x times x.". 
			Lambda expressions are also used for expression declaration as discussed in <xref linkend="epl-syntax-expression-decl"/>.
		</para>
		
		<para>
			When writing lambdas, you do not have to specify a type for the input parameter(s) or output result(s) because the engine can infer all types based on the input and the expression body. So if you are querying an RFIDEvent, for example, then the input variable is inferred to be an RFIDEvent event, which means you have access to its properties and methods.
		</para>
	
		<para>
			The term <emphasis>element</emphasis> in respect to enumeration methods means a single event, scalar value or object in a collection that is the input to an enumeraton method. The term <emphasis>collection</emphasis> means a sequence or group of elements.
		</para>
		
		<para>
			The below table summarizes the built-in enumeration methods available:
		</para>

		<table frame="topbot" id="enumeration_method_table" revision="2">
			<title>Enumeration Methods</title>
			<tgroup cols="2">
				<colspec colwidth="1.0*"/>
				<colspec colwidth="2.0*"/>
				<thead>
					<row>
						<entry>Method</entry>
						<entry>Result</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>aggregate(seed, accumulator lambda)</entry>
						<entry>
							<para>
								Aggregate elements by using seed as an initial accumulator value and applying an accumulator expression.
							</para>
							<para>
								<xref linkend="enumeration-method-aggregate"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>allof(predicate lambda)</entry>
						<entry>
							<para>
								Return true when all elements satisfy a condition.
							</para>
							<para>
								<xref linkend="enumeration-method-allof"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>anyof(predicate lambda)</entry>
						<entry>
							<para>
								Return true when any element satisfies a condition.
							</para>
							<para>
								<xref linkend="enumeration-method-anyof"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>average()</entry>
						<entry>
							<para>
								Computes the average of values obtained from numeric elements.
							</para>
							<para>
								<xref linkend="enumeration-method-average"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>average(projection lambda)</entry>
						<entry>
							<para>
								Computes the average of values obtained from elements by invoking a projection expression on each element.
							</para>
							<para>
								<xref linkend="enumeration-method-average"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>countof()</entry>
						<entry>
							<para>
								Returns the number of elements.
							</para>
							<para>
								<xref linkend="enumeration-method-countof"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>countof(predicate lambda)</entry>
						<entry>
							<para>
								Returns the number of elements that satisfy a condition.
							</para>
							<para>
								<xref linkend="enumeration-method-countof"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>except(source)</entry>
						<entry>
							<para>
								Produces the set difference of the two collections.
							</para>
							<para>
								<xref linkend="enumeration-method-except"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>firstof()</entry>
						<entry>
							<para>
								Returns the first element.
							</para>
							<para>
								<xref linkend="enumeration-method-firstof"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>firstof(predicate lambda)</entry>
						<entry>
							<para>
								Returns the first element that satisfies a condition.
							</para>
							<para>
								<xref linkend="enumeration-method-firstof"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>groupby(key-selector lambda)</entry>
						<entry>
							<para>
								Groups the elements according to a specified key-selector expression.
							</para>
							<para>
								<xref linkend="enumeration-method-groupby"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>groupby(key-selector lambda, value-selector lambda)</entry>
						<entry>
							<para>
								Groups the elements according to a key-selector expression mapping each element to a value according to a value-selector.
							</para>
							<para>
								<xref linkend="enumeration-method-groupby"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>intersect(source)</entry>
						<entry>
							<para>
								Produces the set intersection of the two collections.
							</para>
							<para>
								<xref linkend="enumeration-method-intersect"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>lastof()</entry>
						<entry>
							<para>
								Returns the last element.
							</para>
							<para>
								<xref linkend="enumeration-method-lastof"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>lastof(predicate lambda)</entry>
						<entry>
							<para>
								Returns the last element that satisfies a condition.
							</para>
							<para>
								<xref linkend="enumeration-method-lastof"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>leastFrequent()</entry>
						<entry>
							<para>
								Returns the least frequent value among a collection of values.
							</para>
							<para>
								<xref linkend="enumeration-method-leastfrequent"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>leastFrequent(transform lambda)</entry>
						<entry>
							<para>
								Returns the least frequent value returned by the transform expression when applied to each element.
							</para>
							<para>
								<xref linkend="enumeration-method-leastfrequent"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>max()</entry>
						<entry>
							<para>
								Returns the maximum value among a collection of elements.
							</para>
							<para>
								<xref linkend="enumeration-method-max"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>max(value-selector lambda)</entry>
						<entry>
							<para>
								Returns the maximum value returned by the value-selector expression when applied to each element.
							</para>
							<para>
								<xref linkend="enumeration-method-max"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>maxby(value-selector lambda)</entry>
						<entry>
							<para>
								Returns the element that provides the maximum value returned by the value-selector expression when applied to each element.
							</para>
							<para>
								<xref linkend="enumeration-method-maxby"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>min()</entry>
						<entry>
							<para>
								Returns the minimum value among a collection of elements.
							</para>
							<para>
								<xref linkend="enumeration-method-max"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>min(value-selector lambda)</entry>
						<entry>
							<para>
								Returns the minimum value returned by the value-selector expression when applied to each element.
							</para>
							<para>
								<xref linkend="enumeration-method-min"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>minby(value-selector lambda)</entry>
						<entry>
							<para>
								Returns the element that provides the minimum value returned by the value-selector expression when applied to each element..
							</para>
							<para>
								<xref linkend="enumeration-method-minby"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>mostFrequent()</entry>
						<entry>
							<para>
								Returns the most frequent value among a collection of values.
							</para>
							<para>
								<xref linkend="enumeration-method-mostfrequent"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>mostFrequent(transform lambda)</entry>
						<entry>
							<para>
								Returns the most frequent value returned by the transform expression when applied to each element.
							</para>
							<para>
								<xref linkend="enumeration-method-mostfrequent"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>orderBy()</entry>
						<entry>
							<para>
								Sorts the elements in ascending order.
							</para>
							<para>
								<xref linkend="enumeration-method-orderby"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>orderBy(key-selector lambda)</entry>
						<entry>
							<para>
								Sorts the elements in ascending order according to a key.
							</para>
							<para>
								<xref linkend="enumeration-method-orderby"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>orderByDesc()</entry>
						<entry>
							<para>
								Sorts the elements in descending order.
							</para>
							<para>
								<xref linkend="enumeration-method-orderby"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>orderByDesc(key-selector lambda)</entry>
						<entry>
							<para>
								Sorts the elements in descending order according to a key.
							</para>
							<para>
								<xref linkend="enumeration-method-orderby"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>reverse</entry>
						<entry>
							<para>
								Reverses the order of elements.
							</para>
							<para>
								<xref linkend="enumeration-method-reverse"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>selectFrom(transform lambda)</entry>
						<entry>
							<para>
								Transforms each element resulting in a collection of transformed elements.
							</para>
							<para>
								<xref linkend="enumeration-method-selectfrom"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>sequenceEqual(second)</entry>
						<entry>
							<para>
								Determines whether two collections are equal by comparing each element (<literal>equals</literal> semantics apply).
							</para>
							<para>
								<xref linkend="enumeration-method-sequenceequal"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>sumOf()</entry>
						<entry>
							<para>
								Computes the sum from a collection of numeric elements.
							</para>
							<para>
								<xref linkend="enumeration-method-sumof"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>sumOf(projection lambda)</entry>
						<entry>
							<para>
								Computes the sum by invoking a projection expression on each element.
							</para>
							<para>
								<xref linkend="enumeration-method-sumof"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>take(numElements)</entry>
						<entry>
							<para>
								Returns a specified number of contiguous elements from the start.
							</para>
							<para>
								<xref linkend="enumeration-method-take"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>takeLast(numElements)</entry>
						<entry>
							<para>
								Returns a specified number of contiguous elements from the end.
							</para>
							<para>
								<xref linkend="enumeration-method-takelast"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>takeWhile(predicate lambda)</entry>
						<entry>
							<para>
								Returns elements from the start as long as a specified condition is true.
							</para>
							<para>
								<xref linkend="enumeration-method-takewhile"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>takeWhile( (predicate, index) lambda)</entry>
						<entry>
							<para>
								Returns elements from the start as long as a specified condition is true, allowing each element's index to be used in the logic of the predicate expression.
							</para>
							<para>
								<xref linkend="enumeration-method-takewhile"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>takeWhileLast(predicate)</entry>
						<entry>
							<para>
								Returns elements from the end as long as a specified condition is true.
							</para>
							<para>
								<xref linkend="enumeration-method-takewhilelast"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>takeWhileLast( (predicate,index) lambda)</entry>
						<entry>
							<para>
								Returns elements from the end as long as a specified condition is true, allowing each element's index to be used in the logic of the predicate expression.
							</para>
							<para>
								<xref linkend="enumeration-method-takewhilelast"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>toMap(key-selector lambda, value-selector lambda)</entry>
						<entry>
							<para>
								Returns a Map according to specified key selector and value-selector expressions.
							</para>
							<para>
								<xref linkend="enumeration-method-tomap"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>union(source)</entry>
						<entry>
							<para>
								Forms a union of the input elements with source elements.
							</para>
							<para>
								<xref linkend="enumeration-method-union"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>where(predicate lambda)</entry>
						<entry>
							<para>
								Filters elements based on a predicate.
							</para>
							<para>
								<xref linkend="enumeration-method-where"/>.
							</para>
						</entry>
					</row>
					<row>
						<entry>where( (predicate,index) lambda)</entry>
						<entry>
							<para>
								Filters elements based on a predicate, allowing each element's index to be used in the logic of the predicate expression.
							</para>
							<para>
								<xref linkend="enumeration-method-where"/>.
							</para>
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>		
	</sect1>
		
	<sect1 id="enumeration-exampledata">
		<title>Example Events</title>
		<para>
			The examples in this section come out of the domain of location report (aka. RFID, asset tracking etc.) processing: 
		</para>
		
		<orderedlist spacing="compact">
			<listitem>
				<para>
					The <literal>Item</literal> event is a report of the location of a certain item. An item can be either a piece of luggage or a passenger. 
				</para>
			</listitem>
			<listitem>
				<para>
					The <literal>LocationReport</literal> event contains a list of <literal>Item</literal> items for which it reports location. 
				</para>
			</listitem>
			<listitem>
				<para>
					The <literal>Zone</literal> event describes areas that items may move through.
				</para>
			</listitem>
		</orderedlist>

		<para>
			The examples use example single-row functions for computing the distance (<literal>distance</literal>) and for determining if a location falls within a rectangle (<literal>inrect</literal>) that are not provided by the EPL language. These example UDF functions are not enumeration methods
			and are used in EPL statements to provide a sensible example.
		</para>

		<para>
			The <literal>Item</literal> event contains an <literal>assetId</literal> id, a (x,y) <literal>location</literal>, a <literal>luggage</literal> flag to indicate whether the item represents a luggage (true) or passenger (false), and the <literal>assetIdPassenger</literal> that holds the asset id of the associated passenger when the item is a piece of luggage.
		</para>

		<para>
			The <literal>Item</literal> event is defined as follows (access methods not shown for brevity):
		</para>
		<programlisting><![CDATA[public class Item {
  String assetId;             // passenger or luggage asset id
  Location location;          // (x,y) location
  boolean luggage;            // true if this item is a luggage piece
  String assetIdPassenger;    // if the item is luggage, contains passenger associated
...]]></programlisting>

		<para>
			The <literal>LocationReport</literal> event contains a list of <literal>Item</literal> items for which it reports events.
		</para>
		<para>
			The <literal>LocationReport</literal> event is defined as follows:
		</para>
		<programlisting><![CDATA[public class LocationReport {
  List<Item> items;
...]]></programlisting>

		<para>
			The <literal>Zone</literal> event contains a zone <literal>name</literal> and (x1, y1, x2, y2) <literal>rectangle</literal>.
		</para>
		<para>
			The <literal>Zone</literal> event is defined as follows:
		</para>
		<programlisting><![CDATA[public class Zone {
  String name;
  Rectangle rectangle;
...]]></programlisting>

		<para>
			The <literal>Location</literal> object is a nested object to <literal>Item</literal> and provides the current (x,y) location:
		</para>
		<programlisting><![CDATA[public class Location {
  int x;
  int y;
...]]></programlisting>

		<para>
			The <literal>Rectangle</literal> object is a nested object to <literal>Zone</literal> and provides a zone rectangle(x1,y1,x2,y2):
		</para>
		<programlisting><![CDATA[public class Rectangle {
  int x1;
  int y1;
  int x2;
  int y2;
...]]></programlisting>
	</sect1>

	<sect1 id="enumeration-howtouse">
		<title>How to Use</title>
		
		<sect2 id="enumeration-howtouse-synopsis">
			<title>Syntax</title>

			<para>
				The syntax for enumeration methods is the same syntax as for any chained invocation:
			</para>
			<synopsis><emphasis>input_coll</emphasis>.<emphasis>enum_method_name</emphasis>( [<emphasis>method_parameter</emphasis> [, <emphasis>method_parameter</emphasis> [,...]]])
	  .[ [<emphasis>enum_method_name</emphasis>(...) [...]] | <emphasis>property_name</emphasis>] </synopsis>
	
			<para>
				Following the <emphasis>input_coll</emphasis> input collection (options outlined below), is the <literal>.</literal> (dot) operator and the <emphasis>enum_method_name</emphasis> enumeration method name. It follows in parenthesis a comma-separated list of method parameter expressions. Additional enumeration methods can be chained thereafter. An event property name can follow for those enumeration methods returning an event-typed (non-scalar) element.
			</para>
			
			<para>
				If the method parameter is a lambda expression with a single lambda-parameter, specify the lambda-parameter name followed by the <literal>=&gt;</literal> lambda operator and followed by the expression. The synopsis for use with a single lambda-parameter is:
			</para>
			<synopsis>method_parameter: <emphasis>lamda_param</emphasis> =&gt; <emphasis>lamda_expression</emphasis></synopsis>
	
			<para>
				If the method parameter is a lambda expression with two or more lambda-parameters, specify the lambda parameter names in parenthesis followed by the => lambda operator followed by the expression. The synopsis for use with multiple lambda-parameters is:
			</para>
			<synopsis>method_parameter: (<emphasis>lamda_param</emphasis> [,<emphasis>lamda_param</emphasis> [,...]]) => <emphasis>lamda_expression</emphasis></synopsis>
		
			<para>
				Generally for lambda expressions, the engine applies the lambda expression to each element in the input collection. The expression yields a result that, depending on the particular enumeration method, is used for aggregation, as a filter or for output, for example.
			</para>
		</sect2>
	
		<sect2 id="enumeration-howtouse-example">
			<title>Introductory Examples</title>

			<para>
				Let's look at an EPL statement that employs the <literal>where</literal> enumeration method and a lambda expression. This example returns items that have a (x, y) location of (0, 0):
			</para>
			<programlisting><![CDATA[select items.where(i => i.location.x = 0 and i.location.y = 0) as zeroloc
from LocationReport]]></programlisting>
	
			<para>
				As enumeration methods can be chained, this selection is equivalent:
			</para>
			<programlisting><![CDATA[select items.where(i => i.location.x = 0).where(i => i.location.y = 0) as zeroloc
from LocationReport]]></programlisting>
	
			<para>
				According to above statement the engine outputs in field <literal>zeroloc</literal> a collection of <literal>Item</literal> objects matching the condition. 
			</para>
			
			<para>
				The <literal>where</literal> enumeration method has a second version that has two lambda-parameters. The second parameter is the name of the index property which represents the current index of the element within the collection.
			</para>
			
			<para>
				This sample query returns a collection that consists of the first 3 items. This sample query does not use the <literal>item</literal> lambda parameter:
			</para>
			<programlisting><![CDATA[select items.where( (item, indexElement) => indexElement < 3) as firstThreeItems
from LocationReport]]></programlisting>

		</sect2>
	
		<sect2 id="enumeration-howtouse-output">
			<title>Input, Output and Limitations</title>

			<para>
				It is not necessary to use classes for event representation. The example above applies the same to Map or XML underlying events.
			</para>		
			
			<para>
			   For most enumeration methods the input can be any collection of events, scalar values or objects. For some enumeration methods limitations apply that are documented below. For example, the <literal>sumOf</literal> enumeration method requires a collection of numeric scalar values if used without parameters.
			   If the input to <literal>sumOf</literal> is a collection of events the enumeration method requires a lambda expression as parameter that yields the numeric value to use to compute the sum.
			</para>
	
			<para>
				Many examples of this section operate on the collection returned by the event property <literal>items</literal> in the <literal>LocationReport</literal> event class. 
				There are many other inputs yielding collections as listed below. Most examples herein use an event property as a input simply because the example can thus be brief and does not need to refer to a subquery or named window or other concept.
			</para>
			
			<para>
				For enumeration methods that return a collection, for example <literal>where</literal> and <literal>orderBy</literal>, the engine outputs an implementation of the <literal>Collection</literal> interface that contains the selected value(s). The collection returned must be considered read-only. As Java does not allow resettable iterators, the <literal>Collection</literal> interface allows more flexibility to query size and navigate among collection elements. We recommend against down-casting a collection returned by the engine to a more specific subclass of the <literal>Collection</literal> interface.
			</para>
			
			<para>
				For enumeration methods that return an element, for example <literal>firstOf</literal>, <literal>lastOf</literal>, <literal>minBy</literal> and <literal>maxBy</literal> the engine outputs the scalar value or the underlying event if operating on events. You may add an event property name after the enumeration method to return a property value.
			</para>
			
			<para>
				Enumeration methods generally retain the order of elements provided by the collection.
			</para>

			<para>
				The following restrictions apply to enumeration methods:
			</para>
		
			<orderedlist spacing="compact">
				<listitem>
					<para>
						Enumeration methods returning a collection return a read-only implementation of the <literal>Collection</literal> interface. You may not use any of the write-methods such as <literal>add</literal> or <literal>remove</literal> on a result collection.
					</para>
				</listitem>
			</orderedlist>
		</sect2>
		
	</sect1>

	<sect1 id="enumeration-inputs">
		<title>Inputs</title>
		
		<para>
			The input of data for built-in enumeration methods is a collection of scalar values, events or other objects. Input can originate from any of the following:
		</para>
		
		<orderedlist spacing="compact">
			<listitem>
				<para>
					A subquery.
				</para>
			</listitem>
			<listitem>
				<para>
					A named window.
				</para>
			</listitem>
			<listitem>
				<para>
					A property of an event that is itself a collection of events or classes, i.e. an indexed property.
				</para>
			</listitem>
			<listitem>
				<para>
					Any of the data window aggregation functions (<literal>window</literal>, <literal>first</literal>, <literal>last</literal>).
				</para>
			</listitem>
			<listitem>
				<para>
					The special <literal>prevwindow</literal>, <literal>prev</literal> and <literal>prevtail</literal> single-row functions.
				</para>
			</listitem>
			<listitem>
				<para>
					A plug-in single-row function or user-defined function.
				</para>
			</listitem>
			<listitem>
				<para>
					A declared expression.
				</para>
			</listitem>
			<listitem>
				<para>
					Another enumeration method that returns a collection.
				</para>
			</listitem>
			<listitem>
				<para>
					An array returned by the <literal>{}</literal> array operator.
				</para>
			</listitem>
		</orderedlist>
		
		<sect2 id="enumeration-ds-subquery">
			<title>Subquery Results</title>
			
			<para>
				Subqueries can return the rows of another stream's data window or rows from a named window. By providing a where-clause the rows returned by a subquery can be correlated to data provided by stream(s) in the from-clause. See <xref linkend="epl-subqueries"/>.
			</para>
			
			<para>
				A subquery that selects <literal>(*)</literal> wildcard provides a collection of events as input. A subquery that selects a single value expression provides a collection of scalar values as input. Subqueries that selects multiple value expressions are not allowed as input to enumeration methods.
			</para>

			<para>
				The following example uses a subquery to retrieve all zones for each location report item where the location falls within the rectangle of the zone. Please see a description of example events and functions above.
			</para>
			<programlisting><![CDATA[select assetId,
  (select * from Zone.std:unique(name)).where(z => inrect(z.rectangle, location)) as zones
from Item]]></programlisting>

			<para>
				You may place the subquery in an expression declaration to reuse the subquery in multiple places of the same EPL statement.
			</para>
			
			<para>
				This sample EPL declares the same query as above in an expression declaration:
			</para>
			<programlisting><![CDATA[expression myquery {itm =>
  (select * from Zone.std:unique(name)).where(z => inrect(z.rectangle, itm.location))
}
select assetId, myquery(item) as subq, 
    myquery(item).where(z => z.zone = 'Z01') as assetItem
from Item as item]]></programlisting>

			<para>
				The above query also demonstrates how an enumeration method, in the example the <literal>where</literal>-method, can be run across the results returned by a subquery in an expression declaration.
			</para>
			
			<para>
				Place a single column in the subquery select-clause to provide a collection of scalar values as input.
			</para>
			
			<para>
				The next example selects all names of zones and orders the names returning an order collection of string names every 30 seconds:
			</para>
			<programlisting><![CDATA[select (select name from Zone.std:unique(name)).orderBy() as orderedZones
from pattern[every timer:interval(30)]]]></programlisting>

			<para>
				Note that the engine can cache intermediate results thereby is not forced to re-evaluate the subquery for each occurrence in the <literal>select</literal>-clause.
			</para>
		</sect2>

		<sect2 id="enumeration-ds-namedwindow">
			<title>Named Window</title>
			
			<para>
				Named windows are globally-visible data windows. See <xref linkend="named_overview"/>.
			</para>
			
			<para>
				You may specify the named window name as input for an enumeration method and can optionally provide a correlation where-clause. The syntax is equivalent to a sub-query against a named window but much shorter.
			</para>

			<para>
				Synopsis:
			</para>
			<synopsis><emphasis>named-window-name</emphasis>[(<emphasis>correlation-expression</emphasis>)].<emphasis>enum-method-name</emphasis>(...)</synopsis>
			
			<para>
				When selecting all events in a named window you do not need the <emphasis>correlation-expression</emphasis>. To select a subset of data in the named window, specify a <emphasis>correlation-expression</emphasis>.
				From the perspective of best runtime performance, a correlation expression is preferred to reduce the number of rows returned.
			</para>
			
			<para>
				The following example first declares a named window to hold the last zone event per zone name:
			</para>
			<programlisting><![CDATA[create window ZoneWindow.std:unique(name) as Zone]]></programlisting>

			<para>
				Then we create a statement to insert zone events that arrive to the named window:
			</para>
			<programlisting><![CDATA[insert into ZoneWindow select * from Zone]]></programlisting>
			
			<para>
				Finally this statement queries the named window to retrieve all zones for each location report item where the location falls within the rectangle of the zone:
			</para>
			<programlisting><![CDATA[select ZoneWindow.where(z => inrect(z.rectangle, location)) as zones from Item]]></programlisting>

			<para>
				If you have a filter or correlation expression, append the expression to the named window name and place in parenthesis.
			</para>
			
			<para>
				This slightly modified query is the example above except that it adds a filter expression such that only zones with name Z1, Z2 or Z3 are considered:
			</para>
			<programlisting><![CDATA[select ZoneWindow(name in ('Z1', 'Z2', 'Z3')).where(z => inrect(z.rectangle, location)) as zones 
from Item]]></programlisting>

			<para>
				You may prefix property names provided by the named window with the name to disambiguate property names.
			</para>

			<para>
				This sample query prefixed the <literal>name</literal> property and returns the count of matching zones:
			</para>
			<programlisting><![CDATA[select ZoneWindow(ZoneWindow.name in ('Z1', 'Z2', 'Z3')).countof()) as zoneCount
from Item]]></programlisting>

			<para>
				The engine internally interprets the shortcut syntax and creates a subquery from it. Thus all indexing and query planning for subqueries against named windows apply here as well.
			</para>
		</sect2>

		<sect2 id="enumeration-ds-property">
			<title>Event Property</title>
			
			<para>
				Indexed event properties are event properties that are a collection, array or iterable of scalar values or objects. 
			</para>
			
			<para>
				The <literal>LocationReport</literal> event from the example contains a list of <literal>Item</literal> events. Any indexed property (list, array, collection, iterable) is eligible for use as input  to an enumeration method. If the indexed property contains non-scalar objects the objects are treated as events and can be used as input to enumeration methods as a collection of events.
			</para>
			
			<para>
			   The next sample query returns items that are less then 20 units away from the center, taking the <literal>items</literal> event property provided by each <literal>LocationReport</literal> event as input:
			</para>
			<programlisting><![CDATA[select items.where(p => distance(0, 0, p.location.x, p.location.y) < 20) as centeritems
from LocationReport]]></programlisting>			

			<para>
			   The following example consists of two statements: The first statement declares an a new event type and the second statement invokes the <literal>sequenceEqual</literal> method to compare sequences contained in two properties of the same event:
			</para>
			<programlisting><![CDATA[create schema MyEvent (seqone String[], seqtwo String[])]]></programlisting>			
			<programlisting><![CDATA[select seqone.sequenceEqual(seqtwo) from MyEvent]]></programlisting>			
		</sect2>

		<sect2 id="enumeration-ds-accessagg">
			<title>Data Window Aggregation</title>
			
			<para>
				Data window aggregation functions return events present in a stream's current data window. They are aggregation functions and as such sensitive to the presence of <literal>group by</literal>. See <xref linkend="epl-function-aggregation-dwtrack"/>.
			</para>
			
			<para>
				When using data window aggregation functions as input to a built-in enumeration method you can specify the <literal>*</literal> wildcard to provide a collection of events as input. Or you can specify a property name in the data window aggregation function to provide a collection of scala values as input. Use any of the <literal>window</literal>, <literal>first</literal> or <literal>last</literal> functions.
			</para>
			
			<para>
				In this example query the <literal>window(*)</literal> aggregation function returns the last 10 seconds of item location reports for the same asset id as the incoming event. Among that last 10 seconds of events for the same asset id, the 
				enumeration method returns those item location reports where the distance to center is less then 20, for each arriving Item event.
			</para>
			
			<para>
				Sample query:
			</para>
			<programlisting><![CDATA[select window(*).where(p => distance(0, 0, p.location.x, p.location.y) < 20) as centeritems
from Item(type='P').win:time(10) group by assetId]]></programlisting>
			
			<para>
				The next sample query instead selects the asset id property of all events and returns an ordered collection:
			</para>
			<programlisting><![CDATA[select window(assetId).orderBy() as orderedAssetIds
from Item.win:time(10) group by assetId]]></programlisting>

		</sect2>

		<sect2 id="enumeration-ds-prev">
			<title><literal>prev</literal>, <literal>prevwindow</literal> and <literal>prevtail</literal> Single-Row Functions as Input</title>
			
			<para>
				The <literal>prev</literal>, <literal>prevwindow</literal> and <literal>prevtail</literal> single-row functions allow access into a stream's data window however are not aggregation functions and and as such not sensitive to the presence of <literal>group by</literal>. See <xref linkend="epl-single-row-function-ref-previouswindow"/>.
			</para>
			
			<para>
				When using any of the <literal>prev</literal> single-row functions as input to a built-in enumeration method you can specify the stream name as a parameter to the function or an event property. The input to the enumeration method is a collection of events if you specify the stream name, or a collection of scalar value if you specify an event property.
			</para>
			
			<para>
				In this example query the <literal>prevwindow(stream)</literal> single-row function returns the last 10 seconds of item location reports, among which the 
				enumeration method filters those item location reports where the distance to center is less then 20, for each Item event that arrived in the last 10 seconds considering passenger-type Item events only (see filter type = 'P').
			</para>
			
			<para>
				Sample query:
			</para>
			<programlisting><![CDATA[select prevwindow(items)
    .where(p => distance(0, 0, p.location.x, p.location.y) < 20) as centeritems
from Item(type='P').win:time(10) as items]]></programlisting>

			<para>
				This sample query demonstrates the use of the <literal>prevwindow</literal> function to return a collection of scalar values (collection of asset id) as input to <literal>orderby</literal>:
			</para>
			<programlisting><![CDATA[select prevwindow(assetId).orderBy() as orderedAssetIds
from Item.win:time(10) as items]]></programlisting>
		</sect2>
                
		<sect2 id="enumeration-ds-udf">
			<title>Single-Row Function or UDF</title>
			
			<para>
				Your single-row or user-defined function can return either an array or any collection that implements either the <literal>Collection</literal> or <literal>Iterable</literal> interface. For arrays, the array component type and for collections, the collection or iterable generic type should be the class providing event properties.
			</para>

			<para>
				As an example, assume a <literal>ZoneFactory</literal> class exists and a static method <literal>getZones()</literal> returns a list of zones to filter items, for example:
			</para>
			<programlisting><![CDATA[public class ZoneFactory {
  public static Iterable<Zone> getZones() {
    List<Zone> zones = new ArrayList<Zone>();
    zones.add(new Zone("Z1", new Rectangle(0, 0, 20, 20)));
    return zones;
  }
}]]></programlisting>
    
			<para>
				Import the class through runtime or static configuration, or add the method above as a plug-in single-row function.
			</para>
			
			<para>
				The following query returns for each Item event all zones that the item belongs to:
			</para>
			<programlisting><![CDATA[select ZoneFactory.getZones().where(z => inrect(z.rectangle, item.location)) as zones
from Item as item]]></programlisting>
					
			<para>
				If the class and method were registered as a plug-in single-row function, you can leave the class name off, for example:
			</para>
			<programlisting><![CDATA[select getZones().where(z => inrect(z.rectangle, item.location)) as zones
from Item as item]]></programlisting>			

			<para>
				Your single-row or user-defined function can also return an array, collection or iterable or scalar values.
			</para>

			<para>
				For example, the static method <literal>getZoneNames()</literal> returns a list of zone names:
			</para>
			<programlisting><![CDATA[public static String[] getZoneNames() { 
  return new String[] { "Z1", "Z2"};
}]]></programlisting>

			<para>
				The following query returns zone names every 30 seconds and excludes zone Z1:
			</para>
			<programlisting><![CDATA[select getZoneNames().where(z => z != "Z1")
from pattern[every timer:interval(30)]]]></programlisting>			
		</sect2>

		<sect2 id="enumeration-ds-lambda">
			<title>Declared Expression</title>
			
			<para>
				A declared expression may return input data for an enumeration method.
			</para>

			<para>
				The below query declares an expression that returns all passenger location reports among the items in the location report event in a column named <literal>passengerCollection</literal>. The query uses the result returned by the declared expression
				a second time to filter through the list returning the passenger location report where the asset id is a given value in a column named <literal>passengerP01</literal>.
			</para>

			<para>
				Sample query:
			</para>
			<programlisting><![CDATA[expression passengers {
  lr => lr.items.where(l => l.type='P')
}
select passengers(lr) as passengerCollection,
  passengers(lr).where(x => assetId = 'P01') as passengerP01
from LocationReport lr]]></programlisting>	

			<para>
				The engine applies caching techniques to avoid re-evaluating the declared expression multiple times.
			</para>
		</sect2>
	</sect1>

	<sect1 id="enumeration-example">
		<title>Example</title>
		
		<para>
			Following the RFID asset tracking example as introduced earlier, this section introduces two use cases solved by enumeration methods.
		</para>
		
		<para>
			The first use case requires us to find any luggage that is more then 20 units away from the passenger that the luggage belongs to.
			The declared expression <literal>lostLuggage</literal> solves this question.
		</para>
		
		<para>
			The second question to answer is: For each of such lost luggage what single other passenger is nearest to that luggage.
			The declared expression <literal>nearestOwner</literal> which uses <literal>lostLuggage</literal> answers this question.
		</para>
		
		<para>
			Below is the complete EPL statement (one statement not multiple):
		</para>

		<programlisting><![CDATA[// expression to return a collection of lost luggage
expression lostLuggage {
  lr => lr.items.where(l => l.type='L' and
    lr.items.some(p => p.type='P' and p.assetId=l.assetIdPassenger 
      and LRUtil.distance(l.location.x, l.location.y, p.location.x, p.location.y) > 20))
}

// expression to return all passengers
expression passengers {
  lr => lr.items.where(l => l.type='P')
}

// expression to find the nearest owner
expression nearestOwner {
  lr => lostLuggage(lr).toMap(key => key.assetId,
    value => passengers(lr).minBy(
        p => LRUtil.distance(value.location.x, value.location.y, p.location.x, p.location.y))
    )
}

select lostLuggage(lr) as val1, nearestOwner(lr) as val2 from LocationReport lr]]></programlisting>			
	</sect1>

	<sect1 id="enumeration-method">
		<title>Reference</title>
		
		<sect2 id="enumeration-method-aggregate">
			<title>Aggregate</title>

			<para>
				The <literal>aggregate</literal> enumeration method takes an expression providing the initialization value (seed) and an accumulator lambda expression. The return value is the final accumulator value. 
			</para>
			
			<para>
				Via the <literal>aggregate</literal> method you may perform a calculation over elements. The method initializes the aggregated value by evaluating the expression provided in the first parameter. The method then calls the lambda expression of the second parameter once for each element in the input. The lambda expression receives the last aggregated value and the element from the input. The result of the expression replaces the previous aggregated value and returns the final result after completing all elements.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.aggregate(0, (result, value) => result + value)  // Returns 6</programlisting>

			<para>
				The example below aggregates price of each OrderEvent in the last 10 seconds computing a total price:
			</para>
			<programlisting>// Initialization value is zero.
// Aggregate by adding up the price.
select window(*).aggregate(0, (result, order) => result + order.price) as totalPrice
from OrderEvent.win:time(10)</programlisting>

			<para>
				In the query above, the initialization value is zero, <literal>result</literal> is used for the last aggregated value and <literal>order</literal> denotes the element that the expression adds the value of the price property.
			</para>

			<para>
				This example aggregation builds a comma-separated list of all asset ids of all items:
			</para>
			<programlisting>select items.aggregate('', 
  (result, item) => result || (case when result='' then '' else ',' end) || item.assetId) as assets			
from LocationReport</programlisting>

			<para>
				In above query, the empty string <literal>''</literal> represents the initialization value. The name <literal>result</literal> is used for the last aggregated value and the name <literal>item</literal> is used to denote the element.
			</para>

			<para>
				The type value returned by the initialization expression must match to the type of value returned by the accumulator lambda expression. 
			</para>

			<para>
				If the input is null the method returns null. If the input is empty the method returns the initialization value.
			</para>
		</sect2>

		<sect2 id="enumeration-method-allof">
			<title>AllOf</title>

			<para>
				The <literal>allof</literal> enumeration method determines whether all elements satisfy the predicate condition.
			</para>
			
			<para>
				The method takes a single parameter: The predicate lambda expression that must yield a Boolean result. The enumeration method applies the lambda expression to each element and if the expression returns true for all elements, the method returns true.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.allOf(v => v > 0)    // Returns true as all values are > 0
{1, 2, 3}.allOf(v => v > 1)    // Returns false</programlisting>

			<para>
				The EPL statement below returns true when all items are within 1000 unit distance of center:
			</para>
			<programlisting>select items.allof(i => distance(i.location.x, i.location.y, 0, 0) &lt; 1000) as centered			
from LocationReport</programlisting>

			<para>
				If the input is null the method returns null. If the input is empty the method returns true.
			</para>
		</sect2>

		<sect2 id="enumeration-method-anyof">
			<title>AnyOf</title>

			<para>
				The <literal>anyof</literal> enumeration method determines whether any element satisfies the predicate condition.
			</para>
			
			<para>
				The only parameter is the predicate lambda expression that must yield a Boolean result. The enumeration method applies the lambda expression to each element and if the expression returns true for all elements, the method returns true.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.anyOf(v => v > 0)    // Returns true
{1, 2, 3}.anyOf(v => v > 1)    // Returns true
{1, 2, 3}.anyOf(v => v > 3)    // Returns false</programlisting>

			<para>
				The EPL statement below return true when any of the items are within 10 unit distance of center:
			</para>
			<programlisting>select items.anyof(i => distance(i.location.x, i.location.y, 0, 0) &lt; 10) as centered			
from LocationReport</programlisting>

			<para>
				If the input is null the method returns null. If the input is empty the method returns false.
			</para>
		</sect2>

		<sect2 id="enumeration-method-average">
			<title>Average</title>

			<para>
				The <literal>average</literal> enumeration method computes the average of scalar values. If passing a projection lambda expression the method computes the average obtained by invoking the projection lambda expression on each element.
			</para>
			
			<para>
				The method takes a projection lambda expression yielding a numeric value as a parameter. It applies the lambda expression to each element and computes the average of the result, returning a Double value. A BigDecimal is returned for expressions returning BigInteger or BigDecimal.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.average()    // Returns 2</programlisting>

			<para>
				The EPL statement as shown next computes the average distance from center among all items in the location report event:
			</para>
			<programlisting>select items.average(i => distance(i.location.x, i.location.y, 0, 0)) as avgdistance
from LocationReport</programlisting>

			<para>
				If the input is null the method returns null. If the input is empty the method returns double zero or BigDecimal zero.
			</para>
		</sect2>

		<sect2 id="enumeration-method-countof">
			<title>CountOf</title>

			<para>
				The <literal>countof</literal> enumeration method returns the number of elements, or the number of elements that satisfy a condition.
			</para>
			
			<para>
				The enumeration method has two versions: The first version takes no parameters and computes the number of elements. The second version takes a predicate lambda expression that must yield Boolean true or false, and computes the number of elements that satisfy the condition.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.countOf()    // Returns 3
{1, 2, 3}.countOf(v => v &lt; 2)    // Returns 1</programlisting>

			<para>
				The next sample statement counts the number of items:
			</para>
			<programlisting>select items.countOf() as cnt from LocationReport</programlisting>

			<para>
				This example statement counts the number of items that have a distance to center that is less then 20 units:
			</para>
			<programlisting>select items.countOf(i => distance(i.location.x, i.location.y, 0, 0) &lt; 20) as cntcenter
from LocationReport</programlisting>

			<para>
				If the input is null the method returns null. If the input is empty the method returns integer zero.
			</para>
		</sect2>

		<sect2 id="enumeration-method-except">
			<title>Except</title>

			<para>
				The <literal>except</literal> enumeration method forms a set difference of the input elements with the elements that the parameter expression yields.
			</para>

			<para>
				The enumeration method takes a single parameter that must itself return a collection of events, objects or scalar values. The method returns the elements of the first collection that do not appear in the second collection.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.except({1})   // Returns {2, 3}</programlisting>

			<para>
				The following statement compares the items of the last location report against all items in the previous 10 location reports, and reports for each combination only those items in the current item report that are not also in the location report compared to:
			</para>
			<programlisting>select za.items.except(zb.items) as itemsCompared 
from LocationReport as za unidirectional, LocationReport.win:length(10) as zb</programlisting>
			
			<para>
				If the input is null the method returns null. For scalar values and objects equals-semantics apply.
			</para>
		</sect2>

		<sect2 id="enumeration-method-firstof">
			<title>FirstOf</title>

			<para>
				The <literal>firstOf</literal> enumeration method returns the first element or the first element that satisfies a condition.
			</para>
			
			<para>
				The method has two versions: The first version takes no parameters and returns the first element. The second version takes a predicate lambda expression yielding true or false. It applies the lambda expression to each element and returns the first element for which the expression returns true. The return type is the element itself and not a collection. You may append a property name to return the property value for the first element.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.firstOf()   // Returns 1
{1, 2, 3}.firstOf(v => v / 2 > 1)   // Returns 3</programlisting>

			<para>
				In the following EPL sample the query returns the first item that has a distance to center that is less then 20 units:
			</para>
			<programlisting>select items.firstof(i =&gt; distance(i.location.x, i.location.y, 0, 0) &lt; 20) as firstcenter
from LocationReport</programlisting>

			<para>
				The next sample EPL returns the first item's asset id:
			</para>
			<programlisting>select items.firstof().assetId as firstAssetId from LocationReport</programlisting>

			<para>
				If the input is null, empty or if none of the elements match the condition the method returns null.
			</para>
		</sect2>

		<sect2 id="enumeration-method-groupby">
			<title>GroupBy</title>

			<para>
				The <literal>groupby</literal> enumeration method groups the elements according to a specified key-selector lambda expression. There are two version of the <literal>groupby</literal> method.
			</para>
			
			<para>
				The first version of the method takes a key-selector lambda expression and returns a Map of key with each value a list of objects, one for each distinct key that was encountered. The result is a <literal>Map&lt;Object, Collection&lt;Object&gt;&gt;</literal> wherein object is the event underlying object.
			</para>

			<para>
				The second version of the method takes a key-selector lambda expression and value-selector lambda expression and returns a Map of key with each value a list of values, one for each distinct key that was encountered. The result is a <literal>Map&lt;Object, Collection&lt;Object&gt;&gt;</literal> wherein object is the result of applying the value-selector expression.
			</para>

			<para>
				The next query filters out all luggage items using a <literal>where</literal> method and then groups by the luggage's passenger asset id. It returns a map of
				passenger asset id and the collection of luggage items for each passenger:
			</para>
			<programlisting>select items.where(type='L').groupby(i => assetIdPassenger) as luggagePerPerson
from LocationReport</programlisting>

			<para>
				The query shown below generates a map of item asset id and distance to center:
			</para>
			<programlisting>select items.groupby(
    k => assetId, v => distance(v.location.x, v.location.y, 0, 0)) as distancePerItem
from LocationReport</programlisting>

			<para>
				If the input is null the method returns null. Null values as key and value are allowed.
			</para>
		</sect2>

		<sect2 id="enumeration-method-intersect">
			<title>Intersect</title>

			<para>
				The <literal>intersect</literal> enumeration method forms a set intersection of the input elements with the elements that the parameter expression yields.
			</para>

			<para>
				The enumeration method takes a single parameter that must itself return a collection of events, objects or scalar values. The method returns the elements of the first collection that also appear in the second collection.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.intersect({2, 3})   // Returns {2, 3}</programlisting>

			<para>
				The following statement compares the items of the last location report against all items in the previous 10 location reports, and reports for each combination all items in the current item report that also occur in the other location report:
			</para>
			<programlisting>select za.items.intersect(zb.items) as itemsCompared 
from LocationReport as za unidirectional, LocationReport.win:length(10) as zb</programlisting>
			
			<para>
				If the input is null the method returns null. For scalar values and objects equals-semantics apply.
			</para>
		</sect2>

		<sect2 id="enumeration-method-lastof">
			<title>LastOf</title>

			<para>
				The <literal>lastOf</literal> enumeration method returns the last element or the last element that satisfies a condition.
			</para>
			
			<para>
				The method has two versions: The first version takes no parameters and returns the last element. The second version takes a predicate lambda expression yielding true or false. It applies the lambda expression to each element and returns the last element for which the expression returns true. The return type is the element itself and not a collection. You may append a property name to return the property value for the last element.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.lastOf()   // Returns 3
{1, 2, 3}.lastOf(v => v &lt; 3)   // Returns 2</programlisting>

			<para>
				In the following EPL sample the query returns the last item that has a distance to center that is less then 20 units:
			</para>
			<programlisting>select items.lastof(i =&gt; distance(i.location.x, i.location.y, 0, 0) &lt; 20) as lastcenter 
from LocationReport</programlisting>

			<para>
				The next sample EPL returns the last item's asset id:
			</para>
			<programlisting>select items.lastof().assetId as lastAssetId from LocationReport</programlisting>

			<para>
				If the input is null, empty or if none of the elements match the condition the method returns null.
			</para>
		</sect2>

		<sect2 id="enumeration-method-leastfrequent">
			<title>LeastFrequent</title>

			<para>
				The <literal>leastFrequent</literal> enumeration method returns the least frequent value among a collection of values, or the least frequent value after applying a transform expression to each element.
			</para>

			<para>
				The method has two versions: The first version takes no parameters and returns the least frequent value. The second version takes a transform lambda expression yielding the value to count occurrences for. The method applies the lambda expression to each element and returns the expression result value with the least number of occurrences. The return type is the type of value in the collection or the type of value returned by the transform lambda expression if one was provided.
			</para>
			
			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3, 2, 1}.leastFrequent()   // Returns 3</programlisting>

			<para>
				The example EPL below returns the least frequent item type, counting the distinct item types among all items for the current LocationReport event:
			</para>
			<programlisting>select items.leastFrequent(i =&gt; type) as leastFreqType from LocationReport</programlisting>

			<para>
				If the input is null or empty the method returns null. The transform expression may also yield null. A null value can be returned as the most frequent value if the most frequent value is null. If multiple values have the same number of occurrences the method returns the first value with the least number of occurrences considering the ordering of the collection.
			</para>
		</sect2>

		<sect2 id="enumeration-method-max">
			<title>Max</title>

			<para>
				The <literal>max</literal> enumeration method returns the maximum value among a collection of values.
			</para>

			<para>
				If no value-selector lambda expression is provided, the method finds the maximum.
			</para>

			<para>
				If a value-selector lambda expression is provided, the enumeration method invokes a value-selector lambda expression on each element and returns the maximum value. The type of value returned follows the return type of the lambda expression that was provided as parameter.
			</para>
			
			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3, 2, 1}.max()   // Returns 3</programlisting>

			<para>
				The next query returns the maximum distance of any item from center:
			</para>
			<programlisting>select items.max(i =&gt; distance(i.location.x, i.location.y, 0, 0)) as maxcenter 
from LocationReport</programlisting>

			<para>
				The value-selector lambda expression must return a comparable type: Any primitive or boxed type or <literal>Comparable</literal> type is permitted.
			</para>

			<para>
				If the input is null, empty or if none of the elements when transformed return a non-null value the method returns null.
			</para>
		</sect2>

		<sect2 id="enumeration-method-maxby">
			<title>MaxBy</title>

			<para>
				The <literal>maxBy</literal> enumeration method returns the element that provides the maximum value returned by the value-selector lambda expression when applied to each element.
			</para>
			
			<para>
				The enumeration method returns the element itself. You may append an event property name to return a property value of the element.
			</para>

			<para>
				The next query returns the first item with the maximum distance to center:
			</para>
			<programlisting>select items.maxBy(i =&gt; distance(i.location.x, i.location.y, 0, 0)) as maxItemCenter 
from LocationReport</programlisting>

			<para>
				The next sample returns the type of the item with the largest asset id (string comparison) among all items:
			</para>
			<programlisting>select items.maxBy(i =&gt; assetId).type as minAssetId from LocationReport</programlisting>

			<para>
				The transform expression must return a comparable type: Any primitive or boxed type or <literal>Comparable</literal> type is permitted.
			</para>

			<para>
				If the input is null, empty or if none of the elements when transformed return a non-null value the method returns null.
			</para>
		</sect2>

		<sect2 id="enumeration-method-min">
			<title>Min</title>

			<para>
				The <literal>min</literal> enumeration method returns the minimum value among a collection of values.
			</para>

			<para>
				If no value-selector lambda expression is provided, the method finds the minimum.
			</para>

			<para>
				If a value-selector lambda expression is provided, the enumeration method invokes a value-selector lambda expression on each element and returns the minimum value. The type of value returned follows the return type of the lambda expression that was provided as parameter.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3, 2, 1}.min()   // Returns 1</programlisting>

			<para>
				The next query returns the minimum distance of any item to center:
			</para>
			<programlisting>select items.min(i =&gt; distance(i.location.x, i.location.y, 0, 0)) as mincenter 
from LocationReport</programlisting>

			<para>
				The transform expression must return a comparable type: Any primitive or boxed type or <literal>Comparable</literal> type is permitted.
			</para>

			<para>
				If the input is null, empty or if none of the elements when transformed return a non-null value the method returns null.
			</para>
		</sect2>

		<sect2 id="enumeration-method-minby">
			<title>MinBy</title>

			<para>
				The <literal>minBy</literal> enumeration method returns the element that provides the minimum value returned by the value-selector lambda expression when applied to each element.				
			</para>
			
			<para>
				The enumeration method returns the element itself. You may append an event property name to return a property value of the element.
			</para>

			<para>
				The next query returns the first item with the minimum distance to center:
			</para>
			<programlisting>select items.minBy(i =&gt; distance(i.location.x, i.location.y, 0, 0)) as minItemCenter 
from LocationReport</programlisting>

			<para>
				The next sample returns the type of the item with the smallest asset id (string comparison) among all items:
			</para>
			<programlisting>select items.minBy(i =&gt; assetId).type as minAssetId from LocationReport</programlisting>

			<para>
				The transform expression must return a comparable type: Any primitive or boxed or <literal>Comparable</literal> type is permitted.
			</para>

			<para>
				If the input is null, empty or if none of the elements when transformed return a non-null value the method returns null.
			</para>
		</sect2>

		<sect2 id="enumeration-method-mostfrequent">
			<title>MostFrequent</title>

			<para>
				The <literal>mostFrequent</literal> enumeration method returns the most frequent value among a collection of values, or the most frequent value after applying a transform expression to each element.
			</para>
			
			<para>
				The method has two versions: The first version takes no parameters and returns the most frequent value. The second version takes a transform lambda expression yielding the value to count occurrences for. The method applies the lambda expression to each element and returns the expression result value with the most number of occurrences. The return type is the type of value in the collection or the type of value returned by the transform lambda expression if one was provided.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3, 2, 1, 2}.mostFrequent()   // Returns 2</programlisting>

			<para>
				The example EPL below returns the least frequent item type, counting the distinct item types among all items for the current LocationReport event:
			</para>
			<programlisting>select items.leastFrequent(i =&gt; type) as leastFreqType from LocationReport</programlisting>

			<para>
				If the input is null or empty the method returns null. The transform expression may also yield null. A null value can be returned as the most frequent value if the most frequent value is null. If multiple values have the same number of occurrences the method returns the first value with the most number of occurrences considering the ordering of the collection.
			</para>
		</sect2>

		<sect2 id="enumeration-method-orderby">
			<title>OrderBy and OrderByDesc</title>

			<para>
				The <literal>orderBy</literal> enumeration method sorts elements in ascending order according to a key. The <literal>orderByDesc</literal> enumeration method sorts elements in descending order according to a key.
			</para>

			<para>
				The enumeration method takes a single key-selector lambda expression as parameter and orders elements according to the key yielded by the expression. For same-value keys, it maintains the existing order.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{2, 3, 2, 1}.orderBy()   // Returns {1, 2, 2, 3}</programlisting>

			<para>
				This example orders all items from a location report according to their distance from center:
			</para>
			<programlisting>select items.orderBy(i => distance(i.location.x, i.location.y, 0, 0)) as itemsNearFirst,
  items.orderByDesc(i => distance(i.location.x, i.location.y, 0, 0)) as itemsFarFirst
from LocationReport</programlisting>

			<para>
				The key-selector lambda expression must return a comparable type: Any primitive or boxed or <literal>Comparable</literal> type is permitted.
			</para>

			<para>
				If the input is null the method returns null. If the input is empty the method returns an empty collection.
			</para>
		</sect2>

		<sect2 id="enumeration-method-reverse">
			<title>Reverse</title>

			<para>
				The <literal>reverse</literal> enumeration method simply reverses the order of elements returning a collection.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{2, 3, 2, 1}.reverse()   // Returns {1, 2, 3, 2}</programlisting>

			<para>
				The following EPL reverses the items:
			</para>
			<programlisting>select items.reverse() as reversedItems from LocationReport</programlisting>

			<para>
				If the input is null the method returns null. If the input is empty the method returns an empty collection.
			</para>
		</sect2>

		<sect2 id="enumeration-method-selectfrom">
			<title>SelectFrom</title>

			<para>
				The <literal>selectFrom</literal> enumeration method transforms each element resulting in a collection of transformed elements.
			</para>

			<para>
				The enumeration method applies a transformation lambda expression to each element and returns the result of each transformation as a collection. Use the <literal>new</literal> operator to yield multiple values for each element, see <xref linkend="epl-operator-new"/>.
			</para>

			<para>
				The next EPL query returns a collection of asset ids:
			</para>
			<programlisting>select items.selectFrom(i => assetId) as itemAssetIds from LocationReport</programlisting>

			<para>
				This sample EPL query evaluates each item and returns the asset id as well as the distance from center for each item:
			</para>
			<programlisting>select items.selectFrom(i => 
  new {
    assetId, 
    distanceCenter = distance(i.location.x, i.location.y, 0, 0)
  } ) as itemInfo from LocationReport</programlisting>

			<para>
				If the input is null the method returns null. If the input is empty the method returns an empty collection.
			</para>
		</sect2>

		<sect2 id="enumeration-method-sequenceequal">
			<title>SequenceEqual</title>

			<para>
				The <literal>sequenceEqual</literal> enumeration method determines whether two collections are equal by comparing each element.
			</para>

			<para>
				The method enumerates the two source collections in parallel and compares corresponding elements by using the <literal>equals</literal> method to compare. The method takes a single parameter expression that must return a collection containing elements of the same type as the input. The method returns true if the two source sequences are of equal length and their corresponding elements are equal.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.sequenceEqual({1})   // Returns false
{1, 2, 3}.sequenceEqual({1, 2, 3})   // Returns true</programlisting>

			<para>
				The following example compares the asset id of all items to the asset ids returned by a method <literal>ItemUtil.redListed()</literal> which is assumed to return a list of asset id of string type:
			</para>
			<programlisting>select items.selectFrom(i => assetId).sequenceEquals(ItemUtil.redListed()) from LocationReport</programlisting>

			<para>
				If the input is null the method returns null.
			</para>
		</sect2>

		<sect2 id="enumeration-method-sumof">
			<title>SumOf</title>

			<para>
				The <literal>sumOf</literal> enumeration method computes the sum. If a projection lambda expression is provided, the method invokes the projection lambda expression on each element and computes the sum on each returned value.
			</para>
			
			<para>
				The projection lambda expression should yield a numeric value, BigDecimal or BigInteger value. Depending on the type returned by the projection lambda expression the method returns either Integer, Long, Double, BigDecimal or BigInteger.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.sumOf()   // Returns 6</programlisting>

			<para>
				The following example computes the sum of the distance of each item to center:
			</para>
			<programlisting>select items.sum(i => distance(i.location.x, i.location.y, 0, 0) as totalAllDistances
from LocationReport</programlisting>

			<para>
				If the input is null or empty the method returns null.
			</para>
		</sect2>

		<sect2 id="enumeration-method-take">
			<title>Take</title>

			<para>
				The <literal>take</literal> enumeration method returns a specified number of contiguous elements from the start.
			</para>
			
			<para>
				The enumeration method takes a single size (non-lambda) expression that returns an Integer value.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.take(2)   // Returns {1, 2}</programlisting>

			<para>
				The following example returns the first 5 items:
			</para>
			<programlisting>select items.take(5) as first5Items from LocationReport</programlisting>

			<para>
				If the input is null the method returns null. If the input is empty the method returns an empty collection.
			</para>
		</sect2>

		<sect2 id="enumeration-method-takelast">
			<title>TakeLast</title>

			<para>
				The <literal>takeLast</literal> enumeration method returns a specified number of contiguous elements from the end.
			</para>
			
			<para>
				The enumeration method takes a single size (non-lambda) expression that returns an Integer value.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.takeLast(2)   // Returns {2, 3}</programlisting>

			<para>
				The following example returns the last 5 items:
			</para>
			<programlisting>select items.takeLast(5) as last5Items from LocationReport</programlisting>

			<para>
				If the input is null the method returns null. If the input is empty the method returns an empty collection.
			</para>
		</sect2>

		<sect2 id="enumeration-method-takewhile">
			<title>TakeWhile</title>

			<para>
				The <literal>takeWhile</literal> enumeration method returns elements from the start as long as a specified condition is true.
			</para>

			<para>
				The enumeration method has two versions. The first version takes a predicate lambda expression and the second version takes a predicate lambda expression and index for use within the predicate expression. Both versions return elements from the start as long as the specified condition is true.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.takeWhile(v => v &lt; 3)   // Returns {1, 2}
{1, 2, 3}.takeWhile((v,ind) => ind &gt; 2)   // Returns {1, 2}
{1, 2, -1, 4, 5, 6}.takeWhile((v,ind) => ind &lt; 5 and v &gt; 0)  // Returns {1, 2} (Take while index&lt;5 amd value&gt;0)</programlisting>

			<para>
				This example selects all items from a location report in the order provided until the first item that has a distance to center greater then 20 units:
			</para>
			<programlisting>select items.takeWhile(i => distance(i.location.x, i.location.y, 0, 0) &lt; 20)
from LocationReport</programlisting>
				
			<para>
				The second version of the <literal>where</literal> represents the index of the input element starting at zero for the first element.
			</para>				
			
			<para>
				The next example is similar to the query above but also limits the result to the first 10 items:
			</para>
			<programlisting>select items.takeWhile((i, ind) => distance(i.location.x, i.location.y, 0, 0) &lt; 20) and ind &lt; 10)
from LocationReport</programlisting>

			<para>
				If the input is null the method returns null. If the input is empty the method returns an empty collection.
			</para>
		</sect2>

		<sect2 id="enumeration-method-takewhilelast">
			<title>TakeWhileLast</title>

			<para>
				The <literal>takeWhileLast</literal> enumeration method returns elements from the end as long as a specified condition is true.
			</para>

			<para>
				The enumeration method has two versions. The first version takes a predicate lambda expression and the second version takes a predicate lambda expression and index for use within the predicate expression. Both versions return elements from the end as long as the specified condition is true.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.takeWhileLast(v => v &lt; 3)   // Returns {} (empty collection)
{1, 2, 3}.takeWhileLast(v => v &gt; 1)   // Returns {2, 3}
{1, 2, 3}.takeWhileLast((v,ind) => ind &gt; 2)   // Returns {2, 3}
{1, 2, -1, 4, 5, 6}.takeWhileLast((v,ind) => ind &lt; 5 and v &gt; 0)  // Returns {4, 5, 6} (Take while index&lt;5 amd value&gt;0)</programlisting>

			<para>
				This example selects all items from a location report, starting from the last element and proceeding backwards, until the first item that has a distance to center greater then 20 units:
			</para>
			<programlisting>select items.takeWhile(i => distance(i.location.x, i.location.y, 0, 0) &lt; 20)
from LocationReport</programlisting>
				
			<para>
				The second version provides the index of the input element starting at zero for the last element (reverse index).
			</para>				
			
			<para>
				The next example is similar to the query above but also limits the result to the last 10 items:
			</para>
			<programlisting>select items.takeWhile((i, ind) => distance(i.location.x, i.location.y, 0, 0) &lt; 20) and ind &lt; 10)
from LocationReport</programlisting>

			<para>
				If the input is null the method returns null. If the input is empty the method returns an empty collection.
			</para>
		</sect2>

		<sect2 id="enumeration-method-tomap">
			<title>ToMap</title>

			<para>
				The <literal>toMap</literal> enumeration method returns a Map according to specified key-selector lambda expression and value-selector lambda expression.
			</para>

			<para>
				The enumeration method takes a key-selector expression and a value-selector expression. For each element the method applies the key-selector expression to determine the map key and the value-selector expression to determine the map value. If the key already exists in the map the value is overwritten.
			</para>

			<para>
				The next example EPL outputs a map of item asset id and distance to center for each item:
			</para>
			<programlisting>select items.toMap(k => k.assetId, v => distance(v.location.x, v.location.y, 0, 0)) as assetDistance
from LocationReport</programlisting>
				
			<para>
				If the input is null the method returns null. If the input is empty the method returns an empty map.
			</para>
		</sect2>

		<sect2 id="enumeration-method-union">
			<title>Union</title>

			<para>
				The <literal>union</literal> enumeration method forms a union of the input elements with the elements that the parameter expression yields.
			</para>

			<para>
				The enumeration method takes a single parameter that must itself return a collection of events (input), objects or scalar values. It appends the collection to the input elements and returns the appended collection of elements.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.union({4, 5})   // Returns {1, 2, 3, 4, 5}</programlisting>

			<para>
				This example selects a union of all items that have an asset id of L001 or that are of type passenger:
			</para>
			<programlisting>select items.where(i => i.assetId = 'L001')
    .union(items.where(i => i.type = 'P')) as itemsUnion
from LocationReport</programlisting>
			
			<para>
				If the input is null the method returns null.
			</para>
		</sect2>

		<sect2 id="enumeration-method-where">
			<title>Where</title>

			<para>
				The <literal>where</literal> enumeration method filters elements based on a predicate.
			</para>

			<para>
				The enumeration method has two versions. The first version takes a predicate lambda expression and the second version takes a predicate lambda expression and index for use within the predicate expression. Both version returns all elements for which the predicate expression is true.
			</para>

			<para>
				An expression example with scalar values:
			</para>
			<programlisting>{1, 2, 3}.where(v => v != 2)   // Returns {1, 3}</programlisting>

			<para>
				This example selects all items from a location report that are passenger-type:
			</para>
			<programlisting>select items.where(p => p.type = 'P') from LocationReport</programlisting>
				
			<para>
				The second version of the <literal>where</literal> represents the index of the input element starting at zero for the first element.
			</para>				
			
			<para>
				The example below selects all items from a location report that are passenger-type but ignores the first 3 elements:
			</para>
			<programlisting>select items.where((p, ind) => p.type = 'P' and ind > 2) from LocationReport</programlisting>

			<para>
				If the input is null the method returns null. If the input is empty the method returns an empty collection.
			</para>
		</sect2>
		
	</sect1>

</chapter>