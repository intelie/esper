<chapter id="adapter_jms_spring">
    <title>The Spring JMS Input and Output Adapters</title>
    
    <para>
        This chapter discusses the input and output adapters for JMS based on the Spring JmsTemplate technology. For more information on Spring, and the latest version of Spring, please visit <ulink url="http://www.springframework.org">http://www.springframework.org</ulink>
    </para>
    
    <sect1 id="jms-spring-intro">
        <title>Introduction</title>

        <para>
			Here are the steps to use the adapters:
		</para>

		<orderedlist spacing="compact">
			<listitem>
				<para>
					Configure an Esper engine instance to use a <literal>SpringContextLoader</literal> for loading input and output adapters, and point it to a Spring JmsTemplate configuration file.
				</para>
			</listitem>
			<listitem>
				<para>
					Create a Spring JmsTemplate configuration file for your JMS provider and add all your input and output adapter entries in the same file.
				</para>
			</listitem>
			<listitem>
				<para>
					For receiving events from a JMS destination into an engine (input adapter):
				</para>
				<orderedlist spacing="compact">
					<listitem>
						<para>
							List the destination and un-marshalling class in the Spring configuration. 
						</para>
					</listitem>
					<listitem>
						<para>
							Create EPL statements using the event type name matching the event objects or the Map-event type names received.
						</para>
					</listitem>
				</orderedlist>
			</listitem>
			<listitem>
				<para>
					For sending events to a JMS destination (output adapter):
				</para>
				<orderedlist spacing="compact">
					<listitem>
						<para>
							Use the <literal>insert-into</literal> syntax naming the stream to insert-into using the same name as listed in the Spring configuration file
						</para>
					</listitem>
					<listitem>
						<para>
							Configure the Map event type of the stream in the engine configuration
						</para>
					</listitem>
				</orderedlist>
			</listitem>
		</orderedlist>

        <para>
            In summary the Spring JMS input adapter performs the following functions:
        </para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Initialize from a given Spring configuration file in classpath or from a filename. The Spring configuration file sets all JMS parameters such as JMS connection factory, destination and listener pools.
				</para>
			</listitem>
			<listitem>
				<para>
					Attach to a JMS destination and listen to messages using the Spring class <literal>org.springframework.jms.core.JmsTemplate</literal>
				</para>
			</listitem>
			<listitem>
				<para>
					Unmarshal a JMS message and send into the configured engine instance
				</para>
			</listitem>
		</itemizedlist>

        <para>
            The Spring JMS output adapter can:
        </para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Initialize from a given Spring configuration file in classpath or from a filename, and attach to a JMS destination
				</para>
			</listitem>
			<listitem>
				<para>
					Act as a listener to one or more named streams populated via <literal>insert-into</literal> syntax by EPL statements
				</para>
			</listitem>
			<listitem>
				<para>
					Marshal events generated by a stream into a JMS message, and send to the given destination
				</para>
			</listitem>
		</itemizedlist>
    </sect1>
    
    <sect1 id="jms-spring-engine-config">
        <title>Engine Configuration</title>

        <para>
            The Spring JMS input and output adapters are configured as part of the Esper engine configuration. EsperIO supplies a <literal>SpringContextLoader</literal> class that loads a Spring
            configuration file which in turn configures the JMS input and output adapters. List the <literal>SpringContextLoader</literal> class as an adapter loader in the Esper configuration file as the below example shows. The configuration API can alternatively be used to configure one or more adapter loaders.
        </para>
        
		<programlisting><![CDATA[<esper-configuration>

  <!-- Sample configuration for an input/output adapter loader -->
  <plugin-loader name="MyLoader" class-name="com.espertech.esperio.SpringContextLoader">
    <!-- SpringApplicationContext translates into Spring ClassPathXmlApplicationContext 
           or FileSystemXmlApplicationContext. Only one app-context of a sort can be used. 
           When both attributes are used classpath and file, classpath prevails -->
    <init-arg name="classpath-app-context" value="spring\jms-spring.xml" />
    <init-arg name="file-app-context" value="spring\jms-spring.xml" />
  </plugin-loader>

</esper-configuration>]]></programlisting>		

        <para>
            The loader loads the Spring configuration file from classpath via the <literal>classpath-app-context</literal> configuration, or from a file via <literal>file-app-context</literal>.
        </para>
    </sect1>

    <sect1 id="jms-spring-input-config">
        <title>Input Adapter</title>

		<sect2 id="jms-spring-input-config-file">
			<title>Spring Configuration</title>
			<para>
				The Spring configuration file must list input and output adapters to be initialized by <literal>SpringContextLoader</literal> upon engine initialization.
				Please refer to your JMS provider documentation, and the Spring framework documentation on help to configure your specific JMS provider via Spring.
			</para>
			
			<para>
				The next XML snippet shows a complete sample configuration for an input adapter. The sample includes the JMS configuration for an Apache ActiveMQ JMS provider.
			</para>
			
			<programlisting><![CDATA[<!-- Spring Application Context -->
<beans default-destroy-method="destroy">

  <!-- JMS ActiveMQ Connection Factory -->
  <bean id="jmsActiveMQFactory" class="org.apache.activemq.pool.PooledConnectionFactory">
    <property name="connectionFactory">
      <bean class="org.apache.activemq.ActiveMQConnectionFactory">
        <property name="brokerURL" value="tcp://localhost:61616"/>
      </bean>
    </property>
  </bean>

  <!--  ActiveMQ destination to use  by default -->
  <bean id="defaultDestination"
        class="org.apache.activemq.command.ActiveMQQueue">
    <constructor-arg value="ESPER.QUEUE"/>
  </bean>

  <!--  Spring JMS Template for ActiveMQ -->
  <bean id="jmsActiveMQTemplate" class="org.springframework.jms.core.JmsTemplate">
    <property name="connectionFactory">
      <ref bean="jmsActiveMQFactory"/>
    </property>
    <property name="defaultDestination">
      <ref bean="defaultDestination"/>
    </property>
  </bean>

  <!-- Provides listener threads -->
  <bean id="listenerContainer" 
              class="org.springframework.jms.listener.SimpleMessageListenerContainer">
    <property name="connectionFactory" ref="jmsActiveMQFactory"/>
    <property name="destination" ref="defaultDestination"/>
    <property name="messageListener" ref="jmsInputAdapter"/>
  </bean>

  <!-- Default unmarshaller -->
  <bean id="jmsMessageUnmarshaller" 
              class="com.espertech.esperio.jms.JMSDefaultAnyMessageUnmarshaller"/>

  <!-- Input adapter -->
  <bean id="jmsInputAdapter" class="com.espertech.esperio.jms.SpringJMSTemplateInputAdapter">
    <property name="jmsTemplate">
      <ref bean="jmsActiveMQTemplate"/>
    </property>
    <property name="jmsMessageUnmarshaller">
      <ref bean="jmsMessageUnmarshaller"/>
    </property>
  </bean>

</beans>]]></programlisting>		

			<para>
				This input adapter attaches to the JMS destination <literal>ESPER.QUEUE</literal> at an Apache MQ broker available at port <literal>tcp://localhost:61616</literal>. It configures an un-marshalling class as discussed next.
			</para>
		</sect2>

		<sect2 id="jms-spring-input-unmarshal">
			<title>JMS Message Unmarshalling</title>
			<para>
				EsperIO provides a class for unmarshaling JMS message instances into events for processing by an engine in the class <literal>JMSDefaultAnyMessageUnmarshaller</literal>. The class unmarshals as follows:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						If the received Message is of type <literal>javax.xml.MapMessage</literal>, extract the event type name out of the message and send to the engine via <literal>sendEvent(name, Map)</literal> 
					</para>
				</listitem>
				<listitem>
					<para>
						If the received Message is of type <literal>javax.xml.ObjectMessage</literal>, extract the <literal>Serializable</literal> out of the message and send to the engine via <literal>sendEvent(Object)</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						Else the un-marshaller outputs a warning and ignores the message
					</para>
				</listitem>
			</itemizedlist>
			
			<para>
				The unmarshaller must be made aware of the event type of events within <literal>MapMessage</literal> messages. This is achieved by the client application setting a well-defined property on the message: <literal>InputAdapter.ESPERIO_MAP_EVENT_TYPE</literal>.  An example code snippet is:
			</para>
		<programlisting><![CDATA[MapMessage mapMessage = jmsSession.createMapMessage();
mapMessage.setObject(InputAdapter.ESPERIO_MAP_EVENT_TYPE, "MyInputEvent");]]></programlisting>		
		</sect2>
        
    </sect1>

    <sect1 id="jms-spring-output-config">
        <title>Output Adapter</title>

		<sect2 id="jms-spring-output-config-file">
			<title>Spring Configuration</title>
			<para>
				The Spring configuration file lists all input and output adapters in one file. The <literal>SpringContextLoader</literal> upon engine initialization starts all input and output adapters.
			</para>
			
			<para>
				The next XML snippet shows a complete sample configuration of an output adapter. Please check with your JMS provider for the appropriate Spring class names and settings. Note that the input and output adapter Spring configurations can be in the same file.
			</para>
			
			<programlisting><![CDATA[
<!-- Application Context -->
<beans default-destroy-method="destroy">

  <!-- JMS ActiveMQ Connection Factory -->
  <bean id="jmsActiveMQFactory" class="org.apache.activemq.pool.PooledConnectionFactory">
    <property name="connectionFactory">
      <bean class="org.apache.activemq.ActiveMQConnectionFactory">
        <property name="brokerURL" value="tcp://localhost:61616"/>
      </bean>
    </property>
  </bean>

  <!--  ActiveMQ destination to use  by default -->
  <bean id="defaultDestination"
        class="org.apache.activemq.command.ActiveMQQueue">
    <constructor-arg value="ESPER.QUEUE"/>
  </bean>

  <!--  Spring JMS Template for ActiveMQ -->
  <bean id="jmsActiveMQTemplate" class="org.springframework.jms.core.JmsTemplate">
    <property name="connectionFactory">
      <ref bean="jmsActiveMQFactory"/>
    </property>
    <property name="defaultDestination">
      <ref bean="defaultDestination"/>
    </property>
    <property name="receiveTimeout">
      <value>30000</value>
    </property>
  </bean>

  <!--  Marshaller marshals events into map messages -->
  <bean id="jmsMessageMarshaller" class="com.espertech.esperio.jms.JMSDefaultMapMessageMarshaller"/>
  <bean id="myCustomMarshaller" class="com.espertech.esperio.jms.JMSDefaultMapMessageMarshaller"/>

  <!--  Output adapter puts it all together -->
  <bean id="jmsOutputAdapter" class="com.espertech.esperio.jms.SpringJMSTemplateOutputAdapter">
    <property name="jmsTemplate">
      <ref bean="jmsActiveMQTemplate"/>
    </property>
    <property name="subscriptionMap">
      <map>
        <entry>
          <key><idref local="subscriptionOne"/></key>
          <ref bean="subscriptionOne"/>
        </entry>
        <entry>
          <key><idref local="subscriptionTwo"/></key>
          <ref bean="subscriptionTwo"/>
        </entry>
      </map>
    </property>
    <property name="jmsMessageMarshaller">
      <ref bean="jmsMessageMarshaller"/>
    </property>
  </bean>

  <bean id="subscriptionOne" class="com.espertech.esperio.jms.JMSSubscription">
    <property name="eventTypeName" value="MyOutputStream"/>
  </bean>

  <bean id="subscriptionTwo" class="com.espertech.esperio.jms.JMSSubscription">
    <property name="eventTypeName" value="MyOtherOutputStream"/>
    <property name="jmsMessageMarshaller">
      <ref bean="myCustomMarshaller"/>
    </property>
  </bean>

</beans>]]></programlisting>		

		</sect2>

		<sect2 id="jms-spring-output-marshal">
			<title>JMS Message Marshalling</title>
			<para>
				EsperIO provides a marshal implementation in the class <literal>JMSDefaultMapMessageMarshaller</literal>. This marshaller constructs a JMS <literal>MapMessage</literal> from any event received by copying 
				event properties into the name-value pairs of the message. The configuration file makes it easy to configure a custom marshaller that adheres to the <literal>com.espertech.esperio.jms.JMSMessageMarshaller</literal> interface.
			</para>
            <para>
                Note that this marshaller uses <literal>javax.jms.MapMessage</literal> name-value pairs and not general <literal>javax.jms.Message</literal> properties.
                This means when you'll read the event properties back from the JMS MapMessage, you will have to use the <literal>javax.jms.MapMessage.getObject(...)</literal> method.
            </para>

            <para>
				The <literal>SpringJMSTemplateOutputAdapter</literal> is configured with a list of subscription instances of type <literal>JMSSubscription</literal> as the sample configuration shows. Each subscription defines 
				an event type name that must be configured and used in the <literal>insert-into</literal> syntax of a statement.
			</para>

			<para>
				To connect the Spring JMS output adapter and the EPL statements producing events, use the <literal>insert-into</literal> syntax to direct events for output.  Here is a sample statement that sends events into <literal>MyOutputStream</literal>:
			</para>
			<programlisting><![CDATA[insert into MyOutputStream select assetId, zone from RFIDEvent]]></programlisting>		

			<para>
				The type <literal>MyOutputStream</literal> must be known to an engine instance. The output adapter requires the name to be configured with the Engine instance, e.g.:
			</para>		
			<programlisting><![CDATA[<esper-configuration>
  <event-type name="MyOutputStream">
    <java-util-map>
      <map-property name="assetId" class="String"/>
      <map-property name="zone" class="int"/>
    </java-util-map>
  </event-type>
</esper-configuration>]]></programlisting>		
		</sect2>
        
    </sect1>
</chapter>

