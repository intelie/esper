<chapter id="examples">
    <title>Examples, Tutorials, Case Studies</title>
    
	<para>
		The tutorial and case studies are available on the public web site at <literal>http://esper.codehaus.org/evaluating/evaluating.html</literal>.
	</para>

    <sect1 id="examples-overview">
        <title>Examples Overview</title>
        
		<para>
			This chapter outlines the examples that come with Esper in the <literal>eg/src</literal> folder of the distribution. The code for examples can be found in the <literal>net.esper.example</literal> packages.
		</para>
    	
		<para>
			In order to compile and run the samples please follow the below instructions:
		</para>

		<orderedlist>
			<listitem>
				<para>
                    Make sure Java 1.5 or greater is installed and the JAVA_HOME environment variable is set.
                </para>
			</listitem>
			<listitem>
				<para>
                    Open a console window and change directory to esper/eg/etc.
                </para>
			</listitem>
			<listitem>
				<para>
                    Run "setenv.bat" (Windows) or "setenv.sh" (Unix) to verify your environment settings.
                </para>
			</listitem>
			<listitem>
				<para>
                    Run "compile.bat" (Windows) or "compile.sh" (Unix) to compile the examples.
                </para>
			</listitem>
			<listitem>
				<para>
                    Now you are ready to run the examples. Some examples require mandatory parameters. Further information to running
                    each example can be found in the "eg" folder in file "readme.txt".
                </para>
			</listitem>
			<listitem>
				<para>
                    Modify the logger logging level in the "log4j.xml" configuration file 
                    changing DEBUG to INFO on a class or package level to reduce the volume of text output. 
                </para>
			</listitem>
		</orderedlist>

		<para>
			JUnit tests exist for the example code. The JUnit test source code for the examples can be found in the <literal>eg/test</literal> folder. To build and run the example JUnit tests, use the Maven 2 goal <literal>test</literal>. The JUnit test source code can also be helpful in understanding the example and in the use of Esper APIs.
		</para>		
    </sect1>

    <sect1 id="examples-marketdata-monitor">
        <title>Market Data Feed Monitor</title>

		<para>
			This example processes a raw market data feed. It reports throughput statistics and 
			detects when the data rate of a feed falls off unexpectedly. A rate fall-off may mean that the data is stale and 
			we want to alert when there is a possible problem with the feed.
		</para>

		<para>
			The classes for this example live in package <literal>net.esper.example.marketdatafeed</literal>. 
			Run "run_mktdatafeed.bat" (Windows) or "run_mktdatafeed.sh" (Unix) in the <literal>eg/etc</literal> folder 
			to start the market data feed simulator. 			
		</para>
		
        <sect2 id="examples-marketdata-monitor-input">
        	<title>Input Events</title>
        
			<para>
				The input stream consists of 1 event stream that contains 2 simulated market data feeds. Each individual event in the stream 
				indicates the feed that supplies the market data, the security symbol and some pricing information:
			</para>

<programlisting><![CDATA[String symbol;
FeedEnum feed;
double bidPrice;
double askPrice;
]]></programlisting>
		</sect2>
			
        <sect2 id="examples-marketdata-computing">
        	<title>Computing Rates Per Feed</title>

			<para>
				For the throughput statistics and to detect rapid fall-off we calculate a ticks per second rate for each market data feed. 
			</para>

			<para>
				We can use an EQL statement that specifies a view onto the market data event stream that batches together 1 second of events. 
				We specify the feed and a count of events per feed as output values. To make this data available for further processing, we
				insert output events into the TicksPerSecond event stream:
			</para>

<programlisting><![CDATA[insert into TicksPerSecond
select feed, count(*) as cnt 
  from MarketDataEvent.win:time_batch(1) 
 group by feed
]]></programlisting>
		</sect2>

        <sect2 id="examples-marketdata-falloff">
        	<title>Detecting a Fall-off</title>

			<para>
				We define a rapid fall-off by alerting when the number of ticks per second for any second falls below 75% of the 
				average number of ticks per second over the last 10 seconds. 
			</para>

			<para>
				We can compute the average number of ticks per second over the last 10 seconds simply by using the TicksPerSecond events computed by the
				prior statement and averaging the last 10 seconds. Next, we compare the current rate with the moving average and
				filter out any rates that fall below 75% of the average:
			</para>

<programlisting><![CDATA[select feed, avg(cnt) as avgCnt, cnt as feedCnt 
  from TicksPerSecond.win:time(10)
 group by feed 
having cnt < avg(cnt) * 0.75
]]></programlisting>
		</sect2>

        <sect2 id="examples-marketdata-monitor-sim">
			<title>Event generator</title>
			<para>
				The simulator generates market data events for 2 feeds, feed A and feed B. A target rate parameter
				defines how many events for each feed the simulator sends to the engine in each second. Depending on your system,
				a large target rate may result in more events to be sent to the engine then your system can handle in one second.
				In that case, the target rate will not be achieved. After reaching the target number of events for a given second, 
				the simulator sleeps the thread for an approximate remainder of the current second.
			</para>

			<para>
				The simulator generates a number of events per second following the formula 
				<literal>target rate * 0.9 + target rate * 0.2 * random.nextDouble()</literal>.
				This generates a random rate for each feed in a +-10% range within the target rate.
			</para>

			<para>
				The rate drop probability parameter specifies the probability in percent that the engine drops the rate 
				for a randomly chosen feed to 60% of the target rate for that second. Thus rate fall-off alerts can be generated.
			</para>
		</sect2>
    </sect1>

    <sect1 id="examples-transaction-3-event-challenge">
        <title>Transaction 3-Event Challenge</title>

		<para>
			The classes for this example live in package <literal>net.esper.example.transaction</literal>. 
			Run "run_txnsim.bat" (Windows) or "run_txnsim.sh" (Unix) to start the transaction simulator. 
			Please see the readme file in the same folder for build instructions and command line parameters.
		</para>

        <sect2 id="examples-txn3event-1" >
			<title>The Events</title>

			<para>
	The use case involves tracking three components of a transaction. It‘s important that we use at least three components, since some engines have different performance or coding for only two events per transaction. Each component comes to the engine as an event with the following fields:
			</para>
	
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Transaction ID
					</para>
				</listitem>
				<listitem>
					<para>
						Time stamp
					</para>
				</listitem>
			</itemizedlist>
	
			<para>
				In addition, we have the following extra fields:
			</para>
	
			<para>
				In event A:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Customer ID
					</para>
				</listitem>
			</itemizedlist>
	
			<para>
				In event C:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Supplier ID (the ID of the supplier that the order was filled through)
					</para>
				</listitem>
			</itemizedlist>
		</sect2>

        <sect2 id="examples-txn3event-2" >
			<title>Combined event</title>

			<para>
					We need to take in events A, B and C and produce a single, combined event with the following fields:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Transaction ID
					</para>
				</listitem>
				<listitem>
					<para>
						Customer ID
					</para>
				</listitem>
				<listitem>
					<para>
						Time stamp from event A
					</para>
				</listitem>
				<listitem>
					<para>
						Time stamp from event B
					</para>
				</listitem>
				<listitem>
					<para>
						Time stamp from event C
					</para>
				</listitem>
			</itemizedlist>

			<para>
What we‘re doing here is matching the transaction IDs on each event, to form an aggregate event. If all these events were in a relational database, this could be done as a simple SQL join… except that with 10,000 events per second, you will need some serious database hardware to do it.
			</para>
		</sect2>
		
        <sect2 id="examples-txn3event-3">
			<title>Real time summary data</title>

			<para>
Further, we need to produce the following:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Min,Max,Average total latency from the events (difference in time between A and C) over the past 30 minutes.
					</para>
				</listitem>
				<listitem>
					<para>
						Min,Max,Average latency grouped by (a) customer ID and (b) supplier ID. In other words, metrics on the the latency of the orders coming from each customer and going to each supplier.
					</para>
				</listitem>
				<listitem>
					<para>
						Min,Max,Average latency between events A/B (time stamp of B minus A) and B/C (time stamp of C minus B).
					</para>
				</listitem>
			</itemizedlist>
		</sect2>
		
        <sect2 id="examples-txn3event-4">
			<title>Find problems</title>

			<para>
We need to detect a transaction that did not make it through all three events. In other words, a transaction with events A or B, but not C. Note that, in this case, what we care about is event C. The lack of events A or B could indicate a failure in the event transport and should be ignored. Although the lack of an event C could also be a transport failure, it merits looking into.
			</para>			
		</sect2>
		
        <sect2 id="examples-txn3event-5">
			<title>Event generator</title>
		
			<para>
To make testing easier, standard and to demonstrate how the example works, the example is including an event generator. The generator generates events for a given number of transactions, using the following rules:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						One in 5,000 transactions will skip event A
					</para>
				</listitem>
				<listitem>
					<para>
						One in 1,000 transactions will skip event B
					</para>
				</listitem>
				<listitem>
					<para>
						One in 10,000 transactions will skip event C.
					</para>
				</listitem>
				<listitem>
					<para>
						Transaction identifiers are randomly generated
					</para>
				</listitem>
				<listitem>
					<para>
						Customer and supplier identifiers are randomly chosen from two lists
					</para>
				</listitem>
				<listitem>
					<para>
						The time stamp on each event is based on the system time. Between events A and B as well as B and C, between 0 and 999 is added to the time. So, we have an expected time difference of around 500 milliseconds between each event
					</para>
				</listitem>
				<listitem>
					<para>
						Events are randomly shuffled as described below
					</para>
				</listitem>
				</itemizedlist>
	
				<para>
	To make things harder, we don‘t want transaction events coming in order. This code ensures that they come completely out of order. To do this, we fill in a bucket with events and, when the bucket is full, we shuffle it. The buckets are sized so that some transactions‘ events will be split between buckets. So, you have a fairly randomized flow of events, representing the worst case from a big, distributed infrastructure.
				</para>
	
				<para>
	The generator lets you change the size of the bucket (small, medium, large, larger, largerer). The larger the bucket size, the more events potentially come in between two events in a given transaction and so, the more the performance characteristics like buffers, hashes/indexes and other structures are put to the test as the bucket size increases.
				</para>
			</sect2>
    </sect1>

    <sect1 id="examples-autoid">
        <title>AutoID RFID Reader</title>

		<para>
			In this example an array of RFID readers sense RFID tags as pallets are coming within the range of one of the readers. 
			A reader generates XML documents with observation information such as reader sensor ID, observation time 
			and tags observed. A statement computes the total number of tags per reader sensor ID within the last 60 seconds.
		</para>
    	
		<para>
			This example demonstrates how XML documents unmarshalled to <literal>org.w3c.dom.Node</literal> DOM document nodes
			can natively be processed by the engine without requiring Java object event representations. The example uses an XPath
			expression for an event property counting the number of tags observed by a sensor. The XML documents follow the AutoID (<literal>http://www.autoid.org/</literal>) organization
			standard. 
		</para>

		<para>
			The classes for this example can be found in package <literal>net.esper.example.autoid</literal>.
			As events are XML documents with no Java object representation, the example does not have event classes.
		</para>

		<para>
			A simulator that can be run from the command line is also available for this example.
			The simulator generates a number of XML documents as specified by a command line argument and
			prints out the totals per sensor.
			Run "run_autoid.bat" (Windows) or "run_autoid.sh" (Unix) to start the autoid simulator. 
			Please see the readme file in the same folder for build instructions and command line parameters.
		</para>

		<para>
			The code snippet below shows the simple statement to compute the total number of tags per sensor. The statement is created by class 
			<literal>net.esper.example.autoid.RFIDTagsPerSensorStmt</literal>.
		</para>

<programlisting><![CDATA[select ID as sensorId, sum(countTags) as numTagsPerSensor
from AutoIdRFIDExample.win:time(60)
where Observation[0].Command = 'READ_PALLET_TAGS_ONLY'
group by ID]]></programlisting>

    </sect1>

    <sect1 id="examples-stockticker">
        <title>StockTicker</title>

		<para>
			 The StockTicker example comes from the stock trading domain. The example creates event patterns to filter stock tick events based on price and symbol. 
			 When a stock tick event is encountered that falls outside the lower or upper price limit, the example simply displays that stock tick event.
			 The price range itself is dynamically created and changed. This is accomplished by an event patterns that searches for another event class, the price limit event.			 			 
		</para>
    	
		<para>
			The classes <literal>net.esper.example.stockticker.event.StockTick</literal> and <literal>PriceLimit</literal> represent our events. The event patterns are created by the class <literal>net.esper.example.stockticker.monitor.StockTickerMonitor</literal>. 
		</para>

		<para>
			Summary:
		</para>

        <itemizedlist spacing="compact">
			<listitem>
				<para>
                    Good example to learn the API and get started with event patterns
                </para>
			</listitem>
			<listitem>
				<para>
                    Dynamically creates and removes event patterns based on price limit events received
                </para>
			</listitem>
			<listitem>
				<para>
                    Simple, highly-performant filter expressions for event properties in the stock tick event such as symbol and price
                </para>
			</listitem>
		</itemizedlist>
    </sect1>

    <sect1 id="examples-matchmaker">
        <title>MatchMaker</title>

		<para>
			 In the MatchMaker example every mobile user has an X and Y location, a set of properties (gender, hair color, age range) and a set of preferences (one for each property) to match. The task of the event patterns created by this example is to detect mobile users that are within proximity given a certain range, and for which the properties match preferences.
		</para>
		
		<para>
			The event class representing mobile users is <literal>net.esper.example.matchmaker.event.MobileUserBean</literal>. The <literal>net.esper.example.matchmaker.monitor.MatchMakingMonitor</literal> class contains the patterns for detecing matches.
		</para>
    	
		<para>
			Summary:
		</para>

        <itemizedlist spacing="compact">
			<listitem>
				<para>
                    Dynamically creates and removes event patterns based on mobile user events received
                </para>
			</listitem>
			<listitem>
				<para>
                    Uses range matching for X and Y properties of mobile user events
                </para>
			</listitem>
		</itemizedlist>

    </sect1>
    
	<sect1 id="examples-qossla" revision="2">
        <title>QualityOfService</title>
            
        <para>
            This example develops some code for measuring quality-of-service levels such as for a service-level agreement (SLA).
            A SLA is a contract between 2 parties that defines service constraints such as maximum latency for service operations or error rates.
        </para>
            
        <para>                      
            The example measures and monitors operation latency and error counts per customer and operation. When 
            one of our operations oversteps these constraints, we want to be alerted right away. Additionally, we would like to have some monitoring in
            place that checks the health of our service and provides some information on how the operations are used.
        </para>

        <para>                      
            Some of the constraints we need to check are:
         </para>
            
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					That the latency (time to finish) of some of the operations is always less then X seconds.
				</para>
			</listitem>
			<listitem>
				<para>
					That the latency average is always less then Y seconds over Z operation invocations. 
				</para>
			</listitem>
		</itemizedlist>
		
		<para>
			The <literal>net.esper.example.qos_sla.events.OperationMeasurement</literal> event class with its latency and status properties is the main event used for the SLA analysis. The other event <literal>LatencyLimit</literal> serves to set latency limits on the fly.
		</para>

		<para>
			The <literal>net.esper.example.qos_sla.monitor.AverageLatencyMonitor</literal> creates an EQL statement that computes latency statistics per customer and operation for the
			last 100 events. The <literal>DynaLatencySpikeMonitor</literal> uses an event pattern to listen to spikes in latency with dynamically set limits. The <literal>ErrorRateMonitor</literal> uses the timer <literal>'at'</literal> operator in an event pattern that wakes up periodically and polls the error rate within the last 10 minutes. The <literal>ServiceHealthMonitor</literal> simply alerts when 3 errors occur, and the <literal>SpikeAndErrorMonitor</literal> alerts when a fixed latency is overstepped or an error status is reported.
		</para>

		<para>
			Summary:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
                    This example combines event patterns with EQL statements for event stream analysis.
                </para>
			</listitem>
			<listitem>
				<para>
                    Shows the use of the timer <literal>'at'</literal> operator and followed-by operator <literal>-&gt;</literal> in event patterns
                </para>
			</listitem>
			<listitem>
				<para>
                    Outlines basic EQL statements
                </para>
			</listitem>
			<listitem>
				<para>
                    Shows how to pull data out of EQL statements rather then subscribing to events a statement publishes
                </para>
			</listitem>
		</itemizedlist>
    </sect1>
    
	<sect1 id="examples-linearroad" revision="2">
        <title>LinearRoad</title>
        
        <para>
			The Linear Road example is a very incomplete implementation of the Stream Data Management Benchmark [3] by Standford University. 
        </para>

        <para>
			Linear Road simulates a toll system for the motor vehicle expressways of a large metropolitan area. The main event in this example is a car location report which the class
			<literal>net.esper.example.linearroad.CarLocEvent</literal> represents. Currently the event stream joins are performed by JUnit test classes in the <literal>eg/test</literal> folder. See the <literal>net.esper.example.linearroad.TestAccidentNotify</literal> and the <literal>TestCarSegmentCount</literal> classes. Please consider this a work in progress.
        </para>
        
		<para>
			Summary:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
                    Shows more complex joins between event streams.
                </para>
			</listitem>
		</itemizedlist>        
    </sect1>
    
	<sect1 id="examples-stocktick-rsi" revision="2">
        <title>StockTick RSI</title>
        
        <para>
			The RSI gives you the trend for a stock and for more complete explanation, you can visit the link: http://www.stockcharts.com/education/IndicatorAnalysis/indic_RSI.html.
		</para>
		
        <para>
			After a definite number of stock events, or accumulation period, the first RSI is computed. Then for each subsequent stock event, the RSI calculations use the previous period’s Average Gain and Loss to determine the “smoothed RSI”.
        </para>

		<para>
			Summary:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
                    Uses a simple event pattern with a filter which feeds a listener that computes the RSI, which publishes events containing the computed RSI.
                </para>
			</listitem>
		</itemizedlist>        
    </sect1>

</chapter>

