<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;5.&nbsp;Event Pattern Reference</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="Esper - Java Event Stream Processor "><link rel="up" href="index.html" title="Esper - Java Event Stream Processor "><link rel="previous" href="event_representation.html" title="Chapter&nbsp;4.&nbsp;Event Representations"><link rel="next" href="EQL.html" title="Chapter&nbsp;6.&nbsp;EQL Reference"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;5.&nbsp;Event Pattern Reference</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="event_representation.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="EQL.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="event_patterns"></a>Chapter&nbsp;5.&nbsp;Event Pattern Reference</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="event-pattern-intro"></a>5.1.&nbsp;Event Pattern Overview</h2></div></div><div></div></div><p>
			Event patterns match when an event or multiple events occur that match the pattern's definition. Patterns can also be time-based.
         </p><p>
			Pattern expressions can consist of filter expressions combined with pattern operators. Expressions can contain further nested
			pattern expressions by including the nested expression(s) in <tt class="literal">()</tt> round brackets.
         </p><p>
			There are 5 types of operators:
         </p><div class="orderedlist"><ol type="1" compact><li><p>
					Operators that control pattern finder creation and termination: <tt class="literal">every</tt>
				</p></li><li><p>
					Logical operators: <tt class="literal">and</tt>, <tt class="literal">or</tt>, <tt class="literal">not</tt>
				</p></li><li><p>
					Temporal operators that operate on event order: <tt class="literal">-&gt;</tt> (followed-by)
				</p></li><li><p>
					Guards are where-conditions that filter out events and cause termination of the pattern finder. Examples are <tt class="literal">timer:within</tt>.
				</p></li><li><p>
					Observers observe time events as well as other events. Examples are <tt class="literal">timer:interval</tt> and <tt class="literal">timer:at</tt>.
				</p></li></ol></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-how-to-use"></a>5.2.&nbsp;How to use Patterns</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-howto-syntax"></a>5.2.1.&nbsp;Pattern Syntax</h3></div></div><div></div></div><p>
				This is an example pattern expression that matches on every <tt class="literal">ServiceMeasurement</tt> events in which the
				value of the <tt class="literal">latency</tt> event property is over 20 seconds, and on every <tt class="literal">ServiceMeasurement</tt> event in which the
				<tt class="literal">success</tt> property is false. Either one or the other condition must be true for this pattern to match.
			</p><pre class="programlisting">every (spike=ServiceMeasurement(latency&gt;20000) or error=ServiceMeasurement(success=false))</pre><p>
				In the example above, the pattern expression starts with an <tt class="literal">every</tt> operator to indicate that the pattern should fire for every matching events and not just the first
				matching event. Within the <tt class="literal">every</tt> operator in round brackets is a nested pattern expression using the <tt class="literal">or</tt> operator. 
				The left hand of the <tt class="literal">or</tt> operator is a filter expression that filters for events with a high latency value. The right hand of the operator 
				contains a filter expression that filters for events with error status. Filter expressions are explained in <a href="event_patterns.html#pattern-filter" title="5.3.&nbsp;Filter Expressions">Section&nbsp;5.3, &#8220;Filter Expressions&#8221;</a>.
			</p><p>
				The example above assigned the tags <tt class="literal">spike</tt> and <tt class="literal">error</tt> to the events in the pattern. The tags are important since the
				engine only places tagged events into the output event(s) that a pattern generates, and that the engine supplies to listeners of the pattern statement. The tags can
				further be selected in the select-clause of an EQL statement as discussed in <a href="EQL.html#eql-from-clause-patterns" title="6.4.2.&nbsp;Pattern-based event streams">Section&nbsp;6.4.2, &#8220;Pattern-based event streams&#8221;</a>.
			</p><p>
				Pattern statements are created via the <tt class="literal">EPAdministrator</tt> interface. The <tt class="literal">EPAdministrator</tt> interface allows to create pattern statements in two ways:
				Pattern statements that want to make use of the EQL <tt class="literal">select</tt> clause or any other EQL constructs use the <tt class="literal">createEQL</tt> method to create a statement that specifies one or more pattern expressions. EQL statements that use patterns are described in more detail in <a href="EQL.html#eql-from-clause-patterns" title="6.4.2.&nbsp;Pattern-based event streams">Section&nbsp;6.4.2, &#8220;Pattern-based event streams&#8221;</a>. Use the syntax as shown in below example.
			</p><pre class="programlisting">EPAdministrator admin = EPServiceProviderManager.getDefaultProvider().getEPAdministrator();

String eventName = ServiceMeasurement.class.getName();

EPStatement myTrigger = admin.createEQL("select * from pattern [" +
  "every (spike=" + eventName + "(latency&gt;20000) or error=" + eventName + "(success=false))]");
</pre><p>
				Pattern statements that do not need to make use of the EQL <tt class="literal">select</tt> clause or any other EQL constructs can use the <tt class="literal">createPattern</tt> method, as in below example.
			</p><pre class="programlisting">EPStatement myTrigger = admin.createPattern(
  "every (spike=" + eventName + "(latency&gt;20000) or error=" + eventName + "(success=false))");
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="patterns-howto-subscribe"></a>5.2.2.&nbsp;Subscribing to Pattern Events</h3></div></div><div></div></div><p>			
				When a pattern fires it publishes one or more events to any listeners to the pattern statement. 
				The listener interface is the <tt class="literal">net.esper.client.UpdateListener</tt> interface.
			</p><p>            
				The example below shows an anonymous implementation of the <tt class="literal">net.esper.client.UpdateListener</tt> interface.
				We add the anonymous listener implementation to the <tt class="literal">myPattern</tt> statement created earlier. 
				The listener code simply extracts the underlying event class.
			</p><pre class="programlisting">myPattern.addListener(new UpdateListener()
{
  public void update(EventBean[] newEvents, EventBean[] oldEvents)
  {
    ServiceMeasurement spike = (ServiceMeasurement) newEvents[0].get("spike");
    ServiceMeasurement error = (ServiceMeasurement) newEvents[0].get("error");
    ... // either spike or error can be null, depending on which occurred
    ... // add more logic here
  }
});
</pre><p>            
				Listeners receive an array of <tt class="literal">EventBean</tt> instances in the <tt class="literal">newEvents</tt> parameter.
				There is one <tt class="literal">EventBean</tt> instance passed to the listener for each combination of events that matches
				the pattern expression. At least one <tt class="literal">EventBean</tt> instance is always passed to the listener.
			</p><p>
				The properties of each <tt class="literal">EventBean</tt> instance contain the underlying events that caused the
				pattern to fire, if events have been named in the filter expression via the <tt class="literal">name=eventType</tt> syntax.
				The property name is thus the name supplied in the pattern expression, while the property type is the type of the underlying class, 
				in this example <tt class="literal">ServiceMeasurement</tt>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-howto-pull-data"></a>5.2.3.&nbsp;Pulling Data from Patterns</h3></div></div><div></div></div><p>
				Data can also be pulled from pattern statements via the <tt class="literal">iterator()</tt> method. 
				If the pattern had fired at least once, then the iterator returns the last event for which it fired.
				The <tt class="literal">hasNext()</tt> method can be used to determine if the pattern had fired.				 				
			</p><pre class="programlisting">if (myPattern.iterator().hasNext())
{
	ServiceMeasurement event = (ServiceMeasurement) view.iterator().next().get("alert");
    ... // some more code here to process the event
}
else
{
    ... // no matching events at this time
}</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-filter"></a>5.3.&nbsp;Filter Expressions</h2></div></div><div></div></div><p>
            This chapter outines how to filter events based on their properties.
        </p><p>
            The simplest form of filter is a filter for events of a given type without any conditions on the event property values. This filter matches any event of that type regardless of the event's properties. The example below is such a filter. Note that this event pattern would stop firing as soon as the first RfidEvent is encountered.
         </p><pre class="programlisting">com.mypackage.myevents.RfidEvent</pre><p>
			 To make the event pattern fire for every RfidEvent and not just the first event, use the <tt class="literal">every</tt> keyword.
		 </p><pre class="programlisting">every com.mypackage.myevents.RfidEvent</pre><p>
			 The example above specifies the fully-qualified Java class name as the event type. Via configuration, the event pattern above can be simplified by using the alias
			 that has been defined for the event type. Interfaces and abstract classes are also supported as event types.
		 </p><pre class="programlisting">every RfidEvent</pre><p>
			 Interfaces and superclasses are also supported as event types. In the below example <tt class="literal">IRfidReadable</tt> is an interface class.
		 </p><pre class="programlisting">every org.myorg.rfid.IRfidReadable</pre><p>
            The filtering criteria to filter for events with certain event property values are placed within parenthesis after the event type name.
         </p><pre class="programlisting">mypackage.RfidEvent(category="Perishable")</pre><p>
            The supported filter operators are
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    equals <tt class="literal">=</tt>
                </p></li><li><p>
                    not equals <tt class="literal">!=</tt>
                </p></li><li><p>
                    comparison operators <tt class="literal">&lt; , &gt; , &gt;=, &lt;=</tt>
                </p></li><li><p>
                    ranges use the keyword <tt class="literal">in </tt> and round <tt class="literal">(...)</tt> or square brackets <tt class="literal">[]</tt>
                </p></li></ul></div><p>
			Ranges come in the following 4 varieties. The use of round <tt class="literal">()</tt> 
			or square <tt class="literal">[]</tt> bracket dictates whether an endpoint is included or excluded.
         </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Open ranges that contain neither endpoint <tt class="literal">(low:high)</tt>
                </p></li><li><p>
                    Closed ranges that contain both endpoints <tt class="literal">[low:high]</tt>
                </p></li><li><p>
                    Half-open ranges that contain the low endpoint but not the high endpoint <tt class="literal">[low:high)</tt>
                </p></li><li><p>
                    Half-closed ranges that contain the high endpoint but not the low endpoint <tt class="literal">(low:high]</tt>
                </p></li></ul></div><p>
            Filter criteria are listed in a comma-separated format. In the example below we look for <tt class="literal">RfidEvent</tt> events with
            a <tt class="literal">grade</tt> property between 1 and 2 (endpoints included), a <tt class="literal">price</tt> less then 1, and a category of "Perishable".
         </p><pre class="programlisting">mypackage.RfidEvent(category="Perishable", price&lt;1.00, grade in [1:2])</pre><p>
            Filter criteria can also refer to events matching prior named events in the same expression. Below pattern is an example in which the pattern
            matches once for every RfidEvent that is preceded by an RfidEvent with the same item id.
         </p><pre class="programlisting">every A=mypackage.RfidEvent -&gt; B=mypackage.RfidEvent(itemId=A.itemId)</pre><p>
            The syntax shown above allows filter criteria to reference prior results by specifying the event name and event property. This syntax can be used with all filter operators.
         </p><p>
            Some limitations of filters are:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Range and comparison operators require the event property to be of a numeric type. 
                </p></li><li><p>
                    Null values in filter criteria are currently not allowed.
                </p></li><li><p>
                    Filter criteria can list the same event property only once. 
                </p></li><li><p>
                    Events that have null values for event properties listed in the filter criteria do not match the criteria.
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-operators"></a>5.4.&nbsp;Pattern Operators</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-logical-every"></a>5.4.1.&nbsp;Every</h3></div></div><div></div></div><p>				
				The <tt class="literal">every</tt> operator indicates that the pattern expression should restart when the pattern matches.
				Without the <tt class="literal">every</tt> operator the pattern expressions matcher stops when the pattern matches once.
            </p><p>
				Thus the <tt class="literal">every</tt> operator works like a factory for the pattern expression contained within. When the pattern expression within it 
				fires and thus quits checking for events, the <tt class="literal">every</tt> causes the start of a new pattern matcher listening for more occurances of the same
				event or set of events.
            </p><p>
				Every time a pattern expression within an <tt class="literal">every</tt> operator turns true a new active pattern matcher is started looking 
				for more event(s) or timing conditions that match the pattern expression. If the <tt class="literal">every</tt> operator is not specified for an expression, 
				the expression stops after the first match was found.
            </p><p>
				This pattern fires when encountering event A and then stops looking.
            </p><pre class="programlisting">A</pre><p>
				This pattern keeps firing when encountering event A, and doesn't stop looking.
            </p><pre class="programlisting">every A</pre><p>
				Let's consider an example event sequence as follows.
            </p><p>
				A<sub>1</sub>   
				B<sub>1</sub>   
				C<sub>1</sub>   
				B<sub>2</sub>   
				A<sub>2</sub>   
				D<sub>1</sub>   
				A<sub>3</sub>   
				B<sub>3</sub>   
				E<sub>1</sub>   
				A<sub>4</sub>   
				F<sub>1</sub>   
				B<sub>4</sub>   
            </p><div class="table"><a name="pattern-every-samples"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;'Every' operator examples</b></p><table summary="'Every' operator examples" border="1"><colgroup><col><col></colgroup><thead><tr><th>Example</th><th>Description</th></tr></thead><tbody><tr><td><pre class="programlisting">every ( A -&gt; B )</pre></td><td><p>
									Detect event A followed by event B. 
									At the time when B occurs the pattern matches, then the pattern matcher restarts and looks for event A again.
								</p><div class="orderedlist"><ol type="1" compact><li><p>
											Matches on B<sub>1</sub> for combination {A<sub>1</sub>, B<sub>1</sub>}
										</p></li><li><p>
											Matches on B<sub>3</sub> for combination {A<sub>2</sub>, B<sub>3</sub>}
										</p></li><li><p>
											Matches on B<sub>4</sub> for combination {A<sub>4</sub>, B<sub>4</sub>}
										</p></li></ol></div></td></tr><tr><td><pre class="programlisting">every A -&gt; B</pre></td><td><p>
									The pattern fires for every event A followed by an event B.
								</p><div class="orderedlist"><ol type="1" compact><li><p>
											Matches on B<sub>1</sub> for combination {A<sub>1</sub>, B<sub>1</sub>}
										</p></li><li><p>
											Matches on B<sub>3</sub> for combination {A<sub>2</sub>, B<sub>3</sub>}
											and {A<sub>3</sub>, B<sub>3</sub>}
										</p></li><li><p>
											Matches on B<sub>4</sub> for combination {A<sub>4</sub>, B<sub>4</sub>}
										</p></li></ol></div></td></tr><tr><td><pre class="programlisting">A -&gt; every B</pre></td><td><p>
									The pattern fires for an event A followed by every event B.
								</p><div class="orderedlist"><ol type="1" compact><li><p>
											Matches on B<sub>1</sub> for combination {A<sub>1</sub>, B<sub>1</sub>}.
										</p></li><li><p>
											Matches on B<sub>2</sub> for combination {A<sub>1</sub>, B<sub>2</sub>}.
										</p></li><li><p>
											Matches on B<sub>3</sub> for combination {A<sub>1</sub>, B<sub>3</sub>}
										</p></li><li><p>
											Matches on B<sub>4</sub> for combination {A<sub>1</sub>, B<sub>4</sub>}
										</p></li></ol></div></td></tr><tr><td><pre class="programlisting">every A -&gt; every B</pre></td><td><p>
									The pattern fires for every event A followed by every event B.
								</p><div class="orderedlist"><ol type="1" compact><li><p>
											Matches on B<sub>1</sub> for combination {A<sub>1</sub>, B<sub>1</sub>}.
										</p></li><li><p>
											Matches on B<sub>2</sub> for combination {A<sub>1</sub>, B<sub>2</sub>}.
										</p></li><li><p>
											Matches on B<sub>3</sub> for combination {A<sub>1</sub>, B<sub>3</sub>}
											and {A<sub>2</sub>, B<sub>3</sub>} and {A<sub>3</sub>, B<sub>3</sub>}
										</p></li><li><p>
											Matches on B<sub>4</sub> for combination {A<sub>1</sub>, B<sub>4</sub>}
											and {A<sub>2</sub>, B<sub>4</sub>} and {A<sub>3</sub>, B<sub>4</sub>}
											and {A<sub>4</sub>, B<sub>4</sub>}
										</p></li></ol></div></td></tr></tbody></table></div><p>
				The examples show that it is possible that a pattern fires for multiple combinations of events that match a pattern expression.
				Each combination is posted as an <tt class="literal">EventBean</tt> instance to the <tt class="literal">update</tt> method in the <tt class="literal">UpdateListener</tt> implementation.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-logical-and"></a>5.4.2.&nbsp;And</h3></div></div><div></div></div><p>
				Similar to the Java &amp;&amp; operator the <tt class="literal">and</tt> operator requires both nested pattern expressions to turn 
				true before the whole expression turns true (a join pattern).
            </p><p>
				Pattern matches when both event A and event B are found.
            </p><pre class="programlisting">A and B</pre><p>
				Pattern matches on any sequence A followed by B and C followed by D, or C followed by D and A followed by B
            </p><pre class="programlisting">(A -&gt; B) and (C -&gt; D)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-logical-or"></a>5.4.3.&nbsp;Or</h3></div></div><div></div></div><p>
				Similar to the Java &#8220;||&#8221; operator the <tt class="literal">or</tt> operator requires either one of the expressions 
				to turn true before the whole expression turns true.
            </p><p>
			   Look for either event A or event B. As always, A and B can itself be nested expressions as well.
            </p><pre class="programlisting">A or B</pre><p>
				Detect all stock ticks that are either above or below a threshold.
            </p><pre class="programlisting">every (StockTick(symbol='IBM', price &lt; 100) or StockTick(symbol='IBM', price &gt; 105)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-logical-not"></a>5.4.4.&nbsp;Not</h3></div></div><div></div></div><p>
				The <tt class="literal">not</tt> operator negates the truth value of an expression. Pattern expressions prefixed with <tt class="literal">not</tt> are automatically 
				defaulted to true.
            </p><p>
				This pattern matches only when an event A is encountered followed by event B but only if no event C was encountered before event B.          
            </p><pre class="programlisting">( A -&gt; B ) and not C</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-temporal-followed-by"></a>5.4.5.&nbsp;Followed-by</h3></div></div><div></div></div><p>
				The followed by <tt class="literal">-&gt;</tt> operator specifies that first the left hand expression must turn true and only 
				then is the right hand expression evaluated for matching events.
            </p><p>
				Look for event A and if encountered, look for event B. As always, A and B can itself be nested event pattern expressions.
            </p><pre class="programlisting">A -&gt; B</pre><p>
				This is a pattern that fires when 2 status events indicating an error occur one after the other.
            </p><pre class="programlisting">StatusEvent(status='ERROR') -&gt; StatusEvent(status='ERROR')</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-guards"></a>5.5.&nbsp;Pattern Guards</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-timer-within"></a>5.5.1.&nbsp;timer:within</h3></div></div><div></div></div><p>
				The <tt class="literal">timer:within</tt> guard acts like a stopwatch. 
				If the associated pattern expression does not turn true within the specified time period it is stopped and permanently false.
				The <tt class="literal">timer:within</tt> guard takes a time period (see <a href="EQL.html#eql-syntax-time-periods" title="6.2.1.&nbsp;Specifying Time Periods">Section&nbsp;6.2.1, &#8220;Specifying Time Periods&#8221;</a>) or a number of seconds as a parameter.
            </p><p>
				This pattern fires if an A event arrives within 5 seconds after statement creation.
            </p><pre class="programlisting">A where timer:within (5 seconds)</pre><p>
				This pattern fires for all A events that arrive within 5 seconds. After 5 seconds, this pattern stops matching even if more A events arrive.
            </p><pre class="programlisting">(every A) where timer:within (5 seconds)</pre><p>
				This pattern is similar to the first pattern but here every time A arrives within 5 seconds, the pattern begins looking for A for another 5 seconds. As long
				as A events arrive within 5 seconds after the last A, the pattern does not stop matching.
            </p><pre class="programlisting">every (A where timer:within (5 sec))</pre><p>
				This pattern matches for any one A or B event in the next 5 seconds.
            </p><pre class="programlisting">( A or B ) where timer:within (5 sec)</pre><p>
				This pattern matches for any 2 errors that happen 10 seconds within each other.
            </p><pre class="programlisting">every (StatusEvent(status='ERROR') -&gt; StatusEvent(status='ERROR') where timer:within (10 sec))</pre><p>
				The following guards are equivalent:
			</p><pre class="programlisting">timer:within(2 minutes 5 seconds)
timer:within(125 sec)
timer:within(125)</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-observers"></a>5.6.&nbsp;Pattern Observers</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-timer-interval"></a>5.6.1.&nbsp;timer:interval</h3></div></div><div></div></div><p>
				The <tt class="literal">timer:interval</tt> observer waits for the defined time before the truth value of the observer turns true.
				The observer takes a time period (see <a href="EQL.html#eql-syntax-time-periods" title="6.2.1.&nbsp;Specifying Time Periods">Section&nbsp;6.2.1, &#8220;Specifying Time Periods&#8221;</a>) or a number of seconds as a parameter.
            </p><p>
				After event A arrived wait 10 seconds then indicate that the pattern matches.
            </p><pre class="programlisting">A -&gt; timer:interval(10 seconds) </pre><p>
				The pattern below fires every 20 seconds.
            </p><pre class="programlisting">every timer:interval(20 sec)</pre><p>
				The next example pattern fires for every event A that is not followed by an event B within 60 seconds after event A arrived. B must have the same "id" property
				value as A.
            </p><pre class="programlisting">every a=A -&gt; (timer:interval(60 sec) and not B(id=a.id)) </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-timer-at"></a>5.6.2.&nbsp;timer:at</h3></div></div><div></div></div><p>
				The <tt class="literal">timer:at</tt> observer is similar in function to the Unix &#8220;crontab&#8221; command. At a specified time the 
				expression turns true. The <tt class="literal">at</tt> operator can also be made to pattern match at regular intervals by using an <tt class="literal">every</tt> operator 
				in front of the <tt class="literal">timer:at</tt> operator. 
            </p><p>
				The syntax is: <tt class="literal">timer:at (minutes, hours, days of month, months, days of week [, seconds]).</tt>
            </p><p>
				The value for seconds is optional. Each element allows wildcard <tt class="literal">*</tt> values. Ranges can be specified 
				by means of lower bounds then a colon &#8216;:&#8217; then the upper bound. The division operator <tt class="literal">*/x</tt> can be used to 
				specify that every x<sub>th</sub> value is valid. Combinations of these operators can be used by placing these into square brackets([]).
            </p><p>
				This expression pattern matches every 5 minutes past the hour.
            </p><pre class="programlisting">every timer:at(5, *, *, *, *)</pre><p>
				The below at operator pattern matches every 15 minutes from 8am to 5pm on even numbered days of the month as well as on the 
				first day of the month.
            </p><pre class="programlisting">timer:at (*/15, 8:17, [*/2, 1], *, *)</pre></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="event_representation.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="EQL.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;4.&nbsp;Event Representations&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;6.&nbsp;EQL Reference</td></tr></table></div></body></html>