<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;3.&nbsp;API Reference</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="Esper - Java Event Stream Processor "><link rel="up" href="index.html" title="Esper - Java Event Stream Processor "><link rel="previous" href="configuration.html" title="Chapter&nbsp;2.&nbsp;Configuration"><link rel="next" href="event_representation.html" title="Chapter&nbsp;4.&nbsp;Event Representations"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;3.&nbsp;API Reference</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="configuration.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="event_representation.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="api"></a>Chapter&nbsp;3.&nbsp;API Reference</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-reference-intro"></a>3.1.&nbsp;API Overview</h2></div></div><div></div></div><p>
			Esper has 2 primary interfaces that this section outlines: The administrative interface and the runtime interface.
        </p><p>
			Use Esper's administrative interface to create event patterns and EQL statements as discussed in <a href="event_patterns.html#event-pattern-intro" title="5.1.&nbsp;Event Pattern Overview">Section&nbsp;5.1, &#8220;Event Pattern Overview&#8221;</a> and <a href="EQL.html#eql-intro" title="6.1.&nbsp;EQL Introduction">Section&nbsp;6.1, &#8220;EQL Introduction&#8221;</a>. 
        </p><p>
			Use Esper's runtime interface to send events into the engine, emit events and get statistics for an engine instance.
        </p><p>
			The JavaDoc documentation is also a great source for API information.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-engine-instances"></a>3.2.&nbsp;Engine Instances</h2></div></div><div></div></div><p>
			Each instance of an Esper engine is completely independent of other engine instances and has its own administrative and runtime interface.
        </p><p>
			An instance of the Esper engine is obtained via static methods on the <tt class="literal">EPServiceProviderManager</tt> class.
			The <tt class="literal">getDefaultProvider</tt> method and the <tt class="literal">getProvider(String URI)</tt> methods return an instance of the Esper engine.
			The latter can be used to obtain multiple instances of the engine for different URI values. The <tt class="literal">EPServiceProviderManager</tt>
			determines if the URI matches all prior URI values and returns the same engine instance for the same URI value. If the URI has not been seen before, it creates a new engine instance.
        </p><p>
			The code snipped below gets the default instance Esper engine. Subsequent calls to get the default engine instance return the same instance.
        </p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();</pre><p>
			This code snippet gets an Esper engine for URI <tt class="literal">RFIDProcessor1</tt>. Subsequent calls to get an engine with the same URI return the same instance.
        </p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getProvider("RFIDProcessor1");</pre><p>
			An existing Esper engine instance can be reset via the <tt class="literal">initialize</tt> method on the <tt class="literal">EPServiceProvider</tt> instance. This stops and removes all statements in the Engine.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-administrative"></a>3.3.&nbsp;The Administrative Interface</h2></div></div><div></div></div><p>
			Create event pattern expression and EQL statements via the administrative interface <tt class="literal">EPAdministrator</tt>.
        </p><p>
			This code snippet gets an Esper engine then creates an event pattern and an EQL statement.
        </p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPAdministrator admin = epService.getEPAdministrator();

EPStatement 10secRecurTrigger = admin.createPattern(
  "every timer:at(*, *, *, *, *, */10)");

EPStatement countStmt = admin.createEQL(
  "select count(*) from MarketDataBean.win:time(60 sec)");
</pre><p>
			Note that event pattern expressions can also occur within EQL statements. This is outlined in more detail in <a href="EQL.html#eql-from-clause-patterns" title="6.4.2.&nbsp;Pattern-based event streams">Section&nbsp;6.4.2, &#8220;Pattern-based event streams&#8221;</a>.
        </p><p>
			The <tt class="literal">createPattern</tt> and <tt class="literal">createEQL</tt> methods return <tt class="literal">EPStatement</tt> instances. Statements are automatically started and active when created. A statement can also be stopped and started again via the <tt class="literal">stop</tt> and <tt class="literal">start</tt> methods shown in the code snippet below.
        </p><pre class="programlisting">countStmt.stop();
countStmt.start();
</pre><p>
			We can subscribe to updates posted by a statement via the <tt class="literal">addListener</tt> and <tt class="literal">removeListener</tt> methods the <tt class="literal">EPStatement</tt>  statement. We need to provide an implementation of the <tt class="literal">UpdateListener</tt> interface to the statement.
        </p><pre class="programlisting">UpdateListener myListener = new MyUpdateListener();
countStmt.addListener(myListener);
</pre><p>			
			EQL statements and event patterns publish old data and new data to registered <tt class="literal">UpdateListener</tt> listeners. 
			New data published by statements is the events representing the new values of derived data held by the statement.
			Old data published by statements constists of the events representing the prior values of derived data held by the statement.
		</p><p>
			Subscribing to events posted by a statement is following a push model. The engine pushes data to listeners when events are received that cause data to change or patterns to match. Alternatively, statements can also serve up data in a pull model via the <tt class="literal">iterator</tt> method. This can come in handy if we are not interested in all new updates, but only want to perform a frequent poll for the latest data. For example, an event pattern that fires every 5 seconds could be used to pull data from an EQL statement. The code snippet below demonstrates some pull code.			
        </p><pre class="programlisting">Iterator&lt;EventBean&gt; eventIter = countStmt.iterator();
for (EventBean event : eventIter) {
   // .. do something ..
}
</pre><p>
			This is a second example:
        </p><pre class="programlisting">double averagePrice = (Double) eqlStatement.iterator().next().get("average");</pre><p>
			Esper places the following restrictions on the pull API and usage of the <tt class="literal">iterator</tt> method:
		</p><div class="orderedlist"><ol type="1" compact><li><p>
					EQL statements joining multiple event streams do not support the pull API 
				</p></li></ol></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-runtime"></a>3.4.&nbsp;The Runtime Interface</h2></div></div><div></div></div><p>
			The <tt class="literal">EPRuntime</tt> interface is used to send events for processing into an Esper engine, and to emit Events from an engine instance to the outside world.
        </p><p>
			The below code snippet shows how to send a Java object event to the engine. Note that the <tt class="literal">sendEvent</tt> method is overloaded. As events can take on different representation classes in Java, the <tt class="literal">sendEvent</tt> takes parameters to reflect the different 
			types of events that can be send into the engine. The <a href="event_representation.html" title="Chapter&nbsp;4.&nbsp;Event Representations">Chapter&nbsp;4, <i>Event Representations</i></a> section explains the types of events 
			accepted.
        </p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPRuntime runtime = epService.getEPRuntime();

// Send an example event containing stock market data
runtime.sendEvent(new MarketDataBean('IBM', 75.0));		
</pre><p>
			Another important method in the runtime interface is the <tt class="literal">route</tt> method. This method is designed for use by <tt class="literal">UpdateListener</tt> implementations that
			need to send events into an engine instance.
        </p><p>
			The <tt class="literal">emit</tt> and <tt class="literal">addEmittedListener</tt> methods can be used to emit events from a runtime to a registered set of one or more emitted event listeners. 
			This mechanism is available as a service to enable channel-based publish-subscribe of events emitted from an engine instance via the <tt class="literal">emit</tt> method. Emitting events is not integrated with EQL and is available only via the <tt class="literal">EPRuntime</tt> interface.
			Events are emitted on an event channel identified by a name. Listeners are implementations of the <tt class="literal">EmittedListener</tt> interface. Via the <tt class="literal">addEmittedListener</tt> method a listener can be added to the specified event channel. The lister receives only those events posted to that channel. The channel parameter to <tt class="literal">addEmittedListener</tt> also allows null values. If a null channel value is specified, the listeners receives emitted events posted on any channel.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-controlling-time"></a>3.5.&nbsp;Time-Keeping Events</h2></div></div><div></div></div><p>
			Special events are provided that can be used to control the time-keeping of an engine instance. There are two models for an engine to keep track of time.
			Internal clocking is when the engine instance relies on the <tt class="literal">java.util.Timer</tt> class for time tick events. External clocking can be used to supply time ticks to the engine. The latter is useful for testing time-based event sequences or for synchronizing the engine with an external time source.
        </p><p>
			By default, the Esper engine uses internal time ticks. This behavior can be changed by sending a timer control event to the engine as shown below.
        </p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPRuntime runtime = epService.getEPRuntime();
// switch to external clocking
runtime.sendEvent(new TimerControlEvent(TimerControlEvent.ClockType.CLOCK_EXTERNAL));

// send a time tick
long timeInMillis = System.currentTimeMillis();	// Or get the time somewhere else
runtime.sendEvent(new CurrentTimeEvent(timeInMillis));
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-events-received"></a>3.6.&nbsp;Events Received from the Engine</h2></div></div><div></div></div><p>
			The Esper engine posts events to registered <tt class="literal">UpdateListener</tt> instances ('push' method for receiving events). For many statements events can also be pulled from statements via the <tt class="literal">iterator</tt> method. Both pull and push supply <tt class="literal">EventBean</tt> instances representing the events generated by the engine or events supplied to the engine. Each <tt class="literal">EventBean</tt> instance represents an event, with each event being either an artificial event, composite event or an event supplied to the engine via its runtime interface.
        </p><p>
			The <tt class="literal">getEventType</tt> method supplies an event's event type information represented by an <tt class="literal">EventType</tt> instance. The <tt class="literal">EventType</tt> supplies event property names and types as well as information about the underlying object to the event.
        </p><p>
			The engine may generate artificial events that contain information derived from event streams. A typical example for artificial events is the events posted for a statement to calculate univariate statistics on an event property. The below example shows such a statement and queries the generated events for an average value.
        </p><pre class="programlisting">// Derive univariate statistics on price for the last 100 market data events
String stmt = "select * from MarketDataBean(symbol='IBM').win:length(100).stat:uni('price')";
EPStatement priceStatsView = epService.getEPAdministrator().createEQL(stmt);
priceStatsView.addListener(testListener);
</pre><pre class="programlisting">// Example listener code
public class MyUpdateListener implements UpdateListener
{
    public void update(EventBean[] newData, EventBean[] oldData)
    {
        // Interrogate events
        System.out.println("new average price=" + newData[0].get("average");
	}
}
</pre><p>
			Composite events are events that aggregate one or more other events. Composite events are typically created by the engine for statements that join two event streams, and for event patterns in which the causal events are retained and reported in a composite event. The example below shows such an event pattern.
        </p><pre class="programlisting">// Look for a pattern where AEvent follows BEvent
String pattern = "a=AEvent -&gt; b=BEvent";
EPStatement stmt = epService.getEPAdministrator().createPattern(pattern);
stmt.addListener(testListener);
</pre><pre class="programlisting">// Example listener code
public class MyUpdateListener implements UpdateListener
{
    public void update(EventBean[] newData, EventBean[] oldData)
    {
        System.out.println("a event=" + newData[0].get("a").getUnderlying());
        System.out.println("b event=" + newData[0].get("b").getUnderlying());
	}
}
</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="configuration.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="event_representation.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;2.&nbsp;Configuration&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;4.&nbsp;Event Representations</td></tr></table></div></body></html>