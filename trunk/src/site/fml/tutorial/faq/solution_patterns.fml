<?xml version="1.0"?>
<faqs id="Solution-Patterns" title="Solution Patterns">

  <part id="general">
  	<title>General</title>
  	
    <faq id="throughput-1">
      <question>How do I measure the rate of arrival of events in a given time period?</question>
      <answer>
        <p>
          The time batch window of 1 second as shown below produces an event each second with the count of the number of events
          in the batch.
        </p>
	<div class="source"><pre>select count(*) as cnt from MarketDataEvent.win:time_batch(1)</pre></div>      
      </answer>
    </faq>    

    <faq id="throughput-2">
      <question>How do I measure the rate of arrival of events in a given time period per another category?</question>
      <answer>
        <p>
          We can solve this problem by grouping the events in the window per the category. The below example uses 'feed' as the category.
        </p>
	<div class="source"><pre>select feed, count(*) as cnt from MarketDataEvent.win:time_batch(1) group by feed</pre></div>      
      </answer>
    </faq>    
    
    <faq id="correlate">
      <question>How do I correlate events arriving in 2 or more streams?</question>
      <answer>
        <p>
          The join of event streams looks very similar to joins in SQL. To bind data in the streams together, across streams, 
          we identify keys to join on. 
        </p>
        <p>
          The below example specifies the 'accountNumber' field as the only join key. In this example we hold the last
          30 seconds of events for each stream.
        </p>
	<div class="source"><pre>select fraud.accountNumber as accntNum, withdraw.amount as amount         
from FraudWarningEvent.win:time(30) as fraud,
     WithdrawalEvent.win:time(30) as withdraw
where fraud.accountNumber = withdraw.accountNumber</pre></div>      
      </answer>
    </faq>    

    <faq id="missing">
      <question>How do I find missing events arriving in 2 or more streams that are correlated?</question>
      <answer>
        <p>
          As in SQL we can use outer joins to generate a result even if one or more of the correlated events are not 
          found in a stream. Usually we want to generate the result after a certain time or after a
          certain number of events have been received, indicating that a correlated event is truely missing.          
        </p>
        <p>
	  In this example we are looking for a withdrawal event without a login event for the same account number after 60 seconds.
        </p>
        <p>
	  We join withdrawal events with login events looking for login events that do not exist (account number is null).
	  We want to get notified as these events leave the 60-second time window.
        </p>
	<div class="source"><pre>select withdraw.accountNumber as accntNum, withdraw.amount as amount         
from WithdrawalEvent.win:time(60) as withdraw
     left outer join
     LoginEvent.win:time(60) as login
on fraud.accountNumber = withdraw.accountNumber
where login.accountNumber = null</pre></div>      
      </answer>
    </faq>    

    <faq id="window-per-category">
      <question>How do I keep a separate window of events per category and compute aggregates for each category's window?</question>
      <answer>
        <p>
          I have one or more categories and for each of these categories I need to keep a separate window of events.
        </p>
        <p>
          In the statement below we have stock tick events for which we want to compute the average price of the last 10 
          stock tick events per symbol. Notice we are not using the last 10 events overall, we are looking at the last 10 events per symbol.
        </p>
	<div class="source"><pre>select symbol, avg(price) as avgPrice from StockTick.std:groupby('symbol').win:length(10)</pre></div>      
        <p>
          We can also specify multiple categories:
        </p>
	<div class="source"><pre>select symbol, location, avg(price) as avgPrice from StockTick.std:groupby({'symbol','location'}).win:length(10)</pre></div>
      </answer>
    </faq>    

    <faq id="stagger-statements">
      <question>How do I use results of one statement in another statement?</question>
      <answer>
        <p>
          Use the <em>insert into</em> syntax to use the events generated by one statement as input to another statement.
        </p>
        <p>
          We can first compute the number of events arriving within 1 second, then use that number to perform additional 
          aggregation. Here we compute for the last 30 seconds the maximum and minimum rate per feed.
        </p>

	<div class="source"><pre>insert into TicksPerSecond select feed, count(*) as cnt from MarketDataEvent.win:time_batch(1) group by feed
	
select feed, max(cnt) as maxCount, min(cnt) as minCount from TicksPerSecond.win:time(30) group by feed</pre></div>
      </answer>
    </faq>    

    <faq id="throughput-3">
      <question>How do I reduce the rate of event output by my statement? How do I get frequent but not continuous results?</question>
      <answer>
        <p>
          Use output rate limiting to stabilize or reduce the rate at which rows are output from a query, by outputting rows
          at a specified time or row-based interval.
        </p>
        <p>
          The example below limits the otherwise continuous output to an output row every 5 seconds. The output contains 
          the feed and average volume per feed of the last 60 seconds of market data events.
        </p>
	<div class="source"><pre>select feed, avg(volume) as cnt from MarketDataEvent.win:time(60) group by feed output every 5 seconds</pre></div>      
      </answer>
    </faq>    

  </part>

</faqs>
