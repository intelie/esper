package net.esper.eql.parse;

import net.esper.pattern.*;
import net.esper.filter.FilterSpec;
import net.esper.eql.generated.EQLBaseWalker;
import net.esper.event.EventType;
import net.esper.event.EventAdapterService;
import net.esper.pattern.guard.GuardEnum;
import net.esper.pattern.guard.GuardFactory;
import net.esper.pattern.observer.ObserverFactory;
import net.esper.pattern.observer.ObserverEnum;
import net.esper.util.ConstructorHelper;
import net.esper.event.EventAdapterService;
import antlr.collections.AST;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.beanutils.ConstructorUtils;

import java.util.*;

/**
 * Called during the walks of a pattern expression AST tree as specified in the grammar file.
 * Constructs a pattern evaluation tree under a {@link EvalRootNode}.
 * Keeps track of event types generated by pattern.
 */
public class EQLPatternTreeWalker extends EQLBaseWalker
{
    private final EventAdapterService eventAdapterService;
    private final EvalRootNode rootNode;
    private final Map<AST, EvalNode> astNodeMap;
    private final Map<String, EventType> taggedEventTypes;       // Stores types for filters with tags

    /**
     * Ctor.
     * @param eventAdapterService for resolving event names
     */
    public EQLPatternTreeWalker(EventAdapterService eventAdapterService)
    {
        this.eventAdapterService = eventAdapterService;
        rootNode = new EvalRootNode();
        taggedEventTypes = new HashMap<String, EventType>();
        astNodeMap = new HashMap<AST, EvalNode>();
    }

    /**
     * Returns root node of pattern eval tree.
     * @return root node.
     */
    public EvalRootNode getRootNode()
    {
        return rootNode;
    }

    /**
     * Returns event trypes, if any, as specified as part of filters used in pattern.
     * @return event types and the name for each event
     */
    public Map<String, EventType> getTaggedEventTypes()
    {
        return taggedEventTypes;
    }

    protected void end() throws ASTWalkException
    {
        if (astNodeMap.size() != 1)
        {
            throw new ASTWalkException("Unexpected AST tree contains more then 1 child element for root");
        }

        // Just add the single entry not consumed yet
        rootNode.addChildNode(astNodeMap.values().iterator().next());
    }

    protected void leaveNode(AST node) throws ASTWalkException
    {
        if (log.isDebugEnabled())
        {
            log.debug(".leaveNode " + node);
        }

        switch (node.getType())
        {
            case EVERY_EXPR:
                leaveEvery(node);
                break;
            case NOT_EXPR:
                leaveNot(node);
                break;
            case FOLLOWED_BY_EXPR:
                leaveFollowedBy(node);
                break;
            case OR_EXPR:
                leaveOr(node);
                break;
            case AND_EXPR:
                leaveAnd(node);
                break;
            case EVENT_FILTER_EXPR:
                leaveFilter(node);
                break;
            case GUARD_EXPR:
                leaveGuard(node);
                break;
            case OBSERVER_EXPR:
                leaveObserver(node);
                break;
            case EVENT_PROP_EXPR:
                // need not be handled, part of filter specification
                break;
            default:
                throw new ASTWalkException("Unhandled node type encountered, type '" + node.getType() +
                        "' with text '" + node.getText() + "'");
        }

        // For each AST child node of this AST node that generated an EvalNode add the EvalNode as a child
        EvalNode thisEvalNode = astNodeMap.get(node);

        AST childNode = node.getFirstChild();
        do {
            EvalNode childEvalNode = astNodeMap.get(childNode);
            if (childEvalNode != null)
            {
                thisEvalNode.addChildNode(childEvalNode);
                astNodeMap.remove(childNode);
            }
            childNode = childNode.getNextSibling();
        }
        while (childNode != null);
    }

    private void leaveEvery(AST node)
    {
        log.debug(".leaveEvery");
        EvalEveryNode everyNode = new EvalEveryNode();
        astNodeMap.put(node, everyNode);
    }

    private void leaveFilter(AST node)
    {
        log.debug(".leaveFilter");
        FilterSpec spec = ASTFilterSpecHelper.buildSpec(node, taggedEventTypes, eventAdapterService);
        String optionalTag = ASTFilterSpecHelper.getEventNameTag(node);
        EvalFilterNode filterNode = new EvalFilterNode(spec, optionalTag);
        EventType eventType = spec.getEventType();

        if (optionalTag != null)
        {
            EventType existingType = taggedEventTypes.get(optionalTag);
            if ((existingType != null) && (existingType != eventType))
            {
                throw new IllegalArgumentException("Tag '" + optionalTag + "' for event type " + eventType.getUnderlyingType().getName() +
                        " has already been used for events of type " + existingType.getUnderlyingType().getName());
            }
            taggedEventTypes.put(optionalTag, eventType);
        }

        astNodeMap.put(node, filterNode);
    }

    private void leaveFollowedBy(AST node)
    {
        log.debug(".leaveFollowedBy");
        EvalFollowedByNode fbNode = new EvalFollowedByNode();
        astNodeMap.put(node, fbNode);
    }

    private void leaveAnd(AST node)
    {
        log.debug(".leaveAnd");
        EvalAndNode andNode = new EvalAndNode();
        astNodeMap.put(node, andNode);
    }

    private void leaveOr(AST node)
    {
        log.debug(".leaveOr");
        EvalOrNode orNode = new EvalOrNode();
        astNodeMap.put(node, orNode);
    }

    private void leaveNot(AST node)
    {
        log.debug(".leaveNot");
        EvalNotNode notNode = new EvalNotNode();
        astNodeMap.put(node, notNode);
    }

    private void leaveGuard(AST node) throws ASTWalkException
    {
        log.debug(".leaveGuard");

        // Get the object information from AST
        AST startGuard = node.getFirstChild().getNextSibling();
        String objectNamespace = startGuard.getText();
        String objectName = startGuard.getNextSibling().getText();

        List<Object> objectParams = new LinkedList<Object>();

        AST child = startGuard.getNextSibling().getNextSibling();
        while (child != null)
        {
            Object object = ASTParameterHelper.makeParameter(child);
            objectParams.add(object);
            child = child.getNextSibling();
        }

        // From object name construct guard factory
        GuardEnum guardEnum = GuardEnum.forName(objectNamespace, objectName);
        if (guardEnum == null)
        {
            throw new ASTWalkException("Guard in namespace " + objectNamespace + " and name " + objectName +
                    " is not a known guard");
        }

        GuardFactory guardFactory = null;
        try
        {
            guardFactory = (GuardFactory) ConstructorUtils.invokeConstructor(guardEnum.getClazz(), objectParams.toArray());

            if (log.isDebugEnabled())
            {
                log.debug(".create Successfully instantiated guard");
            }
        }
        catch (Exception e)
        {
            String message = "Error invoking constructor for guard '" + objectName;
            message += "', invalid parameter list for the object";
            log.fatal(".leaveObserver " + message, e);
            throw new ASTWalkException(message);
        }

        EvalGuardNode guardNode = new EvalGuardNode(guardFactory);
        astNodeMap.put(node, guardNode);
    }

    private void leaveObserver(AST node) throws ASTWalkException
    {
        log.debug(".leaveObserver");

        // Get the object information from AST
        String objectNamespace = node.getFirstChild().getText();
        String objectName = node.getFirstChild().getNextSibling().getText();

        int numNodes = node.getNumberOfChildren();
        Object[] observerParameters = new Object[numNodes - 2];

        AST child = node.getFirstChild().getNextSibling().getNextSibling();
        int index = 0;
        while (child != null)
        {
            Object object = ASTParameterHelper.makeParameter(child);
            observerParameters[index++] = object;
            child = child.getNextSibling();
        }

        // From object name construct observer factory
        ObserverEnum observerEnum = ObserverEnum.forName(objectNamespace, objectName);
        if (observerEnum == null)
        {
            throw new ASTWalkException("EventObserver in namespace " + objectNamespace + " and name " + objectName +
                    " is not a known observer");
        }

        ObserverFactory observerFactory = null;
        try
        {
            Object obsFactory = ConstructorHelper.invokeConstructor(observerEnum.getClazz(), observerParameters);
            observerFactory = (ObserverFactory) obsFactory; 

            if (log.isDebugEnabled())
            {
                log.debug(".create Successfully instantiated observer");
            }
        }
        catch (Exception e)
        {
            String message = "Error invoking constructor for observer '" + objectNamespace + ":" + objectName;
            message += "', invalid parameter list for the object";
            log.fatal(".leaveObserver " + message, e);
            throw new ASTWalkException(message);
        }

        EvalObserverNode observerNode = new EvalObserverNode(observerFactory);
        astNodeMap.put(node, observerNode);
    }

    private static final Log log = LogFactory.getLog(EQLPatternTreeWalker.class);
}
