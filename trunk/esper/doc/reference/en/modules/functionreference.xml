<chapter id="functionreference">
    <title>EPL Reference: Functions</title>
        
	<sect1 id="epl-single-row-function-ref">
		<title>Single-row Function Reference</title>
		
		<para>
			Single-row functions return a single value for every single result row generated by your statement. These functions can appear anywhere where expressions are allowed.
		</para>

		<indexterm><primary>user-defined single-row function</primary></indexterm>
		<indexterm><primary>functions</primary><secondary>user-defined</secondary></indexterm>
		<indexterm><primary>static Java methods</primary></indexterm>
		<para>
			Esper allows static Java library methods as single-row functions, and also features built-in single-row functions. In addition, Esper allows instance method invocations on named streams.
		</para>
			
		<para>
			Esper auto-imports the following Java library packages:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
					java.lang.*
				</para>
			</listitem>
			<listitem>
				<para>
					java.math.*
				</para>
			</listitem>
			<listitem>
				<para>
					java.text.*
				</para>
			</listitem>
			<listitem>
				<para>
					java.util.*
				</para>
			</listitem>
		</itemizedlist>

		<para>
			Thus Java static library methods can be used in all expressions as shown in below example:
		</para>

		<programlisting>select symbol, Math.round(volume/1000)
from StockTickEvent.win:time(30 sec)</programlisting>
			
		<para>
			In general, arbitrary Java class names have to be fully qualified (e.g. java.lang.Math) but Esper provides a mechanism 
for user-controlled imports of classes and packages as outlined in <xref linkend="config-class--package-imports"/>.
		</para>

		<para>
			The below table outlines the built-in single-row functions available.
		</para>

		<table frame="topbot" id="epl-single-row-func" revision="2">
			<title>Syntax and results of single-row functions</title>
			<tgroup cols="2">
				<colspec colwidth="2.0*"/>
				<colspec colwidth="1.5*"/>
				<thead>
					<row>
						<entry>Single-row Function</entry>
						<entry>Result</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry><synopsis>case <emphasis>value</emphasis> 
  when <emphasis>compare_value</emphasis> then <emphasis>result</emphasis>
  [when <emphasis>compare_value</emphasis> then <emphasis>result</emphasis> ...] 
  [else <emphasis>result</emphasis>] 
  end </synopsis></entry>
						<entry>
							<para>
								Returns <literal>result</literal> where the first <literal>value</literal> equals <literal>compare_value</literal>. 
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>case 
  when <emphasis>condition</emphasis> then <emphasis>result</emphasis>
  [when <emphasis>condition</emphasis> then <emphasis>result</emphasis> ...] 
  [else <emphasis>result</emphasis>] 
  end</synopsis></entry>
						<entry>
							<para>
								Returns the <literal>result</literal> for the first condition that is true.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>cast(<emphasis>expression</emphasis>, <emphasis>type_name</emphasis>)</synopsis></entry>
						<entry>
							<para>
								Casts the result of an expression to the given type. 
							</para>
						</entry>
					</row>
					<row>
					  <entry><synopsis>coalesce(<emphasis>expression</emphasis>, <emphasis>expression</emphasis> [, <emphasis>expression</emphasis> ...])</synopsis></entry>
						<entry>
							<para>
								Returns the first non-<literal>null</literal> value in the list, or <literal>null</literal> if there are no non-<literal>null</literal> values.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>current_timestamp[()]</synopsis></entry>
						<entry>
							<para>
								Returns the current engine time as a <literal>long</literal> millisecond value. Reserved keyword with optional parenthesis.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>exists(<emphasis>dynamic_property_name</emphasis>)</synopsis></entry>
						<entry>
							<para>
								Returns true if the dynamic property exists for the event, or false if the property does not exist.
							</para>
						</entry>
					</row>
					<row>
					  <entry><synopsis>instanceof(<emphasis>expression</emphasis>, <emphasis>type_name</emphasis> [, <emphasis>type_name</emphasis> ...])</synopsis></entry>
						<entry>
							<para>
								Returns true if the expression returns an object whose type is one of the types listed.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>max(<emphasis>expression</emphasis>, <emphasis>expression</emphasis> [, <emphasis>expression</emphasis> ...])</synopsis></entry>
						<entry>
							<para>
								Returns the highest numeric value among the 2 or more comma-separated expressions.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>min(<emphasis>expression</emphasis>, <emphasis>expression</emphasis> [, <emphasis>expression</emphasis> ...])</synopsis></entry>
						<entry>
							<para>
								Returns the lowest numeric value among the 2 or more comma-separated expressions.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>prev(<emphasis>expression</emphasis>, <emphasis>event_property)</emphasis></synopsis></entry>
						<entry>
							<para>
								Returns a property value of a previous event, relative to the event order within a data window 
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>prior(<emphasis>integer</emphasis>, <emphasis>event_property)</emphasis></synopsis></entry>
						<entry>
							<para>
								Returns a property value of a prior event, relative to the natural order of arrival of events
							</para>
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>

		<sect2 id="epl-single-row-function-ref-case">
			<title>The <literal>Case</literal> Control Flow Function</title>

			<indexterm><primary>case control flow function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>case control flow</secondary></indexterm>
			<para>
				The <literal>case</literal> control flow function has two versions. The first version takes a value and a list of compare values to compare against, and returns the result where the first value equals the compare value. The second version takes a list of conditions and returns the result for the first condition that is true.
			</para>

			<para>
				The return type of a <literal>case</literal> expression is the compatible aggregated type of all return values.
			</para>
			
			<para>
				The example below shows the first version of a <literal>case</literal> statement. It has a <literal>String</literal> return type and returns the value 'one'.
			</para>
			<programlisting>select case 1 when 1 then 'one' when 2 then 'two' else 'more' end from ...</programlisting>
				
			<para>
				The second version of the <literal>case</literal> function takes a list of conditions. The next example has a <literal>Boolean</literal> return type and returns the boolean value true.
			</para>				
			<programlisting>select case when 1>0 then true else false end from ...</programlisting>
		</sect2>
		

		<sect2 id="epl-single-row-function-cast">
			<title>The <literal>Cast</literal> Function</title>

			<indexterm><primary>cast function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>cast</secondary></indexterm>
			<para>
				The <literal>cast</literal> function casts the return type of an expression to a designated type. The function accepts two parameters: The first parameter is the property name or expression that returns the 
				value to be casted. The second parameter is the type to cast to.
			</para>

			<para>
				Valid parameters for the second (type) parameter are:
			</para>
	
			<itemizedlist>
				<listitem>
					<para>
						Any of the Java built-in types: <literal>int, long, byte, short, char, double, float, string, BigInteger, BigDecimal</literal>, where <literal>string</literal>  is a short notation for <literal>java.lang.String</literal> and <literal>BigInteger</literal> as well as <literal>BigDecimal</literal> are the classes in <literal>java.math</literal>. The type name is not case-sensitive. For example:
						<synopsis>cast(price, double)</synopsis>
					</para>
				</listitem>
				<listitem>
					<para>
						The fully-qualified class name of the class to cast to, for example: <synopsis>cast(product, org.myproducer.Product)</synopsis>
					</para>
				</listitem>
			</itemizedlist>

			<para>
				The <literal>cast</literal> function is often used to provide a type for dynamic (unchecked) properties. Dynamic properties are properties whose type is not known at compile type. 
				These properties are always of type <literal>java.lang.Object</literal>. 
			</para>
			
			<para>
				The <literal>cast</literal> function as shown in the next statement casts the dynamic "price" property of an "item" in the OrderEvent to a double value.
			</para>
			<programlisting><![CDATA[select cast(item.price?, double) from OrderEvent]]></programlisting>

			<para>
				The <literal>cast</literal> function returns a <literal>null</literal> value if the expression result cannot be casted to the desired type, or if the expression result itself is <literal>null</literal>.
			</para>

			<para>
				The <literal>cast</literal> function adheres to the following type conversion rules:
			</para>

			<itemizedlist>
				<listitem>
					<para>
						For all numeric types, the <literal>cast</literal> function utilitzes <literal>java.lang.Number</literal> to convert numeric types, if required. 
					</para>
				</listitem>
				<listitem>
					<para>
						For casts to <literal>string</literal> or <literal>java.lang.String</literal>, the function calls <literal>toString</literal> on the expression result.
					</para>
				</listitem>
				<listitem>
					<para>
						For casts to other objects including application objects, the <literal>cast</literal> function considers a Java class's superclasses as well as all directly or indirectly-implemented interfaces by superclasses .
					</para>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="epl-single-row-function-ref-coalesce">
			<title>The <literal>Coalesce</literal> Function</title>

			<indexterm><primary>coalesce function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>coalesce</secondary></indexterm>
			<para>
				The result of the <literal>coalesce</literal> function is the first expression in a list of expressions that returns a non-null value. The return type is the compatible aggregated type of all return values.
			</para>
			
			<para>
				This example returns a String-typed result of value 'foo':
			</para>
			<programlisting>select coalesce(null, 'foo') from ...</programlisting>			
		</sect2>

		<sect2 id="epl-single-row-function-ref-currenttime">
			<title>The <literal>Current_Timestamp</literal> Function</title>

			<indexterm><primary>current_timestamp function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>current_timestamp</secondary></indexterm>
			<para>
				The <literal>current_timestamp</literal> function is a reserved keyword and requires no parameters. The result of the <literal>current_timestamp</literal> function is the <literal>long</literal>-type millisecond value of the current engine system time.
			</para>
			
			<para>
				The function returns the current engine timestamp at the time of expression evaluation. When using external-timer events, the function provides the last value of the externally-supplied time at the time of expression evaluation.
			</para>

			<para>
				This example selects the current engine time:
			</para>
			<programlisting><![CDATA[select current_timestamp from MyEvent
// equivalent to
select current_timestamp() from MyEvent]]></programlisting>
		</sect2>

		<sect2 id="epl-single-row-function-exists">
			<title>The <literal>Exists</literal> Function</title>

			<indexterm><primary>exists function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>exists</secondary></indexterm>
			<para>
				The <literal>exists</literal> function returns a boolean value indicating whether the dynamic property, provided as a parameter to the function, exists on the event. The <literal>exists</literal> function accepts a single dynamic property name as its only parameter. 
			</para>

			<para>
				The <literal>exists</literal> function is for use with dynamic (unchecked) properties. Dynamic properties are properties whose type is not known at compile type. Dynamic properties return a null value
				if the dynamic property does not exists on an event, or if the dynamic property exists but the value of the dynamic property is null. 
			</para>
			
			<para>
				The <literal>exists</literal> function as shown next returns true if the "item" property contains an object that has a "serviceName" property. It returns false if the "item" property is null, or if the "item" property does not 
				contain an object that has a property named "serviceName" :
			</para>
			<programlisting><![CDATA[select exists(item.serviceName?) from OrderEvent]]></programlisting> 
		</sect2>

		<sect2 id="epl-single-row-function-instanceof">
			<title>The <literal>Instance-Of</literal> Function</title>

			<indexterm><primary>instance-of function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>instance-of</secondary></indexterm>
			<para>
				The <literal>instanceof</literal> function returns a boolean value indicating whether the type of value returned by the expression is one of the given types. The first parameter to the <literal>instanceof</literal> function is an expression to evaluate. The second and subsequent parameters are Java type names.
			</para>

			<para>
				The function determines the return type of the expression at runtime by evaluating the expression, and compares the type of object returned by the expression to the defined types. 
				If the type of object returned by the expression matches any of the given types, the function returns <literal>true</literal>. If the expression returned <literal>null</literal> or a type that does not
				match any of the given types, the function returns <literal>false</literal>.
			</para>

			<para>
				The <literal>instanceof</literal> function is often used in conjunction with dynamic (unchecked) properties. Dynamic properties are properties whose type is not known at compile type. 
			</para>

			<para>
				This example uses the <literal>instanceof</literal> function to select different properties based on the type:
			</para>
			<programlisting>select case when instanceof(item, com.mycompany.Service) then serviceName?
  when instanceof(item, com.mycompany.Product) then productName? end 
  from OrderEvent</programlisting>

			<para>
				The <literal>instanceof</literal> function returns <literal>false</literal> if the expression tested by instanceof returned null.
			</para>

			<para>
				Valid parameters for the type parameter list are:
			</para>
	
			<itemizedlist>
				<listitem>
					<para>
						Any of the Java built-in types: <literal>int, long, byte, short, char, double, float, string</literal>, where <literal>string</literal>  is a short notation for <literal>java.lang.String</literal>. The type name is not case-sensitive. For example, the next function tests if the dynamic "price" property is either of type float or type double:
						<synopsis>instanceof(price?, double, float)</synopsis>
					</para>
				</listitem>
				<listitem>
					<para>
						The fully-qualified class name of the class to cast to, for example: <synopsis>instanceof(product, org.myproducer.Product)</synopsis>
					</para>
				</listitem>
			</itemizedlist>
			
			<para>
				The function considers an event class's superclasses as well as all the directly or indirectly-implemented interfaces by superclasses.
			</para>
		</sect2>

		<sect2 id="epl-single-row-function-ref-minmax">
			<title>The <literal>Min</literal> and <literal>Max</literal> Functions</title>

			<indexterm><primary>min function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>min</secondary></indexterm>
			<indexterm><primary>max function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>max</secondary></indexterm>
			<para>
				The <literal>min</literal> and <literal>max</literal> function take two or more parameters that itself can be expressions. The <literal>min</literal> function returns the lowest numeric value among the 2 or more comma-separated expressions, while the <literal>max</literal> function returns the highest numeric value.
				The return type is the compatible aggregated type of all return values.
			</para>

			<para>
				The next example shows the <literal>max</literal> function that has a <literal>Double</literal> return type and returns the value 1.1.
			</para>
			<programlisting>select max(1, 1.1, 2 * 0.5) from ...</programlisting>

			<para>
				The <literal>min</literal> function returns the lowest value. The statement below uses the function to determine the smaller of two timestamp values.
			</para>
	
			<programlisting>select symbol, min(ticks.timestamp, news.timestamp) as minT
	from StockTickEvent.win:time(30 sec) as ticks, NewsEvent.win:time(30 sec) as news
	where ticks.symbol = news.symbol</programlisting>
		</sect2>

		<sect2 id="epl-single-row-function-ref-previous">
			<title>The <literal>Previous</literal> Function</title>

			<indexterm><primary>previous function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>previous</secondary></indexterm>
			<para>
				The <literal>prev</literal> function returns the property value of a previous event. The first parameter denotes the i-th previous event in the order established by the data window. 
				The second parameter is a property name for which the function returns the value for the previous event.
			</para>

			<para>
				This example selects the value of the <literal>price</literal> property of the 2nd-previous event from the current Trade event.
			</para>
			<programlisting>select prev(2, price) from Trade.win:length(10)</programlisting>

			<para>
				Since the <literal>prev</literal> function takes the order established by the data window into account, the function works well with sorted windows. In the following example the statement
				selects the symbol of the 3 Trade events that had the largest, second-largest and third-largest volume.
			</para>
			<programlisting>select prev(0, symbol), prev(1, symbol), prev(2, symbol)
  from Trade.ext:sort(volume, true, 10)</programlisting>

			<para>
				The i-th previous event parameter can also be an expression returning an Integer-type value. The next statement joins the Trade data window with an <literal>RankSelectionEvent</literal> event that provides a <literal>rank</literal> property used to look up a certain position in the sorted Trade data window:
			</para>
			<programlisting>select prev(rank, symbol) from Trade.ext:sort(volume, true, 10), RankSelectionEvent</programlisting>

			<para>
				And the expression <literal>count(*) - 1</literal> allows us to select the oldest event in the length window:
			</para>
			<programlisting>select prev(count(*) - 1, price) from Trade.win:length(100)</programlisting>

			<para>
				The <literal>prev</literal> function returns a <literal>null</literal> value if the data window does not currently hold the i-th previous event. The example below illustrates this using a time batch window. Here the <literal>prev</literal>  
				function returns a null value for any events in which the previous event is not in the same batch of events. Note that the <literal>prior</literal> function as discussed below can be used if a null value is not the desired result.
			</para>
			<programlisting>select prev(1, symbol) from Trade.win:time_batch(1 min)</programlisting>			

			<sect3 id="epl-single-row-function-ref-prev-group">
				<title>Previous Event per Group</title>

				<para>
					The combination of <literal>prev</literal> function and group-by view returns the property value for a previous event in the given group. 
				</para>

				<para>
					Let's look at an example. Assume we want to obtain the price of the previous event of the same symbol as the current event.
				</para>
					
				<para>
					The statement that follows solves this problem. It declares a group-by view grouping on the symbol property and a time window of 1 minute. As a result, when the engine encounters a new symbol value that it hasn't seen before, it creates a new time window specifically to hold events for that symbol. Consequently, the previous function returns the previous event within the respective time window for that event's symbol value. 
				</para>
				<programlisting>select prev(1, price) as prevPrice from Trade.std:groupby(symbol).win:time(1 min)</programlisting>

				<para>
					In a second example, assume we need to return, for each event, the current top price per symbol. We can use the <literal>prev</literal> to obtain the highest price from a sorted data window, and use the group-by view to group by symbol:
				</para>
				<programlisting>select prev(0, price) as topPricePerSymbol 
from Trade.std:groupby(symbol).ext:sort(price, false, 1)</programlisting>
			</sect3>
			
			<sect3 id="epl-single-row-function-ref-prev-restrictions">
				<title>Restrictions</title>
				<para>
						The following restrictions apply to the <literal>prev</literal> functions and its results:
				</para>
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The function always returns a <literal>null</literal> value for remove stream (old data) events
						</para>
					</listitem>
					<listitem>
						<para>
							The function requires a data window view, or a group-by and data window view, without any additional sub-views. See <xref linkend=" epl-views"/> for built-in data window views.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>

			<sect3 id="epl-single-row-function-ref-prev-prior">
				<title>Comparison to the <literal>prior</literal> Function</title>
				<para>
					The <literal>prev</literal> function is similar to the <literal>prior</literal> function. The key differences between the two functions are as follows:				 
				</para>						
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The <literal>prev</literal> function returns previous events in the order provided by the data window, while the <literal>prior</literal> function returns prior events in the order of arrival as posted by a stream's declared views.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>prev</literal> function requires a data window view while the <literal>prior</literal> function does not have any view requirements.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>prev</literal> function returns the previous event grouped by a criteria by combining the <literal>std:groupby</literal> view and a data window. The <literal>prior</literal> function returns prior events posted by the last view regardless of data window grouping.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>prev</literal> function returns a <literal>null</literal> value for remove stream events, i.e. for events leaving a data window. 
							The <literal>prior</literal> function does not have this restriction.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>
			
		</sect2>

		<sect2 id="epl-single-row-function-ref-prior">
			<title>The <literal>Prior</literal> Function</title>

			<indexterm><primary>prior function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>prior</secondary></indexterm>
			<para>
				The <literal>prior</literal> function returns the property value of a prior event. The first parameter is an integer value that denotes the i-th prior event in the natural order of arrival. 
				The second parameter is a property name for which the function returns the value for the prior event.
			</para>

			<para>
				This example selects the value of the <literal>price</literal> property of the 2nd-prior event to the current Trade event.
			</para>
			<programlisting>select prior(2, price) from Trade</programlisting>

			<para>
				The <literal>prior</literal> function can be used on any event stream or view and does not have any specific view requirements.  The function operates on the order of arrival of events by the event stream or view that provides the events.
			</para>

			<para>
				The next statement uses a time batch window to compute an average volume for 1 minute of Trade events, posting results every minute. The select-clause 
				employs the <literal>prior</literal> function to select the current average and the average before the current average:
			</para>
			<programlisting>select average, prior(1, average) 
    from TradeAverages.win:time_batch(1 min).stat:uni(volume)</programlisting>
	
		</sect2>
	</sect1>		
	
	<sect1 id="epl-function-aggregation">
		<title>Aggregate Functions</title>

		<indexterm><primary>aggregation functions</primary><secondary>overview</secondary></indexterm>
		<para>
			The syntax of the aggregation functions and the results they produce are shown in below table.
		</para>

		<table frame="topbot" id="epl-grouping-aggregate-func-table" revision="2">
			<title>Syntax and results of aggregate functions</title>
			<tgroup cols="2">
				<colspec colwidth="1*"/>
				<colspec colwidth="2.0*"/>
				<thead>
					<row>
						<entry>Aggregate Function</entry>
						<entry>Result</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>sum([all|distinct] <emphasis>expression</emphasis>)</entry>
						<entry>
							<para>
								Totals the (distinct) values in the expression, returning a value of <literal>long, double, float or integer</literal> type depending on the expression.
							</para>
						</entry>
					</row>
					<row>
						<entry>avg([all|distinct] <emphasis>expression</emphasis>)</entry>
						<entry>
							<para>
								Average of the (distinct) values in the expression, returning a value of <literal>double</literal> type.
							</para>
						</entry>
					</row>
					<row>
						<entry>count([all|distinct] <emphasis>expression</emphasis>)</entry>
						<entry>
							<para>
								Number of the (distinct) non-null values in the expression, returning a value of <literal>long</literal> type.
							</para>
						</entry>
					</row>
					<row>
						<entry>count(*)</entry>
						<entry>
							<para>
								Number of events, returning a value of <literal>long</literal> type.
							</para>
						</entry>
					</row>
					<row>
						<entry>max([all|distinct] <emphasis>expression</emphasis>)</entry>
						<entry>
							<para>
								Highest (distinct) value in the expression, returning a value of the same type as the expression itself returns.
							</para>
						</entry>
					</row>
					<row>
						<entry>min([all|distinct] <emphasis>expression</emphasis>)</entry>
						<entry>
							<para>
								Lowest (distinct) value in the expression, returning a value of the same type as the expression itself returns.
							</para>
						</entry>
					</row>
					<row>
						<entry>median([all|distinct] <emphasis>expression</emphasis>)</entry>
						<entry>
							<para>
								Median (distinct) value in the expression, returning a value of <literal>double</literal> type. Double Not-a-Number (NaN) values are ignored in the median computation.
							</para>
						</entry>
					</row>
					<row>
						<entry>stddev([all|distinct] <emphasis>expression</emphasis>)</entry>
						<entry>
							<para>
								Standard deviation of the (distinct) values in the expression, returning a value of <literal>double</literal> type.
							</para>
						</entry>
					</row>
					<row>
						<entry>avedev([all|distinct] <emphasis>expression</emphasis>)</entry>
						<entry>
							<para>
								Mean deviation of the (distinct) values in the expression, returning a value of <literal>double</literal> type.
							</para>
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>

		<para>
			Your application may also add its own aggregation function as <xref linkend="custom-aggregation-function"/> describes.
		</para>
	</sect1>		

	<sect1 id="epl-function-user-defined">
		<title>User-Defined Functions</title>
		
		<indexterm><primary>user-defined function</primary></indexterm>
		<indexterm><primary>functions</primary><secondary>user-defined</secondary></indexterm>
		<indexterm><primary>UDF</primary><secondary>user-defined function</secondary></indexterm>
		 <para>
			 A user-defined function (UDF) can be invoked anywhere as an expression itself or within an expresson. The function must simply be a public static method
			 that the classloader can resolve at statement creation time. The engine resolves the function reference at statement creation time and verifies parameter types.
		 </para>

		 <para>
			 User-defined functions can be also be invoked on instances of an event: Please see <xref linkend="epl-from-clause-stream-name"/> to invoke event instance methods on a named stream.
		 </para>

		 <para>
			 The example below assumes a class <literal>MyClass</literal> that exposes a public static method <literal>myFunction</literal> accepting 2 parameters, and
			 returing a numeric type such as <literal>double</literal>.
		 </para>
		 
<programlisting><![CDATA[select 3 * com.mycompany.MyClass.myFunction(price, volume) as myValue 
from StockTick.win:time(30 sec)]]></programlisting>

		 <para>
			 User-defined functions also take array parameters as this example shows. The section on <xref linkend="epl-operator-ref-array"/> outlines in more detail the types of arrays produced.
		 </para>		
		<programlisting><![CDATA[select * from RFIDEvent where com.mycompany.rfid.MyChecker.isInZone(zone, {10, 20, 30})]]></programlisting>

		<para>
			Java class names have to be fully qualified (e.g. java.lang.Math) but Esper provides a mechanism for user-controlled imports of classes and packages as outlined in <xref linkend="config-class--package-imports"/>.
		</para>

		 <para>
			 User-defined functions can return any value including <literal>null</literal>, Java objects or arrays. Therefore user-defined functions can serve to transform, convert or map events, or to extract information and assemble further events.
		 </para>

		 <para>
			 The following statement is a simple pattern that looks for events of type E1 that are followed by events of type E2. It assigns the tags "e1" and "e2" that the function can use to assemble a final event for output:
		 </para> 
		<programlisting><![CDATA[select MyLib.mapEvents(e1, e2) from pattern [every e1=E1 -> e2=E2]]]></programlisting>

		 <para>
			 A function that converts from one event type to another event type is shown in the next example. The first statement declares a stream that consists of MyEvent events. The second statement employs a conversion function to convert MyOtherEvent events to events of type MyEvent:
		 </para> 
		<programlisting><![CDATA[insert into MyStream select * from MyEvent
insert into MyStream select MyLib.convert(other) from MyOtherEvent as other]]></programlisting>

		 <para>
			 In the example above, assuming the event classes MyEvent and MyOtherEvent are Java classes, the static method should have the following footprint:
		 </para> 
		 <programlisting><![CDATA[public static MyEvent convert(MyOtherEvent otherEvent)]]></programlisting>
	</sect1>

</chapter>