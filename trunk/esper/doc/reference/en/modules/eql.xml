<chapter id="EQL">
    <title>EQL Reference</title>
        
    <sect1 id="eql-intro">
        <title>EQL Introduction</title>

        <para>
			EQL statements are used to derive and aggregate information from one or more streams of events, and to join or merge event streams. This section outlines EQL syntax. It also outlines the built-in views, which are the building blocks for deriving and aggregating information from event streams. 
        </para>
        
        <para>
			EQL is similar to SQL in its use of the <literal>select</literal> clause and the <literal>where</literal> clause. Where EQL differs most from SQL is in the use of tables. EQL replaces tables with the concept of event streams.
        </para>

        <para>
			EQL statements contain definitions of one or more views. Similar to tables in an SQL statement, views define the data available for querying and filtering. 
			Some views represent windows over a stream of events. Other views derive statistics from event properties, group events or handle unique event property values.
            Views can be staggered onto each other to build a chain of views. The Esper engine makes sure that views are reused among EQL statements for efficiency.
        </para>
        
        <para>
			The built-in set of views is:
         </para>

		<orderedlist spacing="compact">
			<listitem>
				<para>
					Views that represent moving event windows: <literal>win:length</literal>, <literal>win:length_batch</literal>, <literal>win:time</literal>, <literal>win:time_batch</literal>, <literal>win:ext_time</literal>, <literal>ext:sort_window</literal>
				</para>
			</listitem>
			<listitem>
				<para>
					Views for aggregation: <literal>std:unique</literal>, <literal>std:groupby</literal>, <literal>std:lastevent</literal> (note: the <literal>group-by</literal> clause and the <literal>std:groupby</literal> view are very similar in function, see view description for differences)
				</para>
			</listitem>
			<listitem>
				<para>
					Views that derive statistics: <literal>std:size</literal>, <literal>stat:uni</literal>, <literal>stat:linest</literal>, <literal>stat:correl</literal>, <literal>stat:weighted_avg</literal>, 
					<literal>stat:multidim_stat</literal>
				</para>
			</listitem>
		</orderedlist>

        <para>
			Esper can be extended by plugging-in custom developed views.
        </para>
    </sect1>

    <sect1 id="eql-select-syntax">
        <title>EQL Syntax</title>
        
		<para>
			EQL queries are created and stored in the engine, and publish results as events are received by the engine or timer events occur that match the criteria specified in the query. Events can also be pulled from running EQL queries.
		</para>

		<para>
			The select clause in an EQL query specifies the event properties or events to retrieve. The <literal>from</literal> clause in an EQL query specifies the event stream definitions and stream names to use. The <literal>where</literal> clause in an EQL query specifies search conditions that specify which event or event combination to search for. For example, the following statement returns the average price for IBM stock ticks in the last 30 seconds.
		</para>

			<programlisting><![CDATA[select avg(price) from StockTick.win:time(30 sec) where symbol='IBM']]></programlisting>

		<para>
			EQL queries follow the below syntax. EQL queries can be simple queries or more complex queries. A simple select contains only a select clause and a single stream definition. Complex EQL queries can be build that feature a more elaborate select list utilizing expressions, may join multiple streams, may contain a where clause with search conditions and so on.
		</para>

<synopsis>[insert into <emphasis>insert_into_def</emphasis>]
select <emphasis>select_list</emphasis>
from <emphasis>stream_def</emphasis> [as name] [, <emphasis>stream_def</emphasis> [as name]] [,...]
[where <emphasis>search_conditions</emphasis>]
[group by <emphasis>grouping_expression_list</emphasis>]
[having <emphasis>grouping_search_conditions</emphasis>]
[output <emphasis>output_specification</emphasis>]
[order by <emphasis>order_by_expression_list</emphasis>]
</synopsis>

		<sect2 id="eql-syntax-time-periods">
			<title>Specifying Time Periods</title>
			
			<para>
					Time-based windows as well as pattern observers and guards take a time period as a parameter. Time periods follow the syntax below.
			</para>
		
			<synopsis>time-period : [<emphasis>day-part</emphasis>] [<emphasis>hour-part</emphasis>] [<emphasis>minute-part</emphasis>] [<emphasis>seconds-part</emphasis>] [<emphasis>milliseconds-part</emphasis>]

day-part : <emphasis>number</emphasis> ("days" | "day")
hour-part : <emphasis>number</emphasis> ("hours" | "hour")
minute-part : <emphasis>number</emphasis> ("minutes" | "minute" | "min")
seconds-part : <emphasis>number</emphasis> ("seconds" | "second" | "sec")
milliseconds-part : <emphasis>number</emphasis> ("milliseconds" | "millisecond" | "msec")</synopsis>
                
			<para>
					Some examples of time periods are:
			</para>
			<programlisting>10 seconds
10 minutes 30 seconds
20 sec 100 msec
1 day 2 hours 20 minutes 15 seconds 110 milliseconds
0.5 minutes</programlisting>
		</sect2>
		
    </sect1>

    <sect1 id="eql-select-list">
        <title>Choosing Event Properties And Events: the <emphasis>Select</emphasis> Clause</title>
        
		<para>
			The select clause is required in all EQL statements. The select clause can be used to select all properties via the wildcard <literal>*</literal>, or to specify a list of event properties and expressions. The select clause defines the event type (event property names and types) of the resulting events published by the statement, or pulled from the statement.
		</para>

		<para>
			The select clause also offers optional <literal>istream</literal> and <literal>rstream</literal> keywords to control how events are posted to <literal>UpdateListener</literal> instances listening to the statement.
		</para>

		<para>
			The syntax for the <literal>select</literal> clause is summarized below.
		</para>

		<synopsis>select [rstream | istream] * | <emphasis>expression_list</emphasis> ... </synopsis>

        <sect2 id="eql-select-all-props" >
           <title>Choosing all event properties: select *</title>

			<para>
				The syntax for selecting all event properties in a stream is:
			</para>
			<synopsis>select * from <emphasis>stream_def</emphasis></synopsis>

			<para>
				The following statement selects univariate statistics for the last 30 seconds of IBM stock ticks for price.
			</para>
			<programlisting><![CDATA[select * from StockTick(symbol='IBM').win:time(30 sec).stat:uni('price')]]></programlisting>

			<para>
				In a join statement, using the <literal>select *</literal> syntax selects event properties that contain the events representing the joined streams themselves.
			</para>

			<para>
				The <literal>*</literal> wildcard and expressions can also be combined in a <literal>select</literal> clause. The combination selects all event properties and in addition the computed values
				as specified by any additional expressions that are part of the <literal>select</literal> clause. Here is an example that selects all properties of stock tick events plus a computed product of price and volume that the 
				statement names 'pricevolume':
			</para>
			<programlisting><![CDATA[select *, price * volume as pricevolume from StockTick(symbol='IBM')]]></programlisting>
		</sect2>

        <sect2 id="eql-select-event-props" >
           <title>Choosing specific event properties</title>
			<para>
				To chose the particular event properties to return:
			</para>
			<synopsis>select <emphasis>event_property</emphasis> [, <emphasis>event_property</emphasis>] [, ...] from <emphasis>stream_def</emphasis></synopsis>

			<para>
				The following statement selects the count and standard deviation properties for the last 100 events of IBM stock ticks for volume.
			</para>
			<programlisting><![CDATA[select count, stdev from StockTick(symbol='IBM').win:length(100).stat:uni('volume')
]]></programlisting>
		</sect2>

        <sect2 id="eql-select-expressions" >
           <title>Expressions</title>
			<para>
				The select clause can contain one or more expressions.
			</para>
			<synopsis>select <emphasis>expression</emphasis> [, <emphasis>expression</emphasis>] [, ...] from <emphasis>stream_def</emphasis></synopsis>

			<para>
				The following statement selects the volume multiplied by price for a time batch of the last 30 seconds of stock tick events. 
			</para>
			<programlisting><![CDATA[select volume * price from StockTick.win:time_batch(30 sec)
]]></programlisting>
		</sect2>

        <sect2 id="eql-select-renaming" >
            <title>Renaming event properties</title>
			<para>
				Event properties and expressions can be renamed using below syntax.
			</para>
			<synopsis>select [event property | expression] as <emphasis>identifier</emphasis> [, ...]</synopsis>

			<para>
				The following statement selects volume multiplied by price and specifies the name <emphasis>volPrice</emphasis> for the event property.
			</para>
			<programlisting><![CDATA[select volume * price as volPrice from StockTick.win:length(100)
]]></programlisting>
		</sect2>
		
        <sect2 id="eql-select-using-istream-rstream" >
            <title>Selecting <literal>istream</literal> and <literal>rstream</literal> events</title>

			<para>
				The optional <literal>istream</literal> and <literal>rstream</literal> keywords in the select clause define the event stream posted to listeners to the statement. 
			</para>

			<para>
				If neither keyword is specified, the engine posts
				insert stream events via the <literal>newEvents</literal> parameter to the <literal>update</literal> method of <literal>UpdateListener</literal> instances listening to 
				the statement. The engine posts remove stream events to the <literal>oldEvents</literal> parameter of the <literal>update</literal> method.
				The insert stream consists of the events entering the respective window(s) or stream(s) or aggregations, while the remove stream consists of the events leaving the respective window(s) or the changed aggregation result.
				See <xref linkend="outputmodel"/> for more information on insert and remove streams.
				</para>
			
			<para>
				By specifying the <literal>istream</literal> keyword you can instruct the engine to only post insert stream events via the <literal>newEvents</literal> parameter to the <literal>update</literal> method on listeners. The engine will then not post any remove stream events, and the <literal>oldEvents</literal> parameter is always a null value.
			</para>
				
			<para>
				By specifying the <literal>rstream</literal> keyword you can instruct the engine to only post remove stream events via the <literal>newEvents</literal> parameter to the <literal>update</literal> method on listeners. The engine will then not post any insert stream events, and the <literal>oldEvents</literal> parameter is also always a null value.
			</para>

			<para>
				The following statement selects only the events that are leaving the 30 second time window.
			</para>
			<programlisting><![CDATA[select rstream * from StockTick.win:time(30 sec)]]></programlisting>

			<para>
				The <literal>istream</literal> and <literal>rstream</literal> keywords in the select clause are matched by same-name keywords available in the insert into clause. While the keywords in the select clause control the event stream posted to listeners to the statement, the same keywords in the insert into clause specify the event stream that the engine makes available to other statements.
			</para>
		</sect2>

    </sect1>

    <sect1 id="eql-from-clause">
        <title>Specifying Event Streams : the <emphasis>From</emphasis> Clause</title>

		<para>
			The <literal>from</literal> clause is required in all EQL statements. It specifies one or more event streams. Each event stream can optionally be given a name by means of the <literal>as</literal> syntax.
		</para>
		<synopsis>from <emphasis>stream_def</emphasis> [as <emphasis>name</emphasis>] [, <emphasis>stream_def</emphasis> [as <emphasis>name</emphasis>]] [, ...]</synopsis>

		<para>
			The event stream definition <emphasis>stream_def</emphasis> as shown in the syntax above can consists of either a filter-based event stream definition or a pattern-based event stream definition. 
		</para>

		<para>
			For joins and outer joins, specify two or more event streams. Joins between pattern-based and filter-based event streams are also supported.
		</para>

		<para>
			Esper supports joins against relational databases for access to historical or reference data as explained in <xref linkend="histdata_overview"/>.
		</para>

        <sect2 id="eql-from-clause-filter" >
           <title>Filter-based event streams</title>

			<para>
				For filter-based event streams, the event stream definition <emphasis>stream_def</emphasis> as shown in the syntax above consists of an event type, an optional filter property list and an optional list of views that derive data from a stream. The syntax for a filter-based event stream is as below:
			</para>
	
			<synopsis><emphasis>event_type</emphasis> ( [<emphasis>filter_criteria</emphasis>] ) [.<emphasis>view_spec</emphasis>] [.<emphasis>view_spec</emphasis>] [...]</synopsis>
	
			<para>
				The following EQL statement selects all event properties for the last 100 events of IBM stock ticks for volume. In the example, the event type is the fully qualified Java class name <literal>org.esper.example.StockTick</literal>. The expression filters for events where the property <literal>symbol</literal> has a value of "IBM". The optional view specifications for deriving data from the StockTick events are a length window and a view for computing statistics on volume. The name for the event stream is "volumeStats".
			</para>
			<programlisting><![CDATA[select * from 
  org.esper.example.StockTick(symbol='IBM').win:length(100).stat:uni('volume') as volumeStats]]></programlisting>
	
			<para>
				Instead of the fully-qualified Java class name any other event name can be mapped via Configuration to a Java class, making the resulting statement more readable.
			</para>
			<programlisting><![CDATA[select * from StockTick(symbol='IBM').win:length(100).stat:uni('volume') as volumeStats]]></programlisting>

			<sect3 id="eql-from-clause-event-type" >
			   <title>Specifying an event type</title>
				<para>
					In the example above the event type was <literal>org.esper.example.StockTick</literal>. The event type is simply the fully qualified Java class name. Interfaces and abstract classes are also supported. Alternatively, via configuration an alias for an event type can be defined and used instead of the fully qualified class name. The below example shows one way to obtain the fully qualified class name of a given Java class <literal>StockTick</literal>.
				</para>
	
				<programlisting><![CDATA[String eventName = StockTick.class.getName();]]>
	String stmt = "from " + eventName + ".win:length(100)"
	</programlisting>
			</sect3>
		
			<sect3 id="eql-from-clause-filter-criteria" >
			   <title>Specifying event filter criteria</title>
				<para>
					Filter criteria follow the same syntax as outlined in the event pattern section on filters; see <xref linkend="pattern-filter"/>. Filter criteria operators are: <literal>=, &lt; , &gt; , &gt;=, &lt;=</literal>. Ranges use the <literal>in </literal> keyword and round <literal>(...)</literal> or square brackets <literal>[]</literal>.
				</para>
				
				<para>
					Esper filters out events in an event stream as defined by filter criteria before it sends events to subsequent views. Thus, compared to search conditions in a where-clause, filter criteria remove unneeded events early.
				</para>
	
				<para>
					The below example is a filter criteria list that removes events based on category, price and grade.
				</para>
			 <programlisting><![CDATA[from mypackage.RfidEvent(category="Perishable", price<1.00, grade in [1:2])]]></programlisting>
			</sect3>
		</sect2>
		
        <sect2 id="eql-from-clause-patterns" >
           <title>Pattern-based event streams</title>
			<para>
				Event pattern expressions can also be used to specify one or more event streams in an EQL statement.
				For pattern-based event streams, the event stream definition <emphasis>stream_def</emphasis> consists of the keyword <literal>pattern</literal> and a pattern expression in brackets <literal>[]</literal>. The syntax for an event stream definition using a pattern expression is below. As in filter-based event streams, an optional list of views that derive data from the stream can be supplied.
			</para>
			
			<synopsis>pattern [<emphasis>pattern_expression</emphasis>] [.<emphasis>view_spec</emphasis>] [.<emphasis>view_spec</emphasis>] [...]</synopsis>

			<para>
				The next statement specifies an event stream that consists of both stock tick events and trade events. The example tags stock tick events with the name "tick" and trade events with the name "trade".
			</para>			
            <programlisting><![CDATA[select * from pattern [every tick=StockTickEvent or every trade=TradeEvent]]]></programlisting>
			
			<para>
				This statement generates an event every time the engine receives either one of the event types. The generated events resemble a map with "tick" and "trade" keys. For stock tick events, the "tick" key value is the underlying stock tick event, and the "trade" key value is a null value. For trade events, the "trade" key value is the underlying trade event, and the "tick" key value is a null value.
			</para>			

			<para>
				Lets further refine this statement adding a view the gives us the last 30 seconds of either stock tick or trade events. Lets also select prices and a price total.
			</para>			
            <programlisting><![CDATA[select tick.price as tickPrice, trade.price as tradePrice, 
       sum(tick.price) + sum(trade.price) as total
  from pattern [every tick=StockTickEvent or every trade=TradeEvent].win:time(30 sec)]]></programlisting>

			<para>
				Note that in the statement above <literal>tickPrice</literal> and <literal>tradePrice</literal> can each be null values depending on the event processed. Therefore, an aggregation function such as <literal>sum(tick.price + trade.price))</literal> would always return null values as either of the two price properties are always a null value for any event matching the pattern. Use the <literal>coalesce</literal> function to handle null values, for example: <literal>sum(coalesce(tick.price, 0) + coalesce(trade.price, 0))</literal>.
			</para>			
		</sect2>

        <sect2 id="eql-from-clause-view-spec" >
           <title>Specifying views</title>
			<para>
				Views are used to derive or aggregate data. Views can be staggered onto each other. See the section <xref linkend="built-in-views"/> on the views available.
			</para>
						
			<para>
				Views can optionally take one or more parameters. These parameters can consist of primitive constants such as String, boolean or numeric types. Arrays are also supported as a view parameter types.
			</para>

			<para>
				The below example serves to show views and staggering of views. It uses a car location event that contains information about the location of a car on a highway. 
			</para>
				
			<para>
				The first view <literal>std:groupby('carId')</literal> groups car location events by car id. The second view <literal>win:length(4)</literal> keeps a length window of the 4 last events, with one length window for each car id. The next view <literal>std:groupby({'expressway', 'direction', 'segment'})</literal> groups each event by its expressway, direction and segment property values. Again, the grouping is done for each car id considering the last 4 events only. The last view <literal>std:size()</literal> is used to report the number of events. Thus the below example reports the number of events per car id and per expressway, direction and segment considering the last 4 events for each car id only. 
			</para>

         <programlisting><![CDATA[select * from CarLocEvent.std:groupby('carId').win:length(4).
  std:groupby({'expressway', 'direction', 'segment'}).std:size()
]]></programlisting>
		</sect2>
		
    </sect1>
    
    <sect1 id="eql-where-clause">
        <title>Specifying Search Conditions: the <emphasis>Where</emphasis> Clause</title>

		<para>
			The where clause is an optional clause in EQL statements. Via the where clause event streams can be joined and events can be filtered. 
		</para>
		
		<para>
			Comparison operators <literal>=, &lt; , &gt; , &gt;=, &lt;=, !=, &lt;&gt;, is null, is not null</literal> and logical combinations via <literal>and</literal> and <literal>or</literal> are supported in the where clause. The where clause can also introduce join conditions as outlined in <xref linkend="eql-join"/>. Where-clauses can also contain expressions. Some examples are listed below.
		</para>
		<programlisting>...where fraud.severity = 5 and amount > 500
...where (orderItem.orderId is null) or (orderItem.class != 10)		 
...where (orderItem.orderId = null) or (orderItem.class &lt;&gt; 10)		 
...where itemCount / packageCount > 10		 </programlisting>

    </sect1>

    <sect1 id="eql-grouping-aggregating">
        <title>Aggregates and grouping: the <emphasis>Group-by</emphasis> Clause and the <emphasis>Having</emphasis> Clause</title>

        <sect2 id="eql-grouping-aggregate-functions" >
				<title>Using aggregate functions</title>
			
				<para>
					The aggregate functions are <literal>sum, avg, count, max, min, median, stddev, avedev</literal>. You can use aggregate functions to
					calculate and summarize data from event properties.
					For example, to find out the total price for all stock tick events in the last 30 seconds, type:
				</para>
			    <programlisting>select sum(price) from StockTickEvent.win:time(30 sec)</programlisting>

				<para>
					Here is the syntax for aggregate functions: 
				</para>
				<synopsis><emphasis>aggregate_function</emphasis>( [all | distinct] <emphasis>expression</emphasis>)</synopsis>

				<para>
					You can apply aggregate functions to all events in an event stream window or other view, or to one or more groups of events. From each set of events to which 
					an aggregate function is applied, Esper generates a single value. 
				</para>

				<para>
					<literal>Expression</literal> is usually an event property name. However it can also be a constant, function, or any combination of event property names, constants, 
					and functions connected by arithmetic operators.
				</para>

				<para>
					For example, to find out the average price for all stock tick events in the last 30 seconds if the price was doubled:
				</para>
			    <programlisting>select avg(price * 2) from StockTickEvent.win:time(30 seconds)</programlisting>

				<para>
					You can use the optional keyword <literal>distinct</literal> with all aggregate functions to eliminate duplicate values before the aggregate function is applied. The optional 
					keyword <literal>all</literal> which performs the operation on all events is the default. 
				</para>

				<para>
					The syntax of the aggregation functions and the results they produce are shown in below table.
				</para>

				<table frame="topbot" id="eql-grouping-aggregate-func" revision="2">
					<title>Syntax and results of aggregate functions</title>
					<tgroup cols="2">
						<colspec colwidth="1*"/>
						<colspec colwidth="2.0*"/>
						<thead>
							<row>
								<entry>Aggregate Function</entry>
								<entry>Result</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>sum([all|distinct] <emphasis>expression</emphasis>)</entry>
								<entry>
									<para>
										Totals the (distinct) values in the expression, returning a value of <literal>long, double, float or integer</literal> type depending on the expression
									</para>
								</entry>
							</row>
							<row>
								<entry>avg([all|distinct] <emphasis>expression</emphasis>)</entry>
								<entry>
									<para>
										Average of the (distinct) values in the expression, returning a value of <literal>double</literal> type
									</para>
								</entry>
							</row>
							<row>
								<entry>count([all|distinct] <emphasis>expression</emphasis>)</entry>
								<entry>
									<para>
										Number of the (distinct) non-null values in the expression, returning a value of <literal>long</literal> type
									</para>
								</entry>
							</row>
							<row>
								<entry>count(*)</entry>
								<entry>
									<para>
										Number of events, returning a value of <literal>long</literal> type
									</para>
								</entry>
							</row>
							<row>
								<entry>max([all|distinct] <emphasis>expression</emphasis>)</entry>
								<entry>
									<para>
										Highest (distinct) value in the expression, returning a value of the same type as the expression itself returns
									</para>
								</entry>
							</row>
							<row>
								<entry>min([all|distinct] <emphasis>expression</emphasis>)</entry>
								<entry>
									<para>
										Lowest (distinct) value in the expression, returning a value of the same type as the expression itself returns
									</para>
								</entry>
							</row>
							<row>
								<entry>median([all|distinct] <emphasis>expression</emphasis>)</entry>
								<entry>
									<para>
										Median (distinct) value in the expression, returning a value of <literal>double</literal> type
									</para>
								</entry>
							</row>
							<row>
								<entry>stddev([all|distinct] <emphasis>expression</emphasis>)</entry>
								<entry>
									<para>
										Standard deviation of the (distinct) values in the expression, returning a value of <literal>double</literal> type
									</para>
								</entry>
							</row>
							<row>
								<entry>avedev([all|distinct] <emphasis>expression</emphasis>)</entry>
								<entry>
									<para>
										Mean deviation of the (distinct) values in the expression, returning a value of <literal>double</literal> type
									</para>
								</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			
				<para>
					You can use aggregation functions in a <literal>select</literal> clause and in a <literal>having</literal> clause. You cannot use aggregate functions in a <literal>where</literal> clause, but you can use the where clause to restrict the events to which the aggregate is applied. The next query computes the average and sum of the price of stock tick events for the symbol IBM only, for the last 10 stock tick events regardless of their symbol.
				</para>
			    <programlisting>select 'IBM stats' as title, avg(price) as avgPrice, sum(price) as sumPrice
from StockTickEvent.win:length(10)
where symbol='IBM'</programlisting>				
								
				<para>
					In the above example the length window of 10 elements is not affected by the where-clause, i.e. all events enter and leave the length window regardless of their symbol. If we only care about the last 10 IBM events, we need to add filter criteria as below.
				</para>
			    <programlisting>select 'IBM stats' as title, avg(price) as avgPrice, sum(price) as sumPrice
from StockTickEvent(symbol='IBM').win:length(10)
where symbol='IBM'</programlisting>				

				<para>
					You can use aggregate functions with any type of event property or expression, with the following exceptions:
				</para>

				<orderedlist spacing="compact">
					<listitem>
						<para>
							You can use <literal>sum, avg, median, stddev, avedev</literal> with numeric event properties only	
						</para>
					</listitem>
				</orderedlist>

				<para>
					Esper ignores any null values returned by the event property or expression on which the aggregate function is operating, except for the <literal>count(*)</literal> function, which counts null values as well. All aggregate functions return null if the data set contains no events, or if all events in the data set contain only null values for the aggregated expression.
				</para>
		</sect2>

        <sect2 id="eql-grouping-group-by" >
				 <title>Organizing statement results into groups: the <emphasis>Group-by</emphasis> clause</title>
				<para>
					The <literal>group by</literal> clause is optional in all EQL statements. The <literal>group by</literal> clause divides the output of an EQL statement into groups. You can group by one or more event property names, or by the result of computed expressions. When used with aggregate functions, <literal>group by</literal> retrieves the calculations in each subgroup. You can use <literal>group by</literal> without aggregate functions, but generally that can produce confusing results.
				</para>
	
				<para>
					For example, the below statement returns the total price per symbol for all stock tick events in the last 30 seconds:
				</para>
				<programlisting>select symbol, sum(price) from StockTickEvent.win:time(30 sec) group by symbol</programlisting>
	
				<para>
					The syntax of the group by clause is:
				</para>
				<synopsis>group by <emphasis>arregate_free_expression</emphasis> [, <emphasis>arregate_free_expression</emphasis>] [, ...]</synopsis>
			
				<para>
					Esper places the following restrictions on expressions in the <literal>group by</literal> clause:
				</para>
	
				<orderedlist spacing="compact">
					<listitem>
						<para>
							Expressions in the <literal>group by</literal> cannot contain aggregate functions
						</para>
					</listitem>
					<listitem>
						<para>
							Event properties that are used within aggregate functions in the <literal>select</literal> clause cannot also be used in a <literal>group by</literal> expression
						</para>
					</listitem>
				</orderedlist>
				
				<para>
					You can list more then one expression in the <literal>group by</literal> clause to nest groups. Once the sets are established with <literal>group by</literal> the aggregation
					functions are applied. This statement posts the median volume for all stock tick events in the last 30 seconds per symbol and tick data feed. Esper posts one event for each group to statement listeners:
				</para>
				<programlisting>select symbol, tickDataFeed, median(volume) 
from StockTickEvent.win:time(30 sec) 
group by symbol, tickDataFeed</programlisting>
				
				<para>
					In the statement above the event properties in the <literal>select</literal> list (symbol, tickDataFeed) are also listed in the <literal>group by</literal> clause.
					The statement thus follows the SQL standard which prescribes that non-aggregated event properties in the <literal>select</literal> list must match the 
					<literal>group by</literal> columns.
				</para>

				<para>
					Esper also supports statements in which one or more event properties in the <literal>select</literal> list are not listed in the <literal>group by</literal> clause.
					The statement below demonstrates this case. It calculates the standard deviation for the last 30 seconds of stock ticks aggregating by symbol and posting for 
					each event the symbol, tickDataFeed and the standard deviation on price.
				</para>
				<programlisting>select symbol, tickDataFeed, stddev(price) from StockTickEvent.win:time(30 sec) group by symbol</programlisting>
				
				<para>
					The above example still aggregates the <literal>price</literal> event property based on the <literal>symbol</literal>, but produces one event per incoming event, not one 
					event per group.
				</para>

				<para>
					Additionally, Esper supports statements in which one or more event properties in the <literal>group by</literal> clause are not listed in the <literal>select</literal> list.
					This is an example that calculates the mean deviation per <literal>symbol</literal> and <literal>tickDataFeed</literal> and posts one event per group with <literal>symbol</literal> and mean deviation of price in the generated events. Since tickDataFeed is not in the posted results, this can potentially be confusing.
				</para>
				<programlisting>select symbol, avedev(price) 
from StockTickEvent.win:time(30 sec) 
group by symbol, tickDataFeed</programlisting>

				<para>
					Expressions are also allowed in the <literal>group by</literal> list:
				</para>
				<programlisting>select symbol * price, count(*) from StockTickEvent.win:time(30 sec) group by symbol * price</programlisting>
				
				<para>
					If the <literal>group by</literal> expression resulted in a null value, the null value becomes its own group. All null values are aggregated into the same group. If you are using the <literal>count(expression)</literal> aggregate function which does not count null values, the count returns zero if only null values are encountered.								
				</para>

				<para>
					You can use a <literal>where</literal>	clause in a statement with <literal>group by</literal>. Events that do not satisfy the conditions in the <literal>where</literal> clause are eliminated before any grouping is done. For example, the statement below posts the number of stock ticks in the last 30 seconds with a volume larger then 100, posting one event per group (symbol).
				</para>
				<programlisting>select symbol, count(*) from StockTickEvent.win:time(30 sec) where volume &gt; 100 group by symbol</programlisting>
		</sect2>

        <sect2 id="eql-grouping-having" >
			 <title>Selecting groups of events: the <emphasis>Having</emphasis> clause</title>
				<para>
					Use the <literal>having</literal> clause to pass or reject events defined by the <literal>group-by</literal> clause. The <literal>having</literal> clause sets conditions for the <literal>group by</literal> clause in the same way <literal>where</literal> sets conditions for the <literal>select</literal> clause, except <literal>where</literal> cannot include aggregate functions, while <literal>having</literal> often does.
				</para>
			
				<para>
					This statement is an example of a <literal>having</literal> clause with an aggregate function. It posts the total price per symbol for the last 30 seconds of stock tick events for only those symbols in which the total price exceeds 1000. The <literal>having</literal> clause eliminates all symbols where the total price is equal or less then 1000.
				</para>
				<programlisting>select symbol, sum(price) 
from StockTickEvent.win:time(30 sec) 
group by symbol 
having sum(price) &gt; 1000</programlisting>

				<para>
					To include more then one condition in the <literal>having</literal> clause combine the conditions with <literal>and</literal>, <literal>or</literal> or <literal>not</literal>.
					This is shown in the statement below which selects only groups with a total price greater then 1000 and an average volume less then 500.
				</para>
				<programlisting>select symbol, sum(price), avg(volume)
from StockTickEvent.win:time(30 sec) 
group by symbol 
having sum(price) &gt; 1000 and avg(volume) &lt; 500</programlisting>			

				<para>
					Esper places the following restrictions on expressions in the <literal>having</literal> clause:
				</para>
	
				<orderedlist spacing="compact">
					<listitem>
						<para>
							Any expressions that contain aggregate functions must also occur in the <literal>select</literal> clause
						</para>
					</listitem>
				</orderedlist>

				<para>
					A statement with the <literal>having</literal> clause should also have a <literal>group by</literal> clause. If you omit <literal>group-by</literal>, all the events not excluded
					by the <literal>where</literal> clause return as a single group. In that case <literal>having</literal> acts like a <literal>where</literal> except that <literal>having</literal> can have aggregate functions. 
				</para>
				
				<para>
					The <literal>having</literal> clause can also be used without <literal>group by</literal> clause as the below example shows. The example below posts events where the price is less then the current running average price of all stock tick events in the last 30 seconds.
				</para>
				<programlisting>select symbol, price, avg(price) 
from StockTickEvent.win:time(30 sec) 
having price &lt; avg(price)</programlisting>

		</sect2>

        <sect2 id="eql-filter-where-grouping-having-interactions" >
			 <title>How the stream filter, <emphasis>Where</emphasis>, <emphasis>Group By</emphasis> and <emphasis>Having</emphasis> clauses interact</title>
				<para>
					When you include filters, the <literal>where</literal> condition, the <literal>group by</literal> clause and the <literal>having</literal> condition in an EQL statement
					the sequence in which each clause affects events determines the final result:
				</para>

				<orderedlist spacing="compact">
					<listitem>
						<para>
							The event stream's filter condition, if present, dictates which events enter a window (if one is used). The filter discards any events not meeting filter criteria.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>where</literal> clause excludes events that do not meet its search condition.
						</para>
					</listitem>
					<listitem>
						<para>
							Aggregate functions in the select list calculate summary values for each group.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>having</literal> clause excludes events from the final results that do not meet its search condition.
						</para>
					</listitem>
				</orderedlist>

				<para>
					The following query illustrates the use of filter, <literal>where</literal>, <literal>group by</literal> and <literal>having</literal> clauses in one statement with 
					a <literal>select</literal> clause containing an aggregate function.
				</para>
				
				<programlisting>select tickDataFeed, stddev(price)
from StockTickEvent(symbol='IBM').win:length(10) 
where volume > 1000
group by tickDataFeed 
having stddev(price) &gt; 0.8</programlisting>

				<para>
					Esper filters events using the filter criteria for the event stream <literal>StockTickEvent</literal>. In the example above only events with symbol IBM enter the length window over the last 10 events, all other events are simply discarded. The <literal>where</literal> clause removes any events posted by the length window (events entering the window and event leaving the window) that do not match the condition of volume greater then 1000. Remaining events are applied to the <literal>stddev</literal> standard deviation aggregate function for each tick data feed as specified in the <literal>group by</literal> clause. Each <literal>tickDataFeed</literal> value generates one event. Esper applies the <literal>having</literal> clause and only lets events pass for <literal>tickDataFeed</literal> groups with a standard deviation of price greater then 0.8.
				</para>

		</sect2>

    </sect1>

    <sect1 id="eql-output-rate">
        <title>Stabilizing and Limiting Output: the <emphasis>Output</emphasis> Clause</title>

        <sect2 id="eql-output-options" >
				<title>Output Clause Options</title>
			
				<para>
				The <literal>output</literal> clause is optional in Esper and is used to control or stabilize the rate at which events are output. For example, the following statement batches old and new events and outputs them at the end of every 90 second interval.				
				</para>
			    <programlisting>select * from StockTickEvent.win:length(5) output every 90 seconds</programlisting>

				<para>
					Here is the syntax for output rate limiting: 
				</para>
				<synopsis>output [all | first | last] every <emphasis>number</emphasis> [minutes | seconds | events]</synopsis>

				<para>
					The <literal>all</literal> keyword is the default and specifies that all events in a batch should be output. The batch size can be specified in terms of time or number of events.
				</para>

				<para>
					The <literal>first</literal> keyword specifies that only the first event in an output batch is to be output.
					Using the <literal>first</literal> keyword instructs the engine to output the first matching event as soon as it arrives, and then ignore matching events for the time interval or number of events specified. 
					After the time interval elapsed, or the number of matching events has been reached, the next first matching event is output again and the following interval the engine again ignores matching events.
				</para>

				<para>
					The <literal>last</literal> keyword specifies to only output the last event at the end of the given time interval or after the given number of matching events
					have been accumulated.
				</para>

				<para>
					The time interval can also be specified in terms of minutes; the following statement is identical to the first one.
				</para>
			    <programlisting>select * from StockTickEvent.win:length(5) output every 1.5 minutes</programlisting>

				<para>
					A second way that output can be stabilized is by batching events until a certain number of events have been collected. The next statement only outputs when either 5 (or more) new or 5 (or more) old events have been batched.
				</para>				
			    <programlisting>select * from StockTickEvent.win:time(30 sec) output every 5 events</programlisting>
			    
				<para>
					Additionally, event output can be further modified by the optional <literal>last</literal> keyword, which causes output of only the last event to arrive into an output batch.
				</para>
			    <programlisting>select * from StockTickEvent.win:time(30 sec) output last every 5 events</programlisting>

				<para>
					Using the <literal>first</literal> keyword you can be notified at the start of the interval. The allows to watch for situations such as a rate falling below a threshold
					and only be informed every now and again after the specified output interval, but be informed the moment it first happens. 
				</para>
			    <programlisting>select * from TickRate.win:time(30 seconds) output first every 60 seconds where rate&lt;100</programlisting>

		</sect2>

        <sect2 id="eql-output-groupby" >
				<title>Group By, Having and Output clause interaction</title>
			
				<para>
					The <literal>output</literal> clause interacts in two ways with the <literal>group by</literal> and <literal>having</literal> clauses. First, in the <literal>output every n events </literal>case, the number <literal>n</literal> refers to the number of events arriving into the <literal>group by clause</literal>. That is, if the <literal>group by</literal> clause outputs only 1 event per group, or if the arriving events don't satisfy the <literal>having</literal> clause, then the actual number of events output by the statement could be fewer than <literal>n</literal>.
				</para>
				<para>
Second, the <literal>last</literal> and <literal>all</literal> keywords have special meanings when used in a statement with aggregate functions and the <literal>group by</literal> clause. The <literal>last</literal> keyword specifies that only groups whose aggregate values have been updated with the most recent batch of events should be output. The <literal>all</literal> keyword (the default) specifies that the most recent data for all groups seen so far should be output, whether or not these groups' aggregate values have just been updated.
				</para>
		</sect2>

    </sect1>

    <sect1 id="eql-order-by">
        <title>Sorting Output: the <emphasis>Order By</emphasis> Clause</title>

		<para>
			The <literal>order by</literal> clause is optional in Esper. It is used for ordering output events by their properties, or by expressions involving those properties. For example, the following statement outputs batches of 5 or more stock tick events that are sorted first by price and then by volume.				
		</para>

		<programlisting>select symbol from StockTickEvent.win:time(60 sec) 
output every 5 events 
order by price, volume</programlisting>

		<para>
			Here is the syntax for the <literal>order by</literal> clause:				
		</para>

		<synopsis>order by <emphasis>expression</emphasis> [asc | desc] [, <emphasis>expression</emphasis> [asc | desc]] [, ...]</synopsis>

		<para>
			Esper places the following restrictions on the expressions in the <literal>order by</literal> clause:
		</para>
		
		<orderedlist spacing="compact">
			<listitem>
				<para>
					All aggregate functions that appear in the <literal>order by</literal> clause must also appear in the <literal>select</literal> expression.
				</para>
			</listitem>
		</orderedlist>
		
		<para>
			Otherwise, any kind of expression that can appear in the <literal>select</literal> clause, 
			as well as any alias defined in the <literal>select</literal> clause, is also valid in the order by clause.
		</para>		
	</sect1>

    <sect1 id="eql-insert-into">
        <title>Merging Streams and Continuous Insertion: the <emphasis>Insert Into</emphasis> Clause</title>

		<para>
			The <literal>insert into</literal> clause is optional in Esper. This clause can be specified to make the results of a statement available as an event stream for use
			in further statements. The clause can also be used to merge multiple event streams to form a single stream of events.
		</para>

		<programlisting>insert into CombinedEvent
select A.customerId as custId, A.timestamp - B.timestamp as latency
  from EventA.win:time(30 min) A, EventB.win:time(30 min) B
 where A.txnId = B.txnId</programlisting>

		<para>
			The <literal>insert into</literal> clause in above statement generates events of type <literal>CombinedEvent</literal>. Each generated <literal>CombinedEvent</literal> event has 2 event properties named "custId" and "latency". The events generated by above statement can be used in further statements. The below statement uses the generated events.		
		</para>

		<programlisting>select custId, sum(latency)
  from CombinedEvent.win:time(30 min)
 group by custId</programlisting>

		<para>
			The <literal>insert into</literal> clause can consist of just an event type alias, or of an event type alias and 1 or more event property names.			
			The syntax for the <literal>insert into</literal> clause is as follows:
		</para>

		<synopsis>insert [istream | rstream] into <emphasis>event_type_alias</emphasis>  [ (<emphasis>property_name</emphasis> [, property_name] ) ]</synopsis>

		<para>
			The <literal>istream</literal> (default) and <literal>rstream</literal> keywords are optional. If neither keyword or the <literal>istream</literal> keyword is specified, the engine supplies the insert stream events generated by the statement. The insert stream consists of the events entering the respective window(s) or stream(s). If the <literal>rstream</literal> keyword is specified, the engine supplies the remove stream events generated by the statement. The remove stream consists of the events leaving the respective window(s). 
		</para>

		<para>
			The <literal>event_type_alias</literal> is an identifier that names the events generated by the engine. The identifier can be used in statements to filter and
			process events of the given name.
		</para>

		<para>
			The engine also allows listeners to be attached to a statement that contain an <literal>insert into</literal> clause.
		</para>

		<para>
			To merge event streams, simply use the same <literal>event_type_alias</literal> identifier in all EQL statements that merge their result event streams. Make sure to use the
			same number and names of event properties and event property types match up.
		</para>

		<para>
			Esper places the following restrictions on the <literal>insert into</literal> clause:
		</para>
		
		<orderedlist spacing="compact">
			<listitem>
				<para>
					The number of elements in the <literal>select</literal> clause must match the number of elements in the <literal>insert into</literal> clause if the clause specifies a list of event property names
				</para>
			</listitem>
			<listitem>
				<para>
					If the event type alias has already been defined by a prior statement or configuration, and the event property names and types do not match, an exception is thrown at statement creation time.
				</para>
			</listitem>
		</orderedlist>

		<para>
			The example statement below shows the alternative form of the <literal>insert into</literal> clause that explicitly defines the property names to use.
		</para>

		<programlisting>insert into CombinedEvent (custId, latency)
select A.customerId, A.timestamp - B.timestamp 
...</programlisting>

		<para>
			The <literal>rstream</literal> keyword can be useful to indicate to the engine to generate only remove stream events. This can be useful if we want to trigger 
			actions when events leave a window rather then when events enter a window. The statement below generates <literal>CombinedEvent</literal> events when
			EventA and EventB leave the window after 30 minutes (1800 seconds).
		</para>

		<programlisting>insert rstream into CombinedEvent
select A.customerId as custId, A.timestamp - B.timestamp as latency
  from EventA.win:time(30 min) A, EventB.win:time(30 min) B
 where A.txnId = B.txnId</programlisting>
	</sect1>

    <sect1 id="eql-join">
        <title>Joining Event Streams</title>

		<para>
			Two or more event streams can be part of the <literal>from</literal> clause and thus both streams determine the resulting events. The where-clause lists the join conditions that Esper uses to relate events in the two or more streams. Reference and historical data such as stored in your relational database can also be included in joins. Please see <xref linkend="histdata_overview"/> for details.
		</para>

		<para>
			Each point in time that an event arrives to one of the event streams, the two event streams are joined and output events are produced according to the where-clause.
		</para>

		<para>
			This example joins 2 event streams. The first event stream consists of fraud warning events for which we keep the last 30 minutes (1800 seconds). The second stream is withdrawal events for which we consider the last 30 seconds. The streams are joined on account number.
		</para>
<programlisting><![CDATA[select fraud.accountNumber as accntNum, fraud.warning as warn, withdraw.amount as amount,
       max(fraud.timestamp, withdraw.timestamp) as timestamp, 'withdrawlFraud' as desc
  from net.esper.example.atm.FraudWarningEvent.win:time(30 min) as fraud,
       net.esper.example.atm.WithdrawalEvent.win:time(30 sec) as withdraw
 where fraud.accountNumber = withdraw.accountNumber]]></programlisting>

		<para>
			Joins can also include one or more pattern statements as the next example shows:
		</para>
<programlisting><![CDATA[select * from FraudWarningEvent.win:time(30 min) as fraud,
       pattern [every w=WithdrawalEvent -> PINChangeEvent(acct=w.acct)] as withdraw
 where fraud.accountNumber = withdraw.w.accountNumber]]></programlisting>

		<para>
			The statement above joins the last 30 minutes of fraud warnings with a pattern. The pattern consists of every withdrawal event that is followed by a PIN change event for the same account number. It joins the two event streams on account number.
		</para>
    </sect1>

    <sect1 id="eql-outerjoin">
        <title>Outer Joins</title>

		<para>
			Esper supports left outer joins, right outer joins and full outer joins between an unlimited number of event streams. Outer joins can also join reference and historical data as explained in <xref linkend="histdata_overview"/>.
		</para>

		<para>
			If the outer join is a left outer join, there will be an output event for each event of the stream on the left-hand side of the clause. For example, in the left outer join shown below we will get output for each event in the stream RfidEvent, even if the event does not match any event in the event stream OrderList.
		</para>

<programlisting><![CDATA[select * from net.esper.example.rfid.RfidEvent.win:time(30 sec) as rfid
       left outer join
       net.esper.example.rfid.OrderList.win:length(10000) as orderlist
     on rfid.itemId = orderList.itemId]]></programlisting>
		
		<para>
			Similarly, if the join is a Right Outer Join, then there will be an output event for each event of the stream on the right-hand side of the clause. For example, in the right outer join shown below we will get output for each event in the stream OrderList, even if the event does not match any event in the event stream RfidEvent.
		</para>

<programlisting><![CDATA[select * from net.esper.example.rfid.RfidEvent.win:time(30 sec) as rfid
       right outer join
       net.esper.example.rfid.OrderList.win:length(10000) as orderlist
     on rfid.itemId = orderList.itemId]]></programlisting>

		<para>
			For all types of outer joins, if the join condition is not met, the select list is computed with the event properties of the arrived event while all other event properties are considered to be null.
		</para>
		
<programlisting><![CDATA[select * from net.esper.example.rfid.RfidEvent.win:time(30 sec) as rfid
       full outer join
       net.esper.example.rfid.OrderList.win:length(10000) as orderlist
     on rfid.itemId = orderList.itemId]]></programlisting>

		<para>
			The last type of outer join is a full outer join. In a full outer join, each point in time that an event arrives to one of the event streams, one or more output events are produced. In the example below, when either an RfidEvent or an OrderList event arrive, one or more output event is produced.
		</para>

    </sect1>

	<sect1 id="histdata_overview" revision="1">
		<title>Joining Relational Data via SQL</title>
		
		<para>
			This chapter outlines how reference data and historical data that are stored in a relational database can be queried via SQL within EQL statements. 
		</para>
			
		<para>
			Esper can join and outer join all types of event streams to stored data. In order for such data sources to become accessible to Esper, some configuration is required. The <xref linkend="config-database-ref"/> explains the required configuration for database access in greater detail, and includes information of configuring a query result cache.
		</para>
		
		<para>
			The following restrictions currently apply:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Only one event stream and one SQL query can be joined; Joins of two or more event streams with an SQL query are not yet supported.
				</para>
			</listitem>
			<listitem>
				<para>
					Sub-views on an SQL query are not allowed; That is, one cannot create a time or length window on an SQL query. However one can use the <literal>insert into</literal> syntax to make join results available to a further statement.
				</para>
			</listitem>
			<listitem>
				<para>
					Your database software must support JDBC prepared statements that provide statement meta data at compilation time. Most major databases provide this function.
				</para>
			</listitem>
		</itemizedlist>
		
		<para>
			The next sections assume basic knowledge of SQL (Structured Query Language).
		</para>

		<sect2 id="histdata_join" revision="1">
			<title>Joining SQL Query Results</title>
			
			<para>
				To join an event stream against stored data, specify the <literal>sql</literal> keyword followed by the name of the database and a parameterized SQL query. The syntax to use in the from-clause of an EQL statement is:
			</para>
	
			<synopsis>sql:<emphasis>database_name</emphasis> [" <emphasis>parameterized_sql_query</emphasis> "]</synopsis>
	
			<para>
				The engine uses the <emphasis>database_name</emphasis> identifier to obtain configuration information in order to establish a database connection, as well as settings that control connection creation and removal. Please see <xref linkend="config-database-ref"/> to configure an engine for database access.
			</para>
				
			<para>
				Following the database name is the SQL query to execute. The SQL query can contain one or more substitution parameters. The SQL query string is placed in single brackets <literal>[</literal> and <literal>]</literal>. The SQL query can be placed in either single quotes (') or double quotes ("). The SQL query grammer is passed to your database software unchanged, allowing you to write any SQL query syntax that your database understands, including stored procedure calls.
			</para>

			<para>
				Substitution parameters in the SQL query string take the form <literal>${</literal><emphasis>event_property_name</emphasis><literal>}</literal>. The engine resolves <emphasis>event_property_name</emphasis> at statement execution time to the actual event property value supplied by the events in the joined event stream.
			</para>

			<para>
				The engine determines the type of the SQL query output columns by means of the result set metadata that your database software returns for the statement. The actual 
				query results are obtained via the <literal>getObject</literal> on <literal>java.sql.ResultSet</literal>.
			</para>

			<para>
				The sample EQL statement below joins an event stream consisting of <literal>CustomerCallEvent</literal> events with the results of an SQL query against the database named <literal>MyCustomerDB</literal> and table <literal>Customer</literal>: 
			</para>
			
			<programlisting><![CDATA[select custId, cust_name from CustomerCallEvent,
  sql:MyCustomerDB [' select cust_name from Customer where cust_id = ${custId} ']]]></programlisting>

			<para>
				The example above assumes that <literal>CustomerCallEvent</literal> supplies an event property named <literal>custId</literal>. The SQL query selects the customer name from the Customer table. The where-clause in the SQL matches the Customer table column <literal>cust_id</literal> with the value of <literal>custId</literal> in each <literal>CustomerCallEvent</literal> event. The engine executes the SQL query for each new <literal>CustomerCallEvent</literal> encountered.
			</para>

			<para>
				If the SQL query returns no rows for a given customer id, the engine generates no output event. Else the engine generates one output event for each row returned by the SQL query. An outer join as described in the next section can be used to control whether the engine should generate output events even when the SQL query returns no rows.
			</para>

			<para>
				The next example adds a time window of 30 seconds to the event stream <literal>CustomerCallEvent</literal>. It also renames the selected properties to customerName and customerId to demonstrate how the naming of columns in an SQL query can be used in the select clause in the EQL query. And the example uses explicit stream names via the <literal>as</literal> keyword.
			</para>

			<programlisting><![CDATA[select customerId, customerName from
  CustomerCallEvent.win:time(30 sec) as cce,
  sql:MyCustomerDB ["select cust_id as customerId, cust_name as customerName from Customer 
                  where cust_id = ${cce.custId}"] as cq]]></programlisting>

			<para>
				Any window, such as the time window, generates insert stream (istream) events as events enter the window, and remove stream (rstream) events as events leave the window. The engine executes the given SQL query for each <literal>CustomerCallEvent</literal> in both the insert stream and the remove stream. As a performance optimization, the <literal>istream</literal> or <literal>rstream</literal> keywords in the select-clause can be used to instruct the engine to only join insert stream or remove stream events, reducing the number of SQL query executions.
			</para>
			
		</sect2>

		<sect2 id="histdata_outerjoin" revision="1">
			<title>Outer Joins With SQL Queries</title>

			<para>
				You can use outer joins to join data obtained from an SQL query and control when an event is produced. Use a left outer join, such as in the next statement, if you need an output event for each event regardless of whether or not the SQL query returns rows. If the SQL query returns no rows, the join result populates null values into the selected properties.
			</para>
						
			<programlisting><![CDATA[select custId, custName from
  CustomerCallEvent as cce
  left outer join 
  sql:MyCustomerDB ["select cust_id, cust_name as custName 
                     from Customer where cust_id = ${cce.custId}"] as cq
  on cce.custId = cq.cust_id]]></programlisting>

			<para>
				The statement above always generates at least one output event for each <literal>CustomerCallEvent</literal>, containing all columns selected by the SQL query, even if the SQL query does not return any rows. Note the <literal>on</literal> expression that is required for outer joins. The <literal>on</literal> acts as an additional filter to rows returned by the SQL query.
			</para>
		</sect2>

		<sect2 id="histdata_polling" revision="1">
			<title>Using Patterns to Request (Poll) Data</title>
			
			<para>
				Pattern statements and SQL queries can also be applied together in useful ways. One such use is to poll or request data from a database at regular intervals. The next statement is an example that shows a pattern that fires every 5 seconds to query the NewOrder table for new orders:
			</para>
						
			<programlisting><![CDATA[insert into NewOrders
select orderId, orderAmount from
  pattern [every timer:interval(5 sec)],
  sql:MyCustomerDB ['select orderId, orderAmount from NewOrders']]]></programlisting>
			
		</sect2>

		<sect2 id="histdata_implementation" revision="1">
			<title>JDBC Implementation Overview</title>

			<para>
				The engine translates SQL queries into JDBC <literal>java.sql.PreparedStatement</literal> statements by replacing ${name} parameters with '?' placeholders. It obtains name and type of result columns from the compiled <literal>PreparedStatement</literal> meta data when the EQL statement is created.
			</para>

			<para>
				The engine supplies parameters to the compiled statement via the <literal>setObject</literal> method on <literal>PreparedStatement</literal>. The engine uses the <literal>getObject</literal> method on the compiled statement <literal>PreparedStatement</literal> to obtain column values.
			</para>
		</sect2>
		
	</sect1>

	<sect1 id="eql-single-row-function-ref">
		<title>Single-row Function Reference</title>
		
		<para>
			Single-row functions return a single value for every single result row generated by your statement. These functions can appear anywhere where expressions are allowed.
		</para>

		<para>
			Esper allows static Java library methods as single-row functions, and also features built-in
			single-row functions.
		</para>
			
		<para>
			Esper auto-imports the following Java library packages:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
					java.lang.*
				</para>
			</listitem>
			<listitem>
				<para>
					java.math.*
				</para>
			</listitem>
			<listitem>
				<para>
					java.text.*
				</para>
			</listitem>
			<listitem>
				<para>
					java.util.*
				</para>
			</listitem>
		</itemizedlist>

		<para>
			Thus Java static library methods can be used in all expressions as shown in below example:
		</para>

		<programlisting>select symbol, Math.round(volume/1000)
from StockTickEvent.win:time(30 sec)</programlisting>
			
		<para>
			In general, arbitrary Java class names have to be fully qualified (e.g. java.lang.Math) but Esper provides a mechanism 
for user-controlled imports of classes and packages as outlined in <xref linkend="configuration"/>.
		</para>

		<para>
			The below table outlines the built-in single-row functions available.
		</para>

		<table frame="topbot" id="eql-single-row-func" revision="2">
			<title>Syntax and results of single-row functions</title>
			<tgroup cols="2">
				<colspec colwidth="2.0*"/>
				<colspec colwidth="1.5*"/>
				<thead>
					<row>
						<entry>Single-row Function</entry>
						<entry>Result</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry><synopsis>max(<emphasis>expression</emphasis>, <emphasis>expression</emphasis> [, <emphasis>expression</emphasis> ...])</synopsis></entry>
						<entry>
							<para>
								Returns the highest numeric value among the 2 or more comma-separated expressions.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>min(<emphasis>expression</emphasis>, <emphasis>expression</emphasis> [, <emphasis>expression</emphasis> ...])</synopsis></entry>
						<entry>
							<para>
								Returns the lowest numeric value among the 2 or more comma-separated expressions.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>coalesce(<emphasis>expression</emphasis>, <emphasis>expression</emphasis> [, <emphasis>expression</emphasis> ...])</synopsis>
					</entry>
						<entry>
							<para>
								Returns the first non-<literal>null</literal> value in the list, or <literal>null</literal> if there are no non-<literal>null</literal> values.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>case <emphasis>value</emphasis> 
  when <emphasis>compare_value</emphasis> then <emphasis>result</emphasis>
  [when <emphasis>compare_value</emphasis> then <emphasis>result</emphasis> ...] 
  [else <emphasis>result</emphasis>] 
  end </synopsis></entry>
						<entry>
							<para>
								Returns <literal>result</literal> where the first <literal>value</literal> equals <literal>compare_value</literal>. 
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>case 
  when <emphasis>condition</emphasis> then <emphasis>result</emphasis>
  [when <emphasis>condition</emphasis> then <emphasis>result</emphasis> ...] 
  [else <emphasis>result</emphasis>] 
  end</synopsis></entry>
						<entry>
							<para>
								Returns the <literal>result</literal> for the first condition that is true.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>prev(<emphasis>expression</emphasis>, <emphasis>event_property)</emphasis></synopsis></entry>
						<entry>
							<para>
								Returns a property value of a previous event, relative to the event order within a data window 
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>prior(<emphasis>integer</emphasis>, <emphasis>event_property)</emphasis></synopsis></entry>
						<entry>
							<para>
								Returns a property value of a prior event, relative to the natural order of arrival of events
							</para>
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>

		<sect2 id="eql-single-row-function-ref-minmax">
			<title>The <literal>Min</literal> and <literal>Max</literal> Functions</title>

			<para>
				The <literal>min</literal> and <literal>max</literal> function take two or more parameters that itself can be expressions. The <literal>min</literal> function returns the lowest numeric value among the 2 or more comma-separated expressions, while the <literal>max</literal> function returns the highest numeric value.
				The return type is the compatible aggregated type of all return values.
			</para>

			<para>
				The next example shows the <literal>max</literal> function that has a <literal>Double</literal> return type and returns the value 1.1.
			</para>
			<programlisting>select max(1, 1.1, 2 * 0.5) from ...</programlisting>

			<para>
				The <literal>min</literal> function returns the lowest value. The statement below uses the function to determine the smaller of two timestamp values.
			</para>
	
			<programlisting>select symbol, min(ticks.timestamp, news.timestamp) as minT
	from StockTickEvent.win:time(30 sec) as ticks, NewsEvent.win:time(30 sec) as news
	where ticks.symbol = news.symbol</programlisting>
		</sect2>

		<sect2 id="eql-single-row-function-ref-coalesce">
			<title>The <literal>Coalesce</literal> Function</title>

			<para>
				The result of the <literal>coalesce</literal> function is the first expression in a list of expressions that returns a non-null value. The return type is the compatible aggregated type of all return values.
			</para>
			
			<para>
				This example returns a String-typed result of value 'foo'.
			</para>
			<programlisting>select coalesce(null, 'foo') from ...</programlisting>
			
		</sect2>

		<sect2 id="eql-single-row-function-ref-case">
			<title>The <literal>Case</literal> Control Flow Function</title>

			<para>
				The <literal>case</literal> control flow function has two versions. The first version takes a value and a list of compare values to compare against, and returns the result where the first value equals the compare value. The second version takes a list of conditions and returns the result for the first condition that is true.
			</para>

			<para>
				The return type of a <literal>case</literal> expression is the compatible aggregated type of all return values.
			</para>
			
			<para>
				The example below shows the first version of a <literal>case</literal> statement. It has a <literal>String</literal> return type and returns the value 'one'.
			</para>
			<programlisting>select case 1 when 1 then 'one' when 2 then 'two' else 'more' end from ...</programlisting>
				
			<para>
				The second version of the <literal>case</literal> function takes a list of conditions. The next example has a <literal>Boolean</literal> return type and returns the boolean value true.
			</para>				
			<programlisting>select case when 1>0 then true else false end from ...</programlisting>
		</sect2>
		
		<sect2 id="eql-single-row-function-ref-previous">
			<title>The <literal>Previous</literal> Function</title>

			<para>
				The <literal>prev</literal> function returns the property value of a previous event. The first parameter denotes the i-th previous event in the order established by the data window. 
				The second parameter is a property name for which the function returns the value for the previous event.
			</para>

			<para>
				This example selects the value of the <literal>price</literal> property of the 2nd-previous event from the current Trade event.
			</para>
			<programlisting>select prev(2, price) from Trade.win:length(10)</programlisting>

			<para>
				Since the <literal>prev</literal> function takes the order established by the data window into account, the function works well with sorted windows. In the following example the statement
				selects the symbol of the 3 Trade events that had the largest, second-largest and third-largest volume.
			</para>
			<programlisting>select prev(0, symbol), prev(1, symbol), prev(2, symbol)
  from Trade.ext:sort(volume, true, 10)</programlisting>

			<para>
				The i-th previous event parameter can also be an expression returning an Integer-type value. The next statement joins the Trade data window with an <literal>RankSelectionEvent</literal> event that provides a <literal>rank</literal> property used to look up a certain position in the sorted Trade data window:
			</para>
			<programlisting>select prev(rank, symbol) from Trade.ext:sort(volume, true, 10), RankSelectionEvent</programlisting>

			<para>
				The <literal>prev</literal> function returns a <literal>null</literal> value if the data window does not currently hold the i-th previous event. The example below illustrates this using a time batch window. Here the <literal>prev</literal>  
				function returns a null value for any events in which the previous event is not in the same batch of events. Note that the <literal>prior</literal> function as discussed below can be used if a null value is not the desired result.
			</para>
			<programlisting>select prev(1, symbol) from Trade.win:time_batch(1 min)</programlisting>			

			<sect3 id="eql-single-row-function-ref-prev-group">
				<title>Previous Event per Group</title>

				<para>
					The combination of <literal>prev</literal> function and group-by view returns the property value for a previous event in the given group. 
				</para>

				<para>
					Let's look at an example. Assume we want to obtain the price of the previous event of the same symbol as the current event.
				</para>
					
				<para>
					The statement that follows solves this problem. It declares a group-by view grouping on the symbol property and a time window of 1 minute. As a result, when the engine encounters a new symbol value that it hasn't seen before, it creates a new time window specifically to hold events for that symbol. Consequently, the previous function returns the previous event within the respective time window for that event's symbol value. 
				</para>
				<programlisting>select prev(1, price) as prevPrice from Trade.std:groupby('symbol').win:time(1 min)</programlisting>

				<para>
					In a second example, assume we need to return, for each event, the current top price per symbol. We can use the <literal>prev</literal> to obtain the highest price from a sorted data window, and use the group-by view to group by symbol:
				</para>
				<programlisting>select prev(0, price) as topPricePerSymbol 
from Trade.std:groupby('symbol').ext:sort('price', false, 1)</programlisting>
			</sect3>
			
			<sect3 id="eql-single-row-function-ref-prev-restrictions">
				<title>Restrictions</title>
				<para>
						The following restrictions apply to the <literal>prev</literal> functions and its results:
				</para>
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The function always returns a <literal>null</literal> value for remove stream (old data) events
						</para>
					</listitem>
					<listitem>
						<para>
							The function requires a data window view, or a group-by and data window view, without any additional sub-views. Data window views are: length window, time and time batch window and sorted window
						</para>
					</listitem>
				</itemizedlist>
			</sect3>

			<sect3 id="eql-single-row-function-ref-prev-prior">
				<title>Comparison to the <literal>prior</literal> Function</title>
				<para>
					The <literal>prev</literal> function is similar to the <literal>prior</literal> function. The key differences between the two functions are as follows:				 
				</para>						
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The <literal>prev</literal> function returns previous events in the order provided by the data window, while the <literal>prior</literal> function returns prior events in the order of arrival as posted by a stream's declared views.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>prev</literal> function requires a data window view while the <literal>prior</literal> function does not have any view requirements.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>prev</literal> function returns the previous event grouped by a criteria by combining the <literal>std:groupby</literal> view and a data window. The <literal>prior</literal> function returns prior events posted by the last view regardless of data window grouping.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>prev</literal> function returns a <literal>null</literal> value for remove stream events, i.e. for events leaving a data window. 
							The <literal>prior</literal> function does not have this restriction.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>
			
		</sect2>

		<sect2 id="eql-single-row-function-ref-prior">
			<title>The <literal>Prior</literal> Function</title>

			<para>
				The <literal>prior</literal> function returns the property value of a prior event. The first parameter is an integer value that denotes the i-th prior event in the natural order of arrival. 
				The second parameter is a property name for which the function returns the value for the prior event.
			</para>

			<para>
				This example selects the value of the <literal>price</literal> property of the 2nd-prior event to the current Trade event.
			</para>
			<programlisting>select prior(2, price) from Trade</programlisting>

			<para>
				The <literal>prior</literal> function can be used on any event stream or view and does not have any specific view requirements.  The function operates on the order of arrival of events by the event stream or view that provides the events.
			</para>

			<para>
				The next statement uses a time batch window to compute an average volume for 1 minute of Trade events, posting results every minute. The select-clause 
				employs the <literal>prior</literal> function to select the current average and the average before the current average:
			</para>
			<programlisting>select average, prior(1, average) 
    from TradeAverages.win:time_batch(1 min).stat:uni('volume')</programlisting>
	
		</sect2>
	</sect1>		

	<sect1 id="eql-operator-ref">
		<title>Operator Reference</title>
		
		<para>
			Esper arithmatic and logical operator precedence follows Java standard arithmatic and logical operator precedence.
		</para>

		<sect2 id="eql-operator-ref-arithmatic">
			<title>Arithmatic Operators</title>
			<para>
				The below table outlines the arithmatic operators available.
			</para>
	
			<table frame="topbot" id="eql-arith-operators" revision="2">
				<title>Syntax and results of arithmatic operators</title>
				<tgroup cols="2">
					<colspec colwidth="2.0*"/>
					<colspec colwidth="1.5*"/>
					<thead>
						<row>
							<entry>Operator</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>+, -</entry>
							<entry>
								<para>As unary operators they denote a positive or negative expression. As binary operators they add or subtract.</para>
							</entry>
						</row>
						<row>
							<entry>*, /</entry>
							<entry>
								<para>Multiplication and division are binary operators.</para>
							</entry>
						</row>
						<row>
							<entry>%</entry>
							<entry>
								<para>Modulo binary operator.</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</sect2>		
		
		<sect2 id="eql-operator-ref-logical">
			<title>Logical And Comparsion Operators</title>
			<para>
				The below table outlines the logical and comparison operators available.
			</para>
	
			<table frame="topbot" id="eql-log-operators" revision="2">
				<title>Syntax and results of logical and comparison operators</title>
				<tgroup cols="2">
					<colspec colwidth="2.0*"/>
					<colspec colwidth="1.5*"/>
					<thead>
						<row>
							<entry>Operator</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>NOT</entry>
							<entry>
								<para>Returns true if the following condition is false, returns false if it is true.</para>
							</entry>
						</row>
						<row>
							<entry>OR</entry>
							<entry>
								<para>Returns true if either component condition is true, returns false if both are false.</para>
							</entry>
						</row>
						<row>
							<entry>AND</entry>
							<entry>
								<para>Returns true if both component conditions are true, returns false if either is false.</para>
							</entry>
						</row>
						<row>
							<entry>=, !=, &lt;, &gt; &lt;=, &gt;=,</entry>
							<entry>
								<para>Comparison.</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</sect2>		
		
		<sect2 id="eql-operator-ref-string">
			<title>Concatenation Operators</title>
			<para>
				The below table outlines the concatenation operators available.
			</para>
	
			<table frame="topbot" id="eql-concat-operators" revision="2">
				<title>Syntax and results of concatenation operators</title>
				<tgroup cols="2">
					<colspec colwidth="2.0*"/>
					<colspec colwidth="1.5*"/>
					<thead>
						<row>
							<entry>Operator</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>||</entry>
							<entry>
								<para>Concatenates character strings</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</sect2>		

		<sect2 id="eql-operator-ref-binary">
			<title>Binary Operators</title>
			<para>
				The below table outlines the binary operators available.
			</para>
	
			<table frame="topbot" id="eql-binary-operators" revision="2">
				<title>Syntax and results of binary operators</title>
				<tgroup cols="2">
					<colspec colwidth="2.0*"/>
					<colspec colwidth="1.5*"/>
					<thead>
						<row>
							<entry>Operator</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>&amp;</entry>
							<entry>
								<para>Bitwise AND if both operands are numbers; conditional AND if both operands are boolean</para>
							</entry>
						</row>
						<row>
							<entry>|</entry>
							<entry>
								<para>Bitwise OR if both operands are numbers; conditional OR if both operands are boolean</para>
							</entry>
						</row>
						<row>
							<entry>^</entry>
							<entry>
								<para>Bitwise exclusive OR (XOR)</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</sect2>		

		<sect2 id="eql-operator-ref-array">
			<title>Array Definition Operator</title>
			<para>
				The <literal>{</literal> and <literal>}</literal> curly braces are array definition operators following the Java array initialization syntax. Arrays can be useful to pass to user-defined functions or to select array data in a select clause.
			</para>

			<para>
				Array definitions consist of zero or more expressions within curly braces. Any type of expression is allowed within array definitions including constants, arithmatic expressions or event properties. This is the syntax of an array definition:
			</para>
			<synopsis><emphasis>{</emphasis> [<emphasis>expression</emphasis> [,<emphasis>expression</emphasis>...]] }</synopsis>

			<para>
				Consider the next statement that returns an event property named <literal>actions</literal>. The engine populates the <literal>actions</literal> property as an array of <literal>java.lang.String</literal> values with a length of 2 elements. The first element of the array contains the <literal>observation</literal> property value and the second element the <literal>command</literal> property value of <literal>RFIDEvent</literal> events.
			</para>
			<programlisting><![CDATA[select {observation, command} as actions from RFIDEvent]]></programlisting>

			<para>
				The engine determines the array type based on the types returned by the expressions in the array definiton. For example, if all expressions in the array definition return integer values then the type of the array is <literal>java.lang.Integer[]</literal>. If the types returned by all expressions are compatible number types, such as integer and double values, the engine coerces the array element values and returns a suitable type, <literal>java.lang.Double[]</literal> in this example.
				The type of the array returned is <literal>Object[]</literal> if the types of expressions cannot be coerced or return object values. Null values can also be used in an array definition.
			</para>

			<para>
				Arrays can come in handy for use as parameters to user-defined functions:
			</para>
			<programlisting><![CDATA[select * from RFIDEvent where Filter.myFilter(zone, {1,2,3})]]></programlisting>
		</sect2>

		<sect2 id="eql-operator-ref-keyword-in">
			<title>The '<literal>in</literal>' Keyword</title>
			<para>
				The <literal>in</literal> keyword determines if a given value matches any value in a list. The syntax of the keyword is:	
			</para>
			
			<synopsis><emphasis>test_expression</emphasis> [not] in (<emphasis>expression</emphasis> [,<emphasis>expression</emphasis>...] )</synopsis>
	
			<para>
				The <emphasis>test_expression</emphasis> is any valid expression. The keyword is followed by a list of expressions to test for a match. The optional <literal>not</literal> keyword specifies that the result of the predicate be negated.
			</para>
				
			<para>
				The result of an <literal>in</literal> expression is of type <literal>Boolean</literal>. If the value of <emphasis>test_expression</emphasis> is equal to any expression from the comma-separated list, the result value is <literal>true</literal>. Otherwise, the result value is <literal>false</literal>. All expressions must be of the same type as or a compatible type to <emphasis>test_expression</emphasis>.
			</para>

			<para>
				The next example shows how the <literal>in</literal> keyword can be applied to select certain command types of RFID events:
			</para>
			<programlisting><![CDATA[select * from RFIDEvent where command in ('OBSERVATION', 'SIGNAL')]]></programlisting>
			<para>
				The statement is equivalent to:
			</para>
			<programlisting><![CDATA[select * from RFIDEvent where command = 'OBSERVATION' or symbol = 'SIGNAL']]></programlisting>
		</sect2>		

		<sect2 id="eql-operator-ref-keyword-between">
			<title>The '<literal>between</literal>' Keyword</title>
			<para>
				The <literal>between</literal> keyword specifies a range to test. The syntax of the keyword is:	
			</para>
			
			<synopsis><emphasis>test_expression</emphasis> [not] between <emphasis>begin_expression</emphasis> and <emphasis>end_expression</emphasis></synopsis>
	
			<para>
				The <emphasis>test_expression</emphasis> is any valid expression and is the expression to test for in the range defined by <emphasis>begin_expression</emphasis> and <emphasis>end_expression</emphasis>. The <literal>not</literal> keyword specifies that the result of the predicate be negated. 
			</para>
				
			<para>
				The result of a <literal>between</literal> expression is of type <literal>Boolean</literal>. If the value of <emphasis>test_expression</emphasis> is greater then or equal to the value of <emphasis>begin_expression</emphasis> and less than or equal to the value of <emphasis>end_expression</emphasis>, the result is <literal>true</literal>. 
			</para>

			<para>
				The next example shows how the <literal>between</literal> keyword can be used to select events with a price between 55 and 60 (inclusive).
			</para>
			<programlisting><![CDATA[select * from StockTickEvent where price between 55 and 60]]></programlisting>
			<para>
				The equivalent expression without <literal>between</literal> is:
			</para>
			<programlisting><![CDATA[select * from StockTickEvent where price >= 55 and price <= 60]]></programlisting>
			<para>
				And also equivalent to:
			</para>
			<programlisting><![CDATA[]]>select * from StockTickEvent where price between 60 and 55</programlisting>
		</sect2>		

		<sect2 id="eql-operator-ref-keyword-like">
			<title>The '<literal>like</literal>' Keyword</title>
			<para>
				The <literal>like</literal> keyword provides standard SQL pattern matching. SQL pattern matching allows you to use <literal>'_'</literal> to match any single character and <literal>'%'</literal> to match an arbitrary number of characters (including zero characters). In Esper, SQL patterns are case-sensitive by default. The syntax of <literal>like</literal> is:	
			</para>
			
			<synopsis><emphasis>test_expression</emphasis> [not] like <emphasis>pattern_expression</emphasis> [escape <emphasis>string_literal</emphasis>]</synopsis>
	
			<para>
				The <emphasis>test_expression</emphasis> is any valid expression yielding a String-type or a numeric result. The optional <literal>not</literal> keyword specifies that the result of the predicate be negated. The <literal>like</literal> keyword is followed by any valid standard SQL <emphasis>pattern_expression</emphasis> yielding a String-typed result. The optional <literal>escape</literal> keyword signals the escape character to escape <literal>'_'</literal> and <literal>'%'</literal> values in the pattern.
			</para>
				
			<para>
				The result of a <literal>like</literal> expression is of type <literal>Boolean</literal>. If the value of <emphasis>test_expression</emphasis> matches the <emphasis>pattern_expression</emphasis>, the result value is <literal>true</literal>. Otherwise, the result value is <literal>false</literal>.
			</para>

			<para>
				An example for the <literal>like</literal> keyword is below.
			</para>
			<programlisting><![CDATA[select * from PersonLocationEvent where name like '%Jack%']]></programlisting>

			<para>
				The escape character can be defined as follows. In this example the where-clause matches events where the suffix property is a single <literal>'_'</literal> character.
			</para>
			<programlisting><![CDATA[select * from PersonLocationEvent where suffix like '!_' escape '!']]></programlisting>
		</sect2>		

		<sect2 id="eql-operator-ref-keyword-regexp">
			<title>The '<literal>regexp</literal>' Keyword</title>
			<para>
				The <literal>regexp</literal> keyword is a form of pattern matching based on regular expressions implemented through the Java <literal>java.util.regex</literal> package. The syntax of <literal>regexp</literal> is:	
			</para>
			
			<synopsis><emphasis>test_expression</emphasis> [not] regexp <emphasis>pattern_expression</emphasis></synopsis>
	
			<para>
				The <emphasis>test_expression</emphasis> is any valid expression yielding a String-type or a numeric result. The optional <literal>not</literal> keyword specifies that the result of the predicate be negated. The <literal>regexp</literal> keyword is followed by any valid regular expression <emphasis>pattern_expression</emphasis> yielding a String-typed result.
			</para>
				
			<para>
				The result of a <literal>regexp</literal> expression is of type <literal>Boolean</literal>. If the value of <emphasis>test_expression</emphasis> matches the regular expression <emphasis>pattern_expression</emphasis>, the result value is <literal>true</literal>. Otherwise, the result value is <literal>false</literal>.
			</para>

			<para>
				An example for the <literal>regexp</literal> keyword is below.
			</para>
			<programlisting><![CDATA[select * from PersonLocationEvent where name regexp '*Jack*']]></programlisting>
		</sect2>		

	</sect1>		

    <sect1 id="built-in-views">
        <title>Built-in views</title>

        <para>
            This chapter outlines the views that are built into Esper. All views can be arbitrarily combined as many of the examples below show. 
			The section on <xref linkend="outputmodel"/> provides additional information on the relationship of views, filtering and aggregation.
        </para>
        
        <sect2 id="win-views" >
           <title>Window views</title>

			<sect3 id="view-win-length" >
			   <title>Length window (<literal>win:length</literal>)</title>
		
				<para>
					Creates a moving window extending the specified number of elements into the past. The view takes a single numeric parameter that defines the window size:
				</para>

				<synopsis>win:length(<emphasis>size</emphasis>)</synopsis>

				<para>
					The below example calculates univariate statistics on price for the last 5 stock ticks for symbol IBM.
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent(symbol='IBM').win:length(5).stat:uni('price')]]></programlisting>

				<para>
					The next example keeps a length window of 10 events of stock trade events, with a separate window for each symbol. The
					statistics on price is calculated only for the last 10 events for each symbol.
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent.std:groupby('symbol').win:length(10).stat:uni('price')]]></programlisting>
			</sect3>

			<sect3 id="view-win-length-batch" >
			   <title>Length window batch (<literal>win:length_batch</literal>)</title>
		
				<para>
					This window view buffers events and releases them when a given minimum number of events has been collected. The view takes the number of events to batch as a parameter:
				</para>

				<synopsis>win:length_batch(<emphasis>size</emphasis>)</synopsis>

				<para>
					The next statement buffers events until a minimum of 5 events have collected. Listeners to updates posted by this view receive updated information only when 5 or more events have collected.
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent.win:length_batch(5)]]></programlisting>
			</sect3>

			<sect3 id="view-win-time" >
			   <title>Time window (<literal>win:time</literal>)</title>
		
				<para>
					Creates a moving time window extending from the specified time interval into the past based on the system time.
					This view takes a time period (see <xref linkend="eql-syntax-time-periods"/>) or a number of seconds as a parameter:
				</para>

				<synopsis>win:time(<emphasis>time period</emphasis>)</synopsis>
				<synopsis>win:time(<emphasis>number of seconds</emphasis>)</synopsis>

				<para>
					For the IBM stock tick events in the last 1 second, calculate statistics on price.
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent(symbol='IBM').win:time(1 sec).stat:uni('price')]]></programlisting>

				<para>
					The same statement rewritten to use a parameter supplying number-of-seconds is:
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent(symbol='IBM').win:time(1).stat:uni('price')]]></programlisting>

				<para>
					The following time windows are equivalent specifications:
				</para>
	
				<programlisting><![CDATA[]]>win:time(2 minutes 5 seconds)
win:time(125 sec)
win:time(125)</programlisting>
			</sect3>

			<sect3 id="view-win-ext_time" >
			   <title>Externally-timed window (<literal>win:ext_timed</literal>)</title>
		
				<para>
					Similar to the time window, this view is a moving time window extending from the specified time interval into the past, but based on the millisecond
					time value supplied by an event property. The view takes two parameters: the name of the event property to return the long-typed timestamp value,
					and a time period or a number of seconds:
				</para>

				<synopsis>win:time(<emphasis>timestamp_property_name</emphasis>, <emphasis>time_period</emphasis>)</synopsis>
				<synopsis>win:time(<emphasis>timestamp_property_name</emphasis>, <emphasis>number_of_seconds</emphasis>)</synopsis>

				<para>
					This view holds stock tick events of the last 10 seconds based on the timestamp property in <literal>StockTickEvent</literal>.
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent.win:ext_timed('timestamp', 10 seconds)]]></programlisting>
			</sect3>

			<sect3 id="view-win-time-batch" >
			   <title>Time window batch (<literal>win:time_batch</literal>)</title>
		
				<para>
					This window view buffers events and releases them every specified time interval in one update. The view takes a time period or a number of seconds as a parameter.
				</para>

				<synopsis>win:time_batch(<emphasis>time_period</emphasis>)</synopsis>
				<synopsis>win:time_batch(<emphasis>number_of_seconds</emphasis>)</synopsis>

				<para>
					The below example batches events into a 5 second window releasing new batches every 5 seconds. Listeners to updates
					posted by this view receive updated information only every 5 seconds.
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent.win:time_batch(5 sec)]]></programlisting>
			</sect3>
	   </sect2>

        <sect2 id="std-views" >
           <title>Standard view set</title>

			<sect3 id="view-std-unique" >
			   <title>Unique (<literal>std:unique</literal>)</title>
		
				<para>
					The <literal>unique</literal> view is a view that includes only the most recent among events having the same value for the specified field:
				</para>
				<synopsis>std:unique(<emphasis>event_property_name</emphasis>)</synopsis>

				<para>
					The view acts as a length window of size 1 for each distinct value of the event property. It thus posts as old events the prior event of the same property value, if any.
				</para>

				<para>
					The below example creates a view that retains only the last event per symbol.
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent.std:unique('symbol')]]></programlisting>
			</sect3>

			<sect3 id="view-std-groupby" >
			   <title>Group By (<literal>std:groupby</literal>)</title>
		
				<para>
					This view groups events into sub-views by the value of the specified field. The view takes a single property name to supply the group-by values, or a list of property names as the synopsis shows:
				</para>

				<synopsis>std:groupby(<emphasis>property_name</emphasis>)</synopsis>
				<synopsis>std:groupby({<emphasis>property_name</emphasis> [, <emphasis>property_name</emphasis> ...] })</synopsis>

				<para>
					This example calculates statistics on price separately for each symbol.					
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent.std:groupby('symbol').stat:uni('price')]]></programlisting>

				<para>
					The group-by view can also take multiple fields to group by. This example calculates statistics on price for each symbol and feed.					
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent.std:groupby({'symbol', 'feed'}).stat:uni('price')]]></programlisting>

				<para>
					The order in which the group-by view appears within sub-views of a stream controls the data the engine derives from events for each group. The next 2 statements demonstrate this using a length window.
				</para>

				<para>
					This example keeps a length window of 10 events of stock trade events, with a separate length window for each symbol. The engine calculates statistics on price for the last 10 events for each symbol. During runtime, the engine actually allocates a separate length window for each new symbol arriving.
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent.std:groupby('symbol').win:length(10).stat:uni('price')]]></programlisting>

				<para>
					By putting the group-by view in position after the length window, we can change the semantics of the query. The query now returns the statistics on price per symbol for only the last 10 events across all symbols. Here the engine allocates only one length window for all events.
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent.win:length(10).std:groupby('symbol').stat:uni('price')]]></programlisting>

				<para>
					We have learned that by placing the group-by view before other views, these other views become part of the grouped set of views. The engine dynamically allocates a new view instance for each subview, every time it encounters a new group key such as a new value for symbol. Therefore, in <literal>std:groupby('symbol').win:length(10)</literal> the engine allocates a new length window for each distinct symbol. However in <literal>win:length(10).std:groupby('symbol')</literal> the engine maintains a single length window.
				</para>

				<para>
					Multiple group-by views can also be used in the same statement. The statement below groups by symbol and feed. As the statement declares the time window after the group-by view for symbols, the engine allocates a new time window per symbol however reports statistics on price per symbol and feed. The query results are statistics on price per symbol and feed for the last 1 minute of events per symbol (and not per feed).
				</para>

				<programlisting><![CDATA[select * from StockTickEvent.std:groupby('symbol').win:time(1 minute)
    .std:groupby('feed').stat:uni('price')]]></programlisting>

				<para>
					Last, we consider the permutation where the time window is declared after the group-by. Here, the query results are statistics on price per symbol and feed for the last 1 minute of events per symbol and feed.
				</para>

				<programlisting><![CDATA[select * from StockTickEvent.std:groupby({'symbol', 'feed'})
    .win:time(1 minute).stat:uni('price')]]></programlisting>
			</sect3>

			<sect3 id="view-std-size" >
			   <title>Size (<literal>std:size</literal>)</title>
		
				<para>
					This view simply posts the number of events received from a stream or view. The synopsis is simply:
				</para>

				<synopsis>std:size()</synopsis>

				<para>					
					The view posts a single long-typed property named <literal>size</literal>. The view posts the prior size as old data, and the current size as new data to update listeners of the view. Via the <literal>iterator</literal> method of the statement the size value can also be polled (read).
				</para>

				<para>
					When combined with a data window view, the size view reports the current and prior number of events in the data window. This example reports the number of tick events within the last 1 minute:
				</para>
				<programlisting><![CDATA[select size from StockTickEvent.win:time(1 min).std:size()]]></programlisting>

				<para>
					The size view is also useful in conjunction with a group-by view to count the number of events per group. The EQL below returns the number of events per symbol.
				</para>
				<programlisting><![CDATA[select size from StockTickEvent.std:groupby('symbol').std:size()]]></programlisting>

				<para>
					When used without a data window, the view simply counts the number of events:
				</para>
				<programlisting><![CDATA[select size from StockTickEvent.std:size()]]></programlisting>

				<para>
					All views can be used with pattern statements as well. The next EQL snippet shows a pattern where we look for tick events followed by trade events for the same symbol. The size view counts the number of occurances of the pattern.
				</para>
				<programlisting><![CDATA[select size from pattern[every s=StockTickEvent -> TradeEvent(symbol=s.symbol)].std:size()]]></programlisting>
			</sect3>

			<sect3 id="view-std-last" >
			   <title>Last (<literal>std:lastevent</literal>)</title>
		
				<para>
					This view exposes the last element of its parent view:
				</para>
				<synopsis>std:lastevent()</synopsis>

				<para>
					The view acts as a length window of size 1. It thus posts as old events the prior event in the stream, if any.
				</para>

				<para>
					This example statement retains statistics calculated on stock tick price for the symbol IBM. 
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent(symbol='IBM').stat:uni('price').std:lastevent()]]></programlisting>
			</sect3>
	   </sect2>
  
        <sect2 id="stat-views" >
           <title>Statistics views</title>
           
			<sect3 id="view-stat-uni" >
			   <title>Univariate statistics (<literal>stat:uni</literal>)</title>
		
				<para>
					This view calculates univariate statistics on an event property. The view takes a single event property name as a parameter. The event property must be of numeric type:
				</para>
				<synopsis>stat:uni(<emphasis>event_property_name</emphasis>)</synopsis>
				
				<table frame="topbot" id="view-stat-uni-table" revision="2">
					<title>Univariate statistics derived properties</title>
					<tgroup cols="2">
						<colspec colwidth="1*"/>
						<colspec colwidth="2.5*"/>
						<thead>
							<row>
								<entry>Property Name</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>count</literal></entry>
								<entry>Number of values</entry>
							</row>
							<row>
								<entry><literal>sum</literal></entry>
								<entry>Sum of values</entry>
							</row>
							<row>
								<entry><literal>average</literal></entry>
								<entry>Average of values</entry>
							</row>
							<row>
								<entry><literal>variance</literal></entry>
								<entry>Variance</entry>
							</row>
							<row>
								<entry><literal>stdev</literal></entry>
								<entry>Sample standard deviation (square root of variance) </entry>
							</row>
							<row>
								<entry><literal>stdevpa</literal></entry>
								<entry>Population standard deviation</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
	
				<para>
					The below example selects the standard deviation on price for stock tick events for the last 10 events.
				</para>
	
				<programlisting><![CDATA[select stdev from StockTickEvent.win:length(10).stat:uni('price')]]></programlisting>
			</sect3>

			<sect3 id="view-stat-linest" >
			   <title>Regression (<literal>stat:linest</literal>)</title>
		
				<para>
					This view calculates regression on two event properties. The view takes two event property names as parameters. The event properties must be of numeric type:
				</para>
				
				<synopsis>stat:linest(<emphasis>event_property_name_1</emphasis>, <emphasis>event_property_name_2</emphasis>)</synopsis>

				<table frame="topbot" id="view-stat-linest-table" revision="2">
					<title>Regression derived properties</title>
					<tgroup cols="2">
						<colspec colwidth="1*"/>
						<colspec colwidth="2.5*"/>
						<thead>
							<row>
								<entry>Property Name</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>slope</literal></entry>
								<entry>Slope</entry>
							</row>
							<row>
								<entry><literal>yintercept</literal></entry>
								<entry>Y Intercept</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
				
				<para>
					Calculate slope and y-intercept on price and offer for all events in the last 10 seconds.
				</para>
	
				<programlisting><![CDATA[select slope, yintercept from StockTickEvent.win:time(10 seconds).stat:linest('price', 'offer')]]></programlisting>	
			</sect3>
				
			<sect3 id="view-stat-correl" >
			   <title>Correlation (<literal>stat:correl</literal>)</title>
		
				<para>
					This view calculates the correlation value on two event properties. The view takes two event property names as parameters. The event properties must be of numeric type:
				</para>
				
				<synopsis>stat:correl(<emphasis>event_property_name_1</emphasis>, <emphasis>event_property_name_2</emphasis>)</synopsis>
				
				<table frame="topbot" id="view-stat-correl-table" revision="2">
					<title>Correlation derived properties</title>
					<tgroup cols="2">
						<colspec colwidth="1*"/>
						<colspec colwidth="2.5*"/>
						<thead>
							<row>
								<entry>Property Name</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>correl</literal></entry>
								<entry>Correlation between two event properties</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
	
				<para>
					Calculate correlation on price and offer over all stock tick events for IBM.
				</para>
	
				<programlisting><![CDATA[select * from StockTickEvent(symbol='IBM').stat:correl('price', 'offer')]]></programlisting>            
			</sect3>
						
			<sect3 id="view-stat-weightedavg" >
			   <title>Weighted average (<literal>stat:weighted_avg</literal>)</title>
		
				<para>
					This view returns the weighted average given a weight field and a field to compute the average for. The view takes two event property names as parameters. The event properties must be of numeric type:
				</para>				
				<synopsis>stat:weighted_avg(<emphasis>event_property_name_field</emphasis>, <emphasis>event_property_name_weight</emphasis>)</synopsis>
				
				<table frame="topbot" id="view-stat-weightedavg-table" revision="2">
					<title>Weighted average derived properties</title>
					<tgroup cols="2">
						<colspec colwidth="1*"/>
						<colspec colwidth="2.5*"/>
						<thead>
							<row>
								<entry>Property Name</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>average</literal></entry>
								<entry>Weighted average</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
	
				<para>
					A statement that derives the volume-weighted average price for the last 3 seconds:
				</para>
	
				<programlisting><![CDATA[select average 
from StockTickEvent(symbol='IBM').win:time(3 seconds).stat:weighted_avg('price', 'volume')]]></programlisting>            
			</sect3> 
			
			<sect3 id="view-stat-multidim" >
			   <title>Multi-dimensional statistics (<literal>stat:multidim_stats</literal>)</title>
		
				<para>
					This view works similar to the <literal>std:groupby</literal> views in that it groups information by one or more event properties. 
					The view accepts 3 or more parameters: The first parameter to the view defines the univariate statistics values to derive.
					The second parameter is the property name to derive data from.
					The remaining parameters supply the event property names to use to derive dimensions.
				</para>
				<synopsis>stat:multidim_stats(<emphasis>values_to_derive</emphasis>, <emphasis>property_name_datapoint</emphasis>, <emphasis>property_name_column</emphasis>)</synopsis>
				<synopsis>stat:multidim_stats(<emphasis>values_to_derive</emphasis>, <emphasis>property_name_datapoint</emphasis>, <emphasis>property_name_column</emphasis>, 
    <emphasis>property_name_row</emphasis>)</synopsis>
				<synopsis>stat:multidim_stats(<emphasis>values_to_derive</emphasis>, <emphasis>property_name_datapoint</emphasis>, <emphasis>property_name_column</emphasis>, 
    <emphasis>property_name_row</emphasis>, <emphasis>property_name_page</emphasis>)</synopsis>
				
				<table frame="topbot" id="view-stat-multidim-table" revision="2">
					<title>Multi-dim derived properties</title>
					<tgroup cols="2">
						<colspec colwidth="1*"/>
						<colspec colwidth="2.5*"/>
						<thead>
							<row>
								<entry>Property Name</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>cube</literal></entry>
								<entry>The cube following the <literal>net.esper.view.stat.olap.Cube</literal> interface</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
	
				<para>
					The example below derives the count, average and standard deviation latency of service measurement events per customer.
				</para>	
				<programlisting><![CDATA[select cube from ServiceMeasurement.stat:multidim_stats({count, average, stdev}, 
    'latency', 'customer')]]></programlisting>            

				<para>
					This example derives the average latency of service measurement events per customer, service and error status for events in
					the last 30 seconds.
				</para>	
				<programlisting><![CDATA[select * from ServiceMeasurement.win:length(30000).stat:multidim_stats({average}, 
	'latency', 'customer', 'service', 'status')]]></programlisting>            
			</sect3> 

		</sect2>

        <sect2 id="ext-views" >
           <title>Extension View Set</title>

			<sect3 id="view-ext-sort" >
			   <title>Sorted Window View (<literal>ext:sort</literal>)</title>
		
				<para>					
					This view sorts by values of the specified event properties and keeps only the top events up to the given size. 
				</para>

				<para>
					The syntax to sort on a single event property is as follows.
				</para>
				<synopsis>std:sort(<emphasis>property_name</emphasis>, <emphasis>is_descending</emphasis>, <emphasis>size</emphasis>) </synopsis>

				<para>
					To sort on a multiple event properties the syntax is as follows.
				</para>
				<synopsis>sort( { <emphasis>property_name</emphasis>, <emphasis>is_descending</emphasis> [ , <emphasis>property_name</emphasis>, <emphasis>is_descending</emphasis> ...] }, <emphasis>size</emphasis>) </synopsis>

				<para>
					The view below sorts on price descending keeping the lowest 10 prices and reporting statistics on price.
				</para>
				<programlisting><![CDATA[select * from StockTickEvent.ext:sort('price', false, 10).stat:uni('price')]]></programlisting>				

				<para>
					The following example sorts events first by price in descending order, and then by symbol name in ascending (alphabetical) order, keeping only the 10
events with the highest price (with ties resolved by alphabetical order of symbol).
				</para>
				<programlisting><![CDATA[select * from StockTickEvent.ext:sort({'price', true, 'symbol', false}, 10)]]></programlisting>				
			</sect3>
			
		</sect2>

    </sect1>

    <sect1 id="eql-user-defined">
        <title>User-Defined Functions</title>
        
		 <para>
			 A user-defined function can be invoked anywhere as an expression itself or within an expresson. The function must simply be a public static method
			 that the classloader can resolve at statement creation time. The engine resolves the function reference at statement creation time and verifies parameter types.
		 </para>

		 <para>
			 The example below assumes a class <literal>MyClass</literal> that exposes a public static method <literal>myFunction</literal> accepting 2 parameters, and
			 returing a numeric type such as <literal>double</literal>.
		 </para>
		 
<programlisting><![CDATA[select 3 * MyClass.myFunction(price, volume) as myValue 
from StockTick.win:time(30 sec)]]></programlisting>

		 <para>
			 User-defined functions also take array parameters as this example shows. The section on <xref linkend="eql-operator-ref-array"/> outlines in more detail the types of arrays produced.
		 </para>
		 
<programlisting><![CDATA[select * from RFIDEvent where com.mycompany.rfid.MyChecker.isInZone(zone, {10, 20, 30})]]></programlisting>
    </sect1>
</chapter>