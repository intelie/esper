<chapter id="configuration" revision="1">

    <title>Configuration</title>
    
	<indexterm><primary>configuration</primary><secondary>overview</secondary></indexterm>
	<indexterm><primary>Configuration class</primary></indexterm>
    <para>
        Esper engine configuration is entirely optional. Esper has a very small number of configuration parameters that can be used to simplify event 
        pattern and EPL statements, and to tune the engine behavior to specific requirements. The Esper engine works out-of-the-box without configuration.
    </para>

    <para>
        An application can supply configuration at the time of engine allocation using the <literal>Configuration</literal> class, and can also use XML files to hold configuration. Configuration can be changed at runtime
        via the <literal>ConfigurationOperations</literal> interface available from <literal>EPAdministrator</literal> via the <literal>getConfiguration</literal> method.
    </para>

    <sect1 id="configuration-programmatic" revision="1">
        <title>Programmatic Configuration</title>

	<indexterm><primary>configuration</primary><secondary>programmatic</secondary></indexterm>
        <para>
            An instance of <literal>com.espertech.esper.client.Configuration</literal> represents all configuration parameters. The <literal>Configuration</literal> is used to build an <literal>EPServiceProvider</literal>, which provides the administrative and runtime interfaces for an Esper engine instance.
        </para>

        <para>
            You may obtain a <literal>Configuration</literal> instance by instantiating it directly and adding or setting values on it. The <literal>Configuration</literal> instance is then passed to <literal>EPServiceProviderManager</literal> to obtain a configured Esper engine.
        </para>

		<programlisting><![CDATA[Configuration configuration = new Configuration();
configuration.addEventTypeAlias("PriceLimit", PriceLimit.class.getName());
configuration.addEventTypeAlias("StockTick", StockTick.class.getName());
configuration.addImport("org.mycompany.mypackage.MyUtility");
configuration.addImport("org.mycompany.util.*");

EPServiceProvider epService = EPServiceProviderManager.getProvider("sample", configuration);
]]></programlisting>

        <para>
			Note that <literal>Configuration</literal> is meant only as an initialization-time object. The Esper engine represented by an <literal>EPServiceProvider</literal> does not retain any association back to the <literal>Configuration</literal>.
        </para>
        
        <para>
			The <literal>ConfigurationOperations</literal> interface provides runtime configuration options. Through this interface applications can, for example, add new event types or aliases at runtime and then create new statements
			that rely on the additional configuration. The <literal>getConfiguration</literal> method on <literal>EPAdministrator</literal> allows access to <literal>ConfigurationOperations</literal>.
        </para>

    </sect1>

	<sect1 id="configuration-via-xml" revision="1">
        <title>Configuration via XML File</title>

		<indexterm><primary>configuration</primary><secondary>via XML</secondary></indexterm>
        <para>
			An alternative approach to configuration is to specify a configuration in a XML file. 
        </para>

        <para>
			The default name for the XML configuration file is <literal>esper.cfg.xml</literal>. Esper reads this file from the root of the <literal>CLASSPATH</literal> as an application resource via the <literal>configure</literal> method.
        </para>
		<programlisting><![CDATA[Configuration configuration = new Configuration();		
configuration.configure();
]]></programlisting>

        <para>
			The <literal>Configuration</literal> class can read the XML configuration file from other sources as well. The <literal>configure</literal> method accepts <literal>URL, File and String</literal> filename parameters.
        </para>
		<programlisting><![CDATA[Configuration configuration = new Configuration();		
configuration.configure("myengine.esper.cfg.xml");
]]></programlisting>
    </sect1>

	<sect1 id="configuration-xml" revision="1">
        <title>XML Configuration File</title>

        <para>
			Here is an example configuration file.
            The schema for the configuration file can be found in the <literal>etc</literal> folder and is named <literal>esper-configuration-2-0.xsd</literal>.
            It is also available online at <literal>http://www.espertech.com/schema/esper/esper-configuration-2.0.xsd</literal> so that IDE can fetch it automatically.
            The namespace used is <literal>http://www.espertech.com/schema/esper</literal>.
        </para>
		<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<esper-configuration xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://www.espertech.com/schema/esper"
    xsi:schemaLocation="
http://www.espertech.com/schema/esper http://www.espertech.com/schema/esper/esper-configuration-2.0.xsd">
  <event-type alias="StockTick" class="com.espertech.esper.example.stockticker.event.StockTick"/>
  <event-type alias="PriceLimit" class="com.espertech.esper.example.stockticker.event.PriceLimit"/>
  <auto-import import-name="org.mycompany.mypackage.MyUtility"/>
  <auto-import import-name="org.mycompany.util.*"/>
</esper-configuration>		
]]></programlisting>

        <para>
			The example above is only a subset of the configuration items available. The next chapters outline the available configuration in greater detail.
		</para>
    </sect1>

	<sect1 id="configuration-items" revision="1">
        <title>Configuration Items</title>

		<indexterm><primary>configuration</primary><secondary>items to configure</secondary></indexterm>
		<sect2 id="config-java" revision="1">
			<title>Events represented by Java Classes</title>
			
			<sect3 id="config-java-package-alias" revision="1">
				<title>Package of Java Event Classes</title>
				
				<para>
					Via this configuration an application can make the Java package or packages that contain an application's Java event classes known to an engine. 
					Thereby an application can simply refer to event types in statements by using the simple class name of
					each Java class representing an event type.
				</para>
								
				<para>
					For example, consider an order-taking application that places all event classes in package <literal>com.mycompany.order.event</literal>. One Java class representing an event is the class <literal>OrderEvent</literal>. 
					The application can simply issue a statement as follows to select <literal>OrderEvent</literal> events:
				</para>
				<programlisting><![CDATA[select * from OrderEvent]]></programlisting>

				<para>
					The XML configuration for defining the Java packages that contain Java event classes is:
				</para>
				<programlisting><![CDATA[<event-type-auto-alias package-name="com.mycompany.order.event"/>]]></programlisting>
				
				<para>
					The same configuration but using the <literal>Configuration</literal> class:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.addEventTypeAutoAlias("com.mycompany.order.event");
// ... or ...
config.addEventTypeAutoAlias(MyEvent.getPackage().getName());]]></programlisting>

			</sect3>

			<sect3 id="config-java-event-name" revision="1">
				<title>Event type alias to Java class mapping</title>
				
				<para>
					This configuration item can be used to allow event pattern statements and EPL statements to use an event type alias rather then the fully qualified Java class name. Note that Java Interface classes and abstract classes are also supported as event types via the fully qualified Java class name, and an event type alias can also be defined for such classes.
				</para>
				
				<para>
					The example pattern statement below first shows a pattern that uses the alias <literal>StockTick</literal>. The second pattern statement is equivalent but specifies the fully-qualified Java class name.
				</para>

				<programlisting><![CDATA[every StockTick(symbol='IBM')"]]></programlisting>
				<programlisting><![CDATA[every com.espertech.esper.example.stockticker.event.StockTick(symbol='IBM')]]></programlisting>

				<para>
					The event type alias can be listed in the XML configuration file as shown below. The <literal>Configuration</literal> API can also be used to programatically specify an event type alias, as shown in an earlier code snippet.
				</para>
				<programlisting><![CDATA[<event-type alias="StockTick" class="com.espertech.esper.example.stockticker.event.StockTick"/>]]></programlisting>
				
			</sect3>
			
			<sect3 id="config-java-legacy" revision="1">
				<title>Non-JavaBean and Legacy Java Event Classes</title>
				
				<para>
					Esper can process Java classes that provide event properties through other means then through JavaBean-style getter methods. It is not necessary that the method and member variable names in your Java class adhere to the JavaBean convention - any public methods and public member variables can be exposed as event properties via the below configuration.
				</para>
								
				<para>
					A Java class can optionally be configured with an accessor style attribute. This attribute instructs the engine how it should expose methods and fields for use as event properties in statements.
				</para>

				<table frame="topbot">
					<title>Accessor Styles</title>
					<tgroup cols="2">
						<colspec colwidth="1.5*"/>
						<colspec colwidth="2*"/>
						<thead>
							<row>
								<entry>Style Name</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>javabean</literal></entry>
								<entry>As the default setting, the engine exposes an event property for each public method following the JavaBean getter-method conventions</entry>
							</row>
							<row>
								<entry><literal>public</literal></entry>
								<entry>The engine exposes an event property for each public method and public member variable of the given class</entry>
							</row>
							<row>
								<entry><literal>explicit</literal></entry>
								<entry>The engine exposes an event property only for the explicitly configured public methods and public member variables</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
				
				<para>
					Using the <literal>public</literal> setting for the <literal>accessor-style</literal> attribute instructs the engine to expose an event property for each public method and public member variable of a Java class. The engine assigns event property names of the same name as the name of the method or member variable in the Java class.
				</para>
				
				<para>					
					For example, assuming the class <literal>MyLegacyEvent</literal> exposes a method named <literal>readValue</literal> and a member variable named <literal>myField</literal>, we can then use properties as shown. 
				</para>
				<programlisting><![CDATA[select readValue, myField from MyLegacyEvent]]></programlisting>

				<para>
					Using the <literal>explicit</literal> setting for the <literal>accessor-style</literal> attribute requires that event properties are declared via configuration. This is outlined in the next chapter.
				</para>

				<para>
					When configuring an engine instance from a XML configuration file, the XML snippet below demonstrates the use of the <literal>legacy-type</literal> element and the <literal>accessor-style</literal> attribute.
				</para>

				<programlisting><![CDATA[<event-type alias="MyLegacyEvent" class="com.mycompany.mypackage.MyLegacyEventClass">
  <legacy-type accessor-style="public"/>
</event-type>]]></programlisting>

				<para>
					When configuring an engine instance via Configuration API, the sample code below shows how to set the accessor style.
				</para>

				<programlisting><![CDATA[Configuration configuration = new Configuration();
ConfigurationEventTypeLegacy legacyDef = new ConfigurationEventTypeLegacy();
legacyDef.setAccessorStyle(ConfigurationEventTypeLegacy.AccessorStyle.PUBLIC);
config.addEventTypeAlias("MyLegacyEvent", MyLegacyEventClass.class.getName(), legacyDef);

EPServiceProvider epService = EPServiceProviderManager.getProvider("sample", configuration);
]]></programlisting>

			</sect3>

			<sect3 id="config-java-spec-properties" revision="1">
				<title>Specifying Event Properties for Java Classes</title>
				
				<para>
					Sometimes it may be convenient to use event property names in pattern and EPL statements that are backed up by a given public method or member variable (field) in a Java class. And it can be useful to declare multiple event properties that each map to the same method or member variable.
				</para>

				<para>
					We can configure properties of events via <literal>method-property</literal> and <literal>field-property</literal> elements, as the next example shows.
				</para>

				<programlisting><![CDATA[<event-type alias="StockTick" class="com.espertech.esper.example.stockticker.event.StockTickEvent">
	<legacy-type accessor-style="javabean" code-generation="enabled">
		<method-property name="price" accessor-method="getCurrentPrice" />
		<field-property name="volume" accessor-field="volumeField" />
	</legacy-type>
</event-type>]]></programlisting>

				<para>
					The XML configuration snippet above declared an event property named <literal>price</literal> backed by a getter-method named <literal>getCurrentPrice</literal>, and a second event property named <literal>volume</literal> that is backed by a public member variable named <literal>volumeField</literal>. Thus the price and volume properties can be used in a statement:
				</para>								
				<programlisting><![CDATA[select avg(price * volume) from StockTick]]></programlisting>

				<para>
					As with all configuration options, the API can also be used:
				</para>

				<programlisting><![CDATA[Configuration configuration = new Configuration();
ConfigurationEventTypeLegacy legacyDef = new ConfigurationEventTypeLegacy();
legacyDef.addMethodProperty("price", "getCurrentPrice");
legacyDef.addFieldProperty("volume", "volumeField");
config.addEventTypeAlias("StockTick", StockTickEvent.class.getName(), legacyDef);]]></programlisting>
			</sect3>

			<sect3 id="config-java-codegen" revision="1">
				<title>Turning off Code Generation</title>
				
				<para>
					Esper employes the <literal>CGLIB</literal> library for very fast read access to event property values. For certain legacy Java classes it may be desirable to disable the use of this library and instead use Java reflection to obtain event property values from event objects.
				</para>
								
				<para>
					In the XML configuration, the optional <literal>code-generation</literal> attribute in the <literal>legacy-type</literal> section can be set to <literal>disabled</literal> as shown next.
				</para>
				<programlisting><![CDATA[<event-type alias="MyLegacyEvent" class="com.mycompany.package.MyLegacyEventClass">
	<legacy-type accessor-style="javabean" code-generation="disabled" />
</event-type>
]]></programlisting>

				<para>
					The sample below shows how to configure this option via the API.
				</para>

				<programlisting><![CDATA[Configuration configuration = new Configuration();
ConfigurationEventTypeLegacy legacyDef = new ConfigurationEventTypeLegacy();
legacyDef.setCodeGeneration(ConfigurationEventTypeLegacy.CodeGeneration.DISABLED);
config.addEventTypeAlias("MyLegacyEvent", MyLegacyEventClass.class.getName(), legacyDef);]]></programlisting>

			</sect3>

			<sect3 id="config-java-property-case-sensitivity" revision="1">
				<title>Case Sensitivity and Property Names</title>
				
				<para>
					By default the engine resolves Java event properties case sensitive. That is, property names in statements must match JavaBean-convention property names in name and case. This option controls case sensitivity per Java class.
				</para>
								
				<para>
					In the configuration XML, the optional <literal>property-resolution-style</literal> attribute in the <literal>legacy-type</literal> element can be set to any of these values:
				</para>

				<table frame="topbot">
					<title>Property Resolution Case Sensitivity Styles</title>
					<tgroup cols="2">
						<colspec colwidth="1.5*"/>
						<colspec colwidth="2*"/>
						<thead>
							<row>
								<entry>Style Name</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>case_sensitive (default)</literal></entry>
								<entry>As the default setting, the engine matches property names for the exact name and case only.</entry>
							</row>
							<row>
								<entry><literal>case_insensitive</literal></entry>
								<entry>Properties are matched if the names are identical.  A case insensitive search is used and will choose the first property that matches the name exactly 
											or the first property that matches case insensitively should no match be found.
								</entry>
							</row>
							<row>
								<entry><literal>distinct_case_insensitive</literal></entry>
								<entry>Properties are matched if the names are identical.  A case insensitive search is used and will choose the first property that matches the name exactly case insensitively.  If more than one 'name' can be mapped to the property an exception is thrown.</entry>
							</row>
						</tbody>
					</tgroup>
				</table>

				<para>
					The sample below shows this option in XML configuration, however the setting can also be changed via API:
				</para>
				<programlisting><![CDATA[<event-type alias="MyLegacyEvent" class="com.mycompany.package.MyLegacyEventClass">
  <legacy-type property-resolution-style="case_insensitive"/>
</event-type>]]></programlisting>

			</sect3>

		</sect2>
			
		<sect2 id="config-java-util-map" revision="1">
			<title>Events represented by <literal>java.util.Map</literal></title>
			
			<para>
				The engine can process <literal>java.util.Map</literal> events via the <literal>sendEvent(Map map, String eventTypeAlias)</literal> method on the <literal>EPRuntime</literal> interface. Entries in the Map represent event properties. Keys must be of type <literal>java.util.String</literal> for the engine to be able to look up event property names in pattern or EPL statements. Values can be of any type. JavaBean-style objects as values in a <literal>Map</literal> can be processed by the engine, and strongly-typed nested maps are also supported. Please see the <xref linkend="event_representation"/> section for details on how to use <literal>Map</literal> events with the engine.
			</para>
			
			<para>
				Via configuration we provide an event type alias name for <literal>Map</literal> events for use in statements, and the event property names and types enabling the engine to validate properties in statements.
			</para>
			
			<para>
				The below snippet of XML configuration configures an event named <literal>MyMapEvent</literal>.
			</para>

			<programlisting><![CDATA[<event-type alias="MyMapEvent">
  <java-util-map>
    <map-property name="carId" class="int"/>
    <map-property name="carType" class="string"/>
    <map-property name="assembly" class="com.mycompany.Assembly"/>    
  </java-util-map>
</event-type>]]></programlisting>

			<para>
				This configuration defines the <literal>carId</literal> property of <literal>MyMapEvent</literal> events to be of type <literal>int</literal>, and the <literal>carType</literal> property to be of type <literal>java.util.String</literal>. The <literal>assembly</literal> property of the Map event will contain instances of <literal>com.mycompany.Assembly</literal> for the engine to query.
			</para>

			<para>
				The valid list of values for the type definition via the <literal>class</literal> attribute is:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						<literal>string</literal> or <literal>java.lang.String</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>char</literal> or <literal>java.lang.Character</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>byte</literal> or <literal>java.lang.Byte</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>short</literal> or <literal>java.lang.Short</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>int</literal> or <literal>java.lang.Integer</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>long</literal> or <literal>java.lang.Long</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>float</literal> or <literal>java.lang.Float</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>double</literal> or <literal>java.lang.Double</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>boolean</literal> or <literal>java.lang.Boolean</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						Any fully-qualified Java class name that can be resolved by the engine via <literal>Class.forName</literal>
					</para>
				</listitem>
			</itemizedlist>

			<para>
				 You can also use the configuration API to configure <literal>Map</literal> event types, as the short code snippet below demonstrates:
			</para>

			<programlisting><![CDATA[Properties properties = new Properties();
properties.put("carId", "int");
properties.put("carType", "string");
properties.put("assembly", Assembly.class.getName());

Configuration configuration = new Configuration();
configuration.addEventTypeAlias("MyMapEvent", properties);]]></programlisting>

			<para>
				 For strongly-typed nested maps (maps-within-maps), the configuration API method <literal>addNestableEventTypeAlias</literal> must be used to define the nested types. The XML configuration does not provide the capability to configure nested maps.
			</para>

			<para>
				Finally, here is a sample EPL statement that uses the configured <literal>MyMapEvent</literal> map event. This statement uses the <literal>chassisTag</literal> and <literal>numParts</literal> properties of <literal>Assembly</literal> objects in each map.
			</para>
			<programlisting>select carType, assembly.chassisTag, count(assembly.numParts) from MyMapEvent.win:time(60 sec)</programlisting>

		</sect2>
		
		<sect2 id="config-xml-dom" revision="1">
			<title>Events represented by <literal>org.w3c.dom.Node</literal></title>
			
			<para>
				Via this configuration item the Esper engine can natively process <literal>org.w3c.dom.Node</literal> instances, i.e. XML document object model (DOM) nodes.
				Please see the <xref linkend="event_representation"/> section for details on how to use <literal>Node</literal> events with the engine.
			</para>
			
			<para>
				Esper allows configuring XPath expressions as event properties. You can specify arbitrary XPath functions or expressions and provide a property name by which their result values will be available for use in expressions. 
			</para>
				
			<para>
				For XML documents that follow a XML schema, Esper can load and interrogate your schema and validate event property names and types against the schema information. 
			</para>

			<para>
				Nested, mapped and indexed event properties are also supported in expressions against <literal>org.w3c.dom.Node</literal> events. Thus XML trees can conveniently be
				interrogated using the existing event property syntax for querying JavaBean objects, JavaBean object graphs or <literal>java.util.Map</literal> events.
			</para>

			<para>
				In the simplest form, the Esper engine only requires a configuration entry containing the root element name and the event type alias in order to process <literal>org.w3c.dom.Node</literal> events:
			</para>
			<programlisting><![CDATA[<event-type alias="MyXMLNodeEvent">
  <xml-dom root-element-name="myevent" />
</event-type>]]></programlisting>
			
			<para>
				 You can also use the configuration API to configure XML event types, as the short example below demonstrates. 
				 In fact, all configuration options available through XML configuration can 
				 also be provided via setter methods on the <literal>ConfigurationEventTypeXMLDOM</literal> class.
			</para>

			<programlisting><![CDATA[Configuration configuration = new Configuration();
ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setRootElementName("myevent");
desc.addXPathProperty("name1", "/element/@attribute", XPathConstants.STRING);
desc.addXPathProperty("name2", "/element/subelement", XPathConstants.NUMBER);
configuration.addEventTypeAlias("MyXMLNodeEvent", desc);]]></programlisting>

			<para>
				 The next example presents configuration options in a sample configuration entry.
			</para>

			<programlisting><![CDATA[<event-type alias="AutoIdRFIDEvent">
  <xml-dom root-element-name="Sensor" schema-resource="data/AutoIdPmlCore.xsd" 
       default-namespace="urn:autoid:specification:interchange:PMLCore:xml:schema:1">
    <namespace-prefix prefix="pmlcore" 
       namespace="urn:autoid:specification:interchange:PMLCore:xml:schema:1"/>
    <xpath-property property-name="countTags" 
       xpath="count(/pmlcore:Sensor/pmlcore:Observation/pmlcore:Tag)" type="number"/>
  </xml-dom>
</event-type>]]></programlisting>

			<para>
				 This example configures an event property named <literal>countTags</literal> whose value is computed by an XPath expression. The namespace prefixes
				 and default namespace are for use with XPath expressions and must also be made known to the engine in order for the engine to compile XPath expressions. 
				 Via the <literal>schema-resource</literal> attribute we instruct the engine to load a schema file.
			</para>
			
			<para>
				 Here is an example EPL statement using the configured event type named <literal>AutoIdRFIDEvent</literal>.
			</para>

			<programlisting><![CDATA[select ID, countTags from AutoIdRFIDEvent.win:time(30 sec)]]></programlisting>

			<sect3 id="config-xml-dom-schema" revision="1">
				<title>Schema Resource</title>
				<para>
					 The <literal>schema-resource</literal> attribute takes a schema resource URL or classpath-relative filename. 
					 The engine attempts to resolve the schema resource as an URL. If the schema resource name is not a valid URL, the engine attempts to resolve the resource from classpath via the <literal>ClassLoader.getResource</literal> method using the thread context class loader. If the name could not be resolved, the engine uses the Configuration class classloader.
				</para>

				<para>
					 By configuring a schema file for the engine to load, the engine performs these additional services:
				</para>
				
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							Validates the event properties in a statement, ensuring the event property name matches an attribute or element in the XML
						</para>
					</listitem>
					<listitem>
						<para>
							Determines the type of the event property allowing event properties to be used in type-sensitive expressions such as expressions involving arithmetic (Note: XPath properties are also typed)
						</para>
					</listitem>
					<listitem>
						<para>
							Matches event property names to either element names or attributes
						</para>
					</listitem>
				</itemizedlist>

				<para>
					 If no schema resource is specified, none of the event properties specified in statements are validated at statement creation time and their type defaults to <literal>java.lang.String</literal>. Also, attributes are not supported
					 if no schema resource is specified and must thus be declared via XPath expression.
				</para>

		  </sect3>

			<sect3 id="config-xml-dom-xpathprop" revision="1">
				<title>XPath Property</title>
				<para>
					 The <literal>xpath-property</literal> element adds event properties to the event type that are computed via an XPath expression.
					 In order for the XPath expression to compile, be sure to specify the <literal>default-namespace</literal> attribute and use the 
					 <literal>namespace-prefix</literal> to declare namespace prefixes.
				</para>
					 
				<para>
					 XPath expression properties are strongly typed. The <literal>type</literal> attribute allows the following values. These values correspond to those declared by 
					 <literal>javax.xml.xpath.XPathConstants</literal>.
				</para>

				<itemizedlist spacing="compact">
					<listitem>
						<para>
							number (Note: resolves to a <literal>double</literal>)
						</para>
					</listitem>
					<listitem>
						<para>
							string
						</para>
					</listitem>
					<listitem>
						<para>
							boolean
						</para>
					</listitem>
				</itemizedlist>
				
		  </sect3>
		  
			<sect3 id="config-xml-dom-absolute" revision="1">
				<title>Absolute or Deep Property Resolution</title>
				
				<para>
					This setting indicates that when properties are compiled to XPath expressions that the compilation should generate an absolute XPath expression or a deep (find element) XPath expression. 					
				</para>

				<para>
					For example, consider the following statement against an event type that is represented by a XML DOM document, assuming the event type GetQuote has been configured with the engine as a XML DOM event type:
				</para>
				<programlisting><![CDATA[select request, request.symbol from GetQuote]]></programlisting>

				<para>
					By default, the engine compiles the "request" property name to an XPath expression "/GetQuote/request". It compiles the nested property named "request.symbol" to an XPath expression "/GetQuote/request/symbol", wherein the root element node is "GetQuote".
				</para>

				<para>
					By setting absolute property resolution to false, the engine compiles the "request" property name to an XPath expression "//request". It compiles the nested property named "request.symbol" to an XPath expression "//request/symbol".
					This enables these elements to be located anywhere in the XML document.
				</para>

				<para>
					The setting is available in XML via the attribute <literal>resolve-properties-absolute</literal>.
				</para>

				<para>
					The configuration API provides the above settings as shown here in a sample code:
				</para>

				<programlisting><![CDATA[ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setRootElementName("GetQuote");
desc.setDefaultNamespace("http://services.samples/xsd");
desc.setRootElementNamespace("http://services.samples/xsd");
desc.addNamespacePrefix("m0", "http://services.samples/xsd");
desc.setResolvePropertiesAbsolute(false);
configuration.addEventTypeAlias("GetQuote", desc);]]></programlisting>
			
		  </sect3>

		</sect2>
					
		<sect2 id="config-class--package-imports" revision="1">
			<title>Class and package imports</title>
			
			<para>
				Esper allows invocations of static Java library functions in expressions, as outlined in <xref linkend="epl-single-row-function-ref"/>. This configuration 
				item can be set to allow a partial rather than a fully qualified class name in such invocations. The imports work in the same way as in Java files, so both packages and classes can be imported.
			</para>
			
			<programlisting>select Math.max(priceOne, PriceTwo)
// via configuration equivalent to
select java.lang.Math.max(priceOne, priceTwo)</programlisting>

			<para>
				Esper auto-imports the following Java library packages if no other configuration is supplied.
				This list is replaced with any configuration specified in a configuration file or through the API.
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						java.lang.*
					</para>
				</listitem>
				<listitem>
					<para>
						java.math.*
					</para>
				</listitem>
				<listitem>
					<para>
						java.text.*
					</para>
				</listitem>
				<listitem>
					<para>
						java.util.*
					</para>
				</listitem>
			</itemizedlist>

			<para>
				In a XML configuration file the auto-import configuration may look as below:
			</para>

		<programlisting><![CDATA[<auto-import import-name="com.mycompany.mypackage.*"/>
<auto-import import-name="com.mycompany.myapp.MyUtilityClass"/>]]></programlisting>

			<para>
				Here is an example of providing imports via the API:
			</para>

		<programlisting><![CDATA[Configuration config = new Configuration();
config.addImport("com.mycompany.mypackage.*");	// package import
config.addImport("com.mycompany.mypackage.MyLib");   // class import]]></programlisting>
		</sect2>

		<sect2 id="config-method-invocations" revision="1">
			<title>Cache Settings for Method Invocations</title>
			
			<para>
				Method invocations are allowed in the <literal>from</literal> clause in EPL, such that your application may join event streams to the data returned by a web service, or to data read from a distributed cache or object-oriented database, or obtain data by other means. A local cache may be placed in front of such method invocations through the configuration settings described herein.
			</para>
			
			<para>
				The LRU cache is described in detail in <xref linkend="config-database-cache-lru"/>. The expiry-time cache documentation can be found in <xref linkend="config-database-cache-expiry"/>
			</para>
			
			<para>
				The next XML snippet is a sample cache configuration that applies to methods provided by the classes 'MyFromClauseLookupLib'  and 'MyFromClauseWebServiceLib'. The XML and API configuration understand both the fully-qualified Java class name, as well as the simple class name:
			</para>			
			<programlisting><![CDATA[<method-reference class-name="com.mycompany.MyFromClauseLookupLib">
  <expiry-time-cache max-age-seconds="10" purge-interval-seconds="10" ref-type="weak"/>
</method-reference> 	
<method-reference class-name="MyFromClauseWebServiceLib">
  <lru-cache size="1000"/>
</method-reference> ]]></programlisting>
		</sect2>

		<sect2 id="config-variables" revision="1">
			<title>Variables</title>
			
			<para>
				Variables can be created dynamically in EPL via the <literal>create variable</literal> syntax but can also be configured at runtime and at configuration time.
			</para>
			
			<para>
				A variable is declared by specifying a variable name, the variable type and an optional initialization value. The initialization value can be of the same or compatible type as the variable type, or can also be a String value that, when parsed, is compatible to the type declared for the variable.
			</para>

			<para>
				In a XML configuration file the variable configuration may look as below. The <literal>Configuration</literal> API can also be used to configure variables.
			</para>

		<programlisting><![CDATA[<variable name="var_threshold" type="long" initialization-value="100"/>
<variable name="var_key" type="string"/>]]></programlisting>

		</sect2>

		<sect2 id="config-database-ref" revision="1">
			<title>Relational Database Access</title>
			
			<para>
				Esper has the capability to join event streams against historical data sources, such as a relational database. This section describes the configuration entries that the engine requires to access data stored in your database. Please see <xref linkend="histdata_overview"/> for information on the use of EPL queries that include historical data sources.
			</para>
			
			<para>
					EPL queries that poll data from a relational database specify the name of the database as part of the EPL statement. The engine uses the configuration information described here to resolve the database name in the statement to database settings. The required and optional database settings are summarized below. 
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Database connections can be obtained via JDBC <literal>javax.xml.DataSource</literal> or alternatively via <literal>java.sql.DriverManager</literal>. Either one of these methods to obtain new database connections is a required configuration.
					</para>
				</listitem>
				<listitem>
					<para>
						Optionally, JDBC connection-level settings such as auto-commit, transaction isolation level, read-only and the catalog name can be defined.
					</para>
				</listitem>
				<listitem>
					<para>
						Optionally, a connection lifecycle can be set to indicate to the engine whether the engine must retain connections or must obtain a new connection for each lookup.
					</para>
				</listitem>
				<listitem>
					<para>
						Optionally, define a cache policy to allow the engine to retrieve data from a query cache, reducing the number of query executions.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Some of the settings can have important performance implications that need to be carefully considered in relationship to your database software, JDBC driver and runtime environment. This section attempts to outline such implications where appropriate.
			</para>

			<para>
				The sample XML configuration file in the "etc" folder can be used as a template for configuring database settings. All settings are also available by means of the configuration API through the classes <literal>Configuration</literal> and <literal>ConfigurationDBRef</literal>.
			</para>
						
			<sect3 id="config-database-datasource" revision="1">
				<title>Connections obtained via DataSource</title>

				<para>
				The snippet of XML below configures a database named <literal>mydb1</literal> to obtain connections via a <literal>javax.sql.DataSource</literal>. The <literal>datasource-connection</literal> element instructs the engine to obtain new connections to the database <literal>mydb1</literal> by performing a lookup via <literal>javax.naming.InitialContext</literal> for the given object lookup name. Optional environment properties for the <literal>InitialContext</literal> are also shown in the example.
				</para>

				<programlisting><![CDATA[<database-reference name="mydb1">
  <datasource-connection context-lookup-name="java:comp/env/jdbc/mydb">
    <env-property name="java.naming.factory.initial" value ="com.myclass.CtxFactory"/>
    <env-property name="java.naming.provider.url" value ="iiop://localhost:1050"/>
  </datasource-connection>
</database-reference>]]></programlisting>

				<para>
					To help you better understand how the engine uses this information to obtain connections, we have included the logic below.
				</para>
				<programlisting><![CDATA[if (envProperties.size() > 0) {
  initialContext = new InitialContext(envProperties);
}
else {
  initialContext = new InitialContext();
}
DataSource dataSource = (DataSource) initialContext.lookup(lookupName);
Connection connection = dataSource.getConnection();]]></programlisting>
			</sect3>

			<sect3 id="config-database-drivermanager" revision="1">
				<title>Connections obtained via DriverManager</title>

				<para>
				The next snippet of XML configures a database named <literal>mydb2</literal> to obtain connections via <literal>java.sql.DriverManager</literal>. The <literal>drivermanager-connection</literal> element instructs the engine to obtain new connections to the database <literal>mydb2</literal> by means of <literal>Class.forName</literal> and <literal>DriverManager.getConnection</literal> using the class name, URL and optional username, password and connection arguments.
				</para>

				<programlisting><![CDATA[<database-reference name="mydb2">
  <drivermanager-connection class-name="my.sql.Driver" 
        url="jdbc:mysql://localhost/test?user=root&amp;password=mypassword" 
        user="myuser" password="mypassword">
    <connection-arg name="user" value ="myuser"/>
    <connection-arg name="password" value ="mypassword"/>
    <connection-arg name="somearg" value ="someargvalue"/>
  </drivermanager-connection>
</database-reference>]]></programlisting>

				<para>
					The username and password are shown in multiple places in the XML only as an example. Please check with your database software on the required information in
					URL and connection arguments.
				</para>
			</sect3>

			<sect3 id="config-database-connections" revision="1">
				<title>Connections-level settings</title>

				<para>
					Additional connection-level settings can optionally be provided to the engine which the engine will apply to new connections. When the engine obtains a new connection, it applies only those settings to the connection that are explicitly configured. The engine leaves all other connection settings at default values.
				</para>

				<para>
					The below XML is a sample of all available configuration settings. Please refer to the Java API JavaDocs for <literal>java.sql.Connection</literal> for more information to each option or check the documentation of your JDBC driver and database software.
				</para>
				
				<programlisting><![CDATA[<database-reference name="mydb2">
... configure data source or driver manager settings...
  <connection-settings auto-commit="true" catalog="mycatalog" 
      read-only="true" transaction-isolation="1" />
</database-reference>]]></programlisting>

				<para>
					The <literal>read-only</literal> setting can be used to indicate to your database engine that SQL statements are read-only. The <literal>transaction-isolation</literal> and <literal>auto-commit</literal> help you database software perform the right level of locking and lock release. Consider setting these values to reduce transactional overhead in your database queries.
				</para>
			</sect3>

			<sect3 id="config-database-connections-lifecycle" revision="1">
				<title>Connections lifecycle settings</title>

				<para>
					By default the engine retains a separate database connection for each started EPL statement. However, it is possible to override this behavior and require the engine to obtain a new database connection for each lookup, and to close that database connection after the lookup is completed. This often makes sense when you have a large number of EPL statements and require pooling of connections via a connection pool. If your runtime environment includes an application server, the connection pool may be exposed as a <literal>DataSource</literal>.
				</para>

				<para>
					The XML for this option is below. The connection lifecycle allows the following values: <literal>pooled</literal> and <literal>retain</literal>.
				</para>
				
				<programlisting><![CDATA[<database-reference name="mydb2">
... configure data source or driver manager settings...
    <connection-lifecycle value="pooled"/>
</database-reference>]]></programlisting>
			</sect3>

			<sect3 id="config-database-cache" revision="1">
				<title>Cache settings</title>

				<para>
					Cache settings can dramatically reduce the number of database queries that the engine executes for EPL statements. If no cache setting is specified, the engine does not cache query results and executes a separate database query for every event.
				</para>
	
				<para>
					Caches store the results of database queries and make these results available to subsequent queries using the exact same query parameters as the query for which
					the result was stored. If your query returns one or more rows, the cache keep the result rows of the query keyed to the parameters of the query. If your query returns no rows, the cache also keeps the empty result. Query results are held by a cache until the cache entry is evicted. The strategies available for evicting cached 
					query results are listed next.
				</para>

				<sect4 id="config-database-cache-lru" revision="1">
					<title>LRU Cache</title>
					
					<para>
						The least-recently-used (LRU) cache is configured by a maximum size. The cache discards the least recently used query results first once the cache reaches the maximum size.
					</para>
					
					<para>
						The XML configuration entry for a LRU cache is as below. This entry configures an LRU cache holding up to 1000 query results.
					</para>

					<programlisting><![CDATA[<database-reference name="mydb">
... configure data source or driver manager settings...
    <lru-cache size="1000"/>
</database-reference>]]></programlisting>
				</sect4>

				<sect4 id="config-database-cache-expiry" revision="1">
					<title>Expiry-time Cache</title>
					
					<para>
						The expiry time cache is configured by a maximum age in seconds, a purge interval and an optional reference type. The cache discards (on the get operation) any query results that are older then the maximum age so that stale data is not used. If the cache is not empty, then every purge interval number of seconds the engine purges any expired entries from the cache.
					</para>
					
					<para>
						The XML configuration entry for an expiry-time cache is as follows. The example configures an expiry time cache in which prior query results are valid for 60 seconds and which the engine inspects every 2 minutes to remove query results older then 60 seconds.
					</para>

					<programlisting><![CDATA[<database-reference name="mydb">
... configure data source or driver manager settings...
    <expiry-time-cache max-age-seconds="60" purge-interval-seconds="120" />
</database-reference>]]></programlisting>

					<para>
						By default, the expiry-time cache is backed by a <literal>java.util.WeakHashMap</literal> and thus relies on weak references. That means that cached SQL results can be freed during garbage collection. 
					</para>

					<para>
						Via XML or using the configuration API the type of reference can be configured to not allow entries to be garbage collected, by setting the <literal>ref-type</literal> property to <literal>hard</literal>:
					</para>

					<programlisting><![CDATA[<database-reference name="mydb">
... configure data source or driver manager settings...
    <expiry-time-cache max-age-seconds="60" purge-interval-seconds="120" ref-type="hard"/>
</database-reference>]]></programlisting>
				</sect4>

					<para>
						The last setting for the cache reference type is <literal>soft</literal>: This strategy allows the garbage collection of cache entries only when all other weak references have been collected.
					</para>
			</sect3>

			<sect3 id="config-database-columnchangecase" revision="1">
				<title>Column Change Case</title>
				
				<para>
					This setting instructs the engine to convert to lower- or uppercase any output column names returned by your database system. When using Oracle relational database software, for example, column names
					can be changed to lowercase via this setting.
				</para>
				
				<para>
					A sample XML configuration entry for this setting is:
				</para>
				<programlisting><![CDATA[<column-change-case value="lowercase"/>]]></programlisting>				
			</sect3>

			<sect3 id="config-database-sqltypes" revision="1">
				<title>SQL Types Mapping</title>				
				<para>
					By providing a mapping of SQL types (<literal>java.sql.Types</literal>) to Java built-in types your code can avoid using sometimes awkward default database types and can easily change the way Esper
					returns Java types for columns returned by a SQL query.
				</para>
				
				<para>
					The mapping maps a constant as defined by <literal>java.sql.Types</literal> to a Java built-in type of any of the following Java type names: <literal>String, BigDecimal, Boolean, Byte, Short, Int, Long, Float, Double, ByteArray, SqlDate, SqlTime, SqlTimestamp</literal>.  The Java type names are not case-sensitive.
				</para>
				
				<para>
					A sample XML configuration entry for this setting is shown next. The sample maps <literal>Types.NUMERIC</literal> (of value <literal>2</literal>) to the Java <literal>int</literal> type.
				</para>
				<programlisting><![CDATA[<sql-types-mapping sql-type="2" java-type="int" />]]></programlisting>				
			</sect3>

			<sect3 id="config-database-metadata" revision="1">
				<title>Metadata Origin</title>
				
				<para>
					This setting controls how the engine retrieves SQL statement metadata from JDBC prepared statements.
				</para>
				
				<table frame="topbot" id="epl-grouping-aggregate-func" revision="2">
					<title>Syntax and results of aggregate functions</title>
					<tgroup cols="2">
						<colspec colwidth="0.5*"/>
						<colspec colwidth="2.0*"/>
						<thead>
							<row>
								<entry>Option</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>default</entry>
								<entry>
									<para>
										By default, the engine detects the driver name and queries prepared statement metadata if the driver is not an Oracle database driver. For Oracle drivers, the engine uses
										lexical analysis of the SQL statement to construct a sample SQL statement and then fires that statement to retrieve statement metadata.
									</para>
								</entry>
							</row>
							<row>
								<entry>metadata</entry>
								<entry>
									<para>
										The engine always queries prepared statement metadata regardless of the database driver used.
									</para>
								</entry>
							</row>
							<row>
								<entry>sample</entry>
								<entry>
									<para>
										The engine always uses lexical analysis of the SQL statement to construct a sample SQL statement, and then fires that statement to retrieve statement metadata.
									</para>
								</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</sect3>
		</sect2>

		<sect2 id="config-engine-threading" revision="1">
			<title>Engine Settings related to Concurrency and Threading</title>
			
			<sect3 id="config-engine-threading-dispatch" revision="1">
				<title>Preserving the order of events delivered to listeners</title>

				<para>
					In multithreaded environments, this setting controls whether dispatches of statement result events to listeners preserve the ordering in which a statement processes events. By default the engine guarantees that it delivers a statement's result events to statement listeners in the order in which the result is generated. This behavior can be turned off via configuration as below. 
				</para>
				
				<para>
					The next code snippet shows how to control this feature:
				</para>
					<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getThreading().setListenerDispatchPreserveOrder(false);
engine = EPServiceProviderManager.getDefaultProvider(config);]]></programlisting>
				
				<para>
					And the XML configuration file can also control this feature by adding the following elements:
				</para>
					<programlisting><![CDATA[<engine-settings>
  <defaults>
    <threading>
      <listener-dispatch preserve-order="true" timeout-msec="1000" locking="spin"/>
    </threading>
  </defaults>
</engine-settings>]]></programlisting>

				<para>
					As discussed, by default the engine can temporarily block another processing thread when delivering result events to listeners in order to preserve the order in which results are delivered to a given statement. The maximum time the engine blocks a thread can also be configured, and by default is set to 1 second.
				</para>

				<para>
					As such delivery locks are typically held for a very short amount of time, the default blocking technique employs a spin lock (There are two techniques for implementing blocking; having the operating system suspend the thread until it is awakened later or using spin locks). While spin locks are CPU-intensive and appear inefficient, a spin lock can be more efficient than suspending the thread and subsequently waking it up, especially if the lock in question is held for a very short time. That is because there is significant overhead to suspending and rescheduling a thread.  
				</para>
				
				<para>
					The locking technique can be changed to use a blocking strategy that suspends the thread, by means of setting the locking property to 'suspend'.
				</para>
			</sect3>

			<sect3 id="config-engine-threading-insert-into" revision="1">
				<title>Preserving the order of events for insert-into streams</title>

				<para>
					In multithreaded environments, this setting controls whether statements producing events for other statements via insert-into preserve the order of delivery within the producing and consuming statements, allowing statements that consume other statement's events to behave deterministic in multithreaded applications, if the consuming statement requires such determinism. By default, the engine makes this guarantee (the setting is on).
				</para>

				<para>
					Take, for example, an application where a single statement (S1) inserts events into a stream that another statement (S2) further evaluates. A multithreaded application may have multiple threads processing events into statement S1. As statement S1 produces events for consumption by statement S2, such results may need to be delivered in the exact order produced as the consuming statement may rely on the order received. For example, if the first statement counts the number of events, the second statement may employ a pattern that inspects counts and thus expect the counts posted by statement S1 to continuously increase by 1 even though multiple threads process events. 
				</para>

				<para>
					The engine may need to block a thread such that order of delivery is maintained, and statements that require order (such as pattern detection, previous and prior functions) receive a deterministic order of events. The settings available control the blocking technique and parameters. As described in the section immediately prior, the default blocking technique employs spin locks per statement inserting events for consumption, as the locks in questions are typically held a very short time. The 'suspend' blocking technique can be configured and a timeout value can also defined.
				</para>
				
				<para>
					The XML configuration file may change settings via the following elements:
				</para>
					<programlisting><![CDATA[<engine-settings>
  <defaults>
    <threading>
      <insert-into-dispatch preserve-order="true" timeout-msec="100" locking="spin"/>
    </threading>
  </defaults>
</engine-settings>]]></programlisting>
			</sect3>

			<sect3 id="config-engine-threading-internal-timer" revision="1">
				<title>Internal Timer Settings</title>

				<para>
					This option can be used to disable the internal timer thread and such have the application supply external time events, as well as to set a timer resolution.
				</para>

				<para>
					The next code snippet shows how to disable the internal timer thread via the configuration API:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
  config.getEngineDefaults().getThreading().setInternalTimerEnabled(false);]]></programlisting>
  
				<para>
					This snippet of XML configuration leaves the internal timer enabled (the default) and sets a resolution of 200 milliseconds (the default is 100 milliseconds):
				</para>
				<programlisting><![CDATA[<engine-settings>
  <defaults>
    <threading>
      <internal-timer enabled="true" msec-resolution="200"/>
    </threading>
  </defaults>
</engine-settings>]]></programlisting>
			</sect3>

				<para>
					We recommend that when disabling the internal timer, applications send an external timer event setting the start time before creating statements,
					such that statement start time is well-defined.
				</para>
		</sect2>

		<sect2 id="config-engine-eventmeta" revision="1">
			<title>Engine Settings related to Event Metadata</title>
			
			<sect3 id="config-engine-eventmeta-propertyreso" revision="1">
				<title>Java Class Property Names and Case Sensitivity</title>

				<para>
				  As discussed in <xref linkend="config-java-property-case-sensitivity"/> this setting controls case sensitivity for Java event class properties of all Java classes as a default, rather then at a class level.
				</para>

				<para>
					The next code snippet shows how to control this feature via the API:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getEventMeta().setClassPropertyResolutionStyle(
    Configuration.PropertyResolutionStyle.CASE_INSENSITIVE);]]></programlisting>
			</sect3>
		</sect2>

		<sect2 id="config-engine-viewresources" revision="1">
			<title>Engine Settings related to View Resources</title>
			
			<sect3 id="config-engine-viewresources-sharing" revision="1">
				<title>Sharing View Resources between Statements</title>

				<para>
				   The engine by default attempts to optimize resource usage and thus re-uses or shares views between statements that declare same views. However, in multi-threaded environments, this can lead to reduced concurrency as 
				   locking for shared view resources must take place. Via this setting this behavior can be turned off for higher concurrency in multi-threaded processing.
				</para>

				<para>
					The next code snippet outlines the API to turn off view resource sharing between statements:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getViewResources().setShareViews(false);]]></programlisting>
			</sect3>
		</sect2>

		<sect2 id="config-engine-logging" revision="1">
			<title>Engine Settings related to Logging</title>
			
			<sect3 id="config-engine-logging-execpath" revision="1">
				<title>Execution Path Debug Logging</title>

				<para>
				   By default, the engine does not produce debug output for the event processing execution paths even when Log4j or Logger configurations have been set to output debug level logs.
				   To enable debug level logging, set this option in the configuration as well as in your Log4j configuration file.
				</para>

				<para>
					The API to use to enable debug logging is shown here:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getLogging().setEnableExecutionDebug(true);]]></programlisting>

				<para>
					Note: this is a configuration option that applies to all engine instances of a given Java module or VM.
				</para>
			</sect3>
		</sect2>

		<sect2 id="config-engine-variables" revision="1">
			<title>Engine Settings related to Variables</title>
			
			<sect3 id="config-engine-variables-lifetimeold" revision="1">
				<title>Variable Version Release Interval</title>

				<para>
				   This setting controls the length of time that the engine retains variable versions for use by statements that use variables and that execute, within the same statement for the same event, longer then the time interval.
				   By default, the engine retains 15 seconds of variable versions.
				</para>

				<para>
				   For statements that use variables and that execute (in response to a single timer or other event) longer then the time period, the engine returns the current variable version at the time the statement executes, thereby softening the guarantee of consistency of variable values within the long-running statement. Please see <xref linkend="variable_using"/> for more information.
				</para>

				<para>
					The XML configuration for this setting is shown below:
				</para>
					<programlisting><![CDATA[<engine-settings>
  <defaults>
    <variables>
      <msec-version-release value="15000"/>
    </variables>
  </defaults>
</engine-settings>]]></programlisting>

			</sect3>
		</sect2>

		<sect2 id="config-engine-stream-selection" revision="1">
			<title>Engine Settings related to Stream Selection</title>
			
			<sect3 id="config-engine-streamselect-choices" revision="1">
				<title>Default Statement Stream Selection</title>

				<para>
				   Statements can produce both insert stream (new data) and remove stream (old data) results. Remember that insert stream refers to arriving events and new aggregation values, while remove stream refers to events leaving data windows and prior aggregation values. By default, the engine delivers only the insert stream to listeners and observers of a statement.
				</para>
				   
				<para>
				   There are keywords in the <literal>select</literal> clause that instruct the engine to not generate insert stream and/or remove stream results if your application does not need either one of the streams. These keywords are the <literal>istream</literal>, <literal>rstream</literal> and the <literal>irstream</literal> keywords. 
				</para>

				<para>
				   By default, the engine only generates insert stream results equivalent to using the optional <literal>istream</literal> keyword in the <literal>select</literal> clause.
				   If you application requires insert and remove stream results for many statements, your application can add the <literal>irstream</literal> keyword to the <literal>select</literal> clause of each statement,
				   or you can set a new default stream selector via this setting.
				</para>

				<para>
					The XML configuration for this setting is shown below:
				</para>
					<programlisting><![CDATA[<engine-settings>
  <defaults>
    <stream-selection>
      <stream-selector value="irstream" />
    </stream-selection>
  </defaults>
</engine-settings>]]></programlisting>

				<para>
					The equivalent code snippet using the configuration API is here:
				</para>
				<programlisting><![CDATA[Configuration config = new Configuration();
config.getEngineDefaults().getStreamSelection()
    .setDefaultStreamSelector(StreamSelector.RSTREAM_ISTREAM_BOTH);]]></programlisting>
			</sect3>
		</sect2>
    </sect1>
</chapter>
