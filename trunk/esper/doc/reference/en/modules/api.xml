<chapter id="api">
    <title>API Reference</title>

    <sect1 id="api-reference-intro">
        <title>API Overview</title>

        <para>
			Esper has 2 primary interfaces that this section outlines: The administrative interface and the runtime interface.
        </para>

        <para>
			Use Esper's administrative interface to create and manage EQL and pattern statements, and set runtime configurations, as discussed in <xref linkend="eql-intro"/> and <xref linkend="event-pattern-intro"/>. 
        </para>
        
        <para>
			Use Esper's runtime interface to send events into the engine, emit events and get statistics for an engine instance.
        </para>
        
		<para>
			The JavaDoc documentation is also a great source for API information.
        </para>

    </sect1>
    
    <sect1 id="api-engine-instances">
        <title>Engine Instances</title>

        <para>
			Each instance of an Esper engine is completely independent of other engine instances and has its own administrative and runtime interface.
        </para>

        <para>
			An instance of the Esper engine is obtained via static methods on the <literal>EPServiceProviderManager</literal> class.
			The <literal>getDefaultProvider</literal> method and the <literal>getProvider(String URI)</literal> methods return an instance of the Esper engine.
			The latter can be used to obtain multiple instances of the engine for different URI values. The <literal>EPServiceProviderManager</literal>
			determines if the URI matches all prior URI values and returns the same engine instance for the same URI value. If the URI has not been seen before, it creates a new engine instance.
        </para>

        <para>
			The code snipped below gets the default instance Esper engine. Subsequent calls to get the default engine instance return the same instance.
        </para>
		<programlisting><![CDATA[EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();]]></programlisting>

        <para>
			This code snippet gets an Esper engine for URI <literal>RFIDProcessor1</literal>. Subsequent calls to get an engine with the same URI return the same instance.
        </para>
		<programlisting><![CDATA[EPServiceProvider epService = EPServiceProviderManager.getProvider("RFIDProcessor1");]]></programlisting>
      
        <para>
			An existing Esper engine instance can be reset via the <literal>initialize</literal> method on the <literal>EPServiceProvider</literal> instance. This stops and removes all statements in the Engine.
        </para>
    </sect1>

    <sect1 id="api-administrative">
        <title>The Administrative Interface</title>

		<sect2 id="api-admin-creating">
        <title>Creating Statements</title>
			<para>
				Create event pattern expression and EQL statements via the administrative interface <literal>EPAdministrator</literal>.
			</para>
	
			<para>
				This code snippet gets an Esper engine then creates an event pattern and an EQL statement.
			</para>
			<programlisting><![CDATA[EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPAdministrator admin = epService.getEPAdministrator();

EPStatement 10secRecurTrigger = admin.createPattern(
  "every timer:at(*, *, *, *, *, */10)");

EPStatement countStmt = admin.createEQL(
  "select count(*) from MarketDataBean.win:time(60 sec)");
]]></programlisting>

			<para>
				Note that event pattern expressions can also occur within EQL statements. This is outlined in more detail in <xref linkend="eql-from-clause-patterns"/>.
			</para>
	
			<para>
				The <literal>create</literal> methods on <literal>EPAdministrator</literal> are overloaded and allow an optional statement name to be passed to the engine. A statement name can be useful for retrieving a statement
				by name from the engine at a later time. The engine assigns a statement name if no statement name is supplied on statement creation.
			</para>

			<para>
				The <literal>createPattern</literal> and <literal>createEQL</literal> methods return <literal>EPStatement</literal> instances. Statements are automatically started and active when created. A statement can also be stopped and started again via the <literal>stop</literal> and <literal>start</literal> methods shown in the code snippet below.
			</para>
			<programlisting><![CDATA[countStmt.stop();
countStmt.start();]]></programlisting>
	
	  </sect2>

	  <sect2 id="api-admin-listeners">		
			<title>Adding Listeners</title>
			<para>
				We can subscribe to updates posted by a statement via the <literal>addListener</literal> and <literal>removeListener</literal> methods on <literal>EPStatement</literal> . We need to provide an implementation of the <literal>UpdateListener</literal> or the <literal>StatementAwareUpdateListener</literal> interface to the statement:
			</para>
			<programlisting><![CDATA[UpdateListener myListener = new MyUpdateListener();
countStmt.addListener(myListener);]]></programlisting>

			<para>			
				EQL statements and event patterns publish old data and new data to registered <literal>UpdateListener</literal> listeners. 
				New data published by statements is the events representing the new values of derived data held by the statement.
				Old data published by statements constists of the events representing the prior values of derived data held by the statement.
			</para>		

			<para>			
				A second listener interface is the <literal>StatementAwareUpdateListener</literal> interface. A <literal>StatementAwareUpdateListener</literal> is especially useful for registering the same listener object with multiple statements, 
				as the listener receives the statement instance and engine instance in addition to new and old data when the engine indicates new results to a listener.
			</para>		
			<programlisting><![CDATA[StatementAwareUpdateListener myListener = new MyStmtAwareUpdateListener();
statement.addListener(myListener);]]></programlisting>

			<para>			
				To indicate results the engine invokes this method on <literal>StatementAwareUpdateListener</literal> listeners: <literal>update(EventBean[] newEvents, EventBean[] oldEvents, EPStatement statement, EPServiceProvider epServiceProvider)</literal>
			</para>		

	  </sect2>

	  <sect2 id="api-admin-iterators">		
			<title>Using Iterators</title>
			<para>
				Subscribing to events posted by a statement is following a push model. The engine pushes data to listeners when events are received that cause data to change or patterns to match. Alternatively, statements can also serve up data in a pull model via the <literal>iterator</literal> method. This can come in handy if we are not interested in all new updates, but only want to perform a frequent poll for the latest data. For example, an event pattern that fires every 5 seconds could be used to pull data from an EQL statement. The code snippet below demonstrates some pull code.			
			</para>
			<programlisting><![CDATA[Iterator<EventBean> eventIter = countStmt.iterator();
for (EventBean event : eventIter) {
   // .. do something ..
}]]></programlisting>

			<para>
				This is a second example:
			</para>
			<programlisting><![CDATA[double averagePrice = (Double) eqlStatement.iterator().next().get("average");]]></programlisting>
			
			<para>
				The <literal>iterator</literal> method can be used to pull results out of most statements, including statements that contain aggregation functions, pattern statements, and statements that contain a <literal>where</literal> clause, <literal>group by</literal> clause, <literal>having</literal> clause or <literal>order by</literal> clause.
			</para>

			<para>
				For statements without an <literal>order by</literal> clause, the <literal>iterator</literal> method returns events in the order maintained by the data window. For statements that contain an <literal>order by</literal> clause, the <literal>iterator</literal> method returns events in the order indicated by the <literal>order by</literal> clause.
			</para>

			<para>
				Esper places the following restrictions on the pull API and usage of the <literal>iterator</literal> method:
			</para>
	
			<orderedlist spacing="compact">
				<listitem>
					<para>
						EQL statements joining multiple event streams do not support the pull API.
					</para>
				</listitem>
				<listitem>
					<para>
						Since the <literal>iterator</literal> method returns events to the application immediately, the iterator does not honor an output rate limiting clause, if present.
					</para>
				</listitem>
				<listitem>
					<para>
						In multithreaded applications, the <literal>iterator</literal> method does not hold any locks and modifications to the underlying data window may throw runtime exceptions in the face of concurrent modifications.
					</para>
				</listitem>
			</orderedlist>
		</sect2>

	    <sect2 id="api-admin-mgmt-stmt">		
			<title>Managing Statements</title>

			<para>
				The <literal>EPAdministrator</literal> interface provides the facilities for managing statements:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Use the <literal>getStatement</literal> method to obtain an existing started or stopped statement by name
					</para>
				</listitem>
				<listitem>
					<para>
						Use the <literal>getStatementNames</literal> methods to obtain a list of started and stopped statement names
					</para>
				</listitem>
				<listitem>
					<para>
						Use the <literal>startAllStatements</literal>, <literal>stopAllStatements</literal> and <literal>destroyAllStatements</literal> methods to manage all statements in one operation
					</para>
				</listitem>
			</itemizedlist>				
	    </sect2>

	    <sect2 id="api-admin-runtime-config">		
			<title>Runtime Engine Configuration</title>
			<para>
				Certain configuration changes are available to perform on an engine instance while in operation. Such configuration operations are available via the <literal>getConfiguration</literal> method on <literal>EPAdministrator</literal>,
				which returns an <literal>ConfigurationOperations</literal> object.
			</para>

			<para>
				The  configuration operations available on a running engine instance are as follows. Please see <xref linkend="configuration"/> for more information. 
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Add an new event type for a JavaBean class, legacy Java class or custom Java class
					</para>
				</listitem>
				<listitem>
					<para>
						Add an new DOM XML event type
					</para>
				</listitem>
				<listitem>
					<para>
						Add an new Map-based event type
					</para>
				</listitem>
			</itemizedlist>				
	    </sect2>

    </sect1>

    <sect1 id="api-runtime">
        <title>The Runtime Interface</title>

        <para>
			The <literal>EPRuntime</literal> interface is used to send events for processing into an Esper engine, and to emit Events from an engine instance to the outside world.
        </para>
        
        <para>
			The below code snippet shows how to send a Java object event to the engine. Note that the <literal>sendEvent</literal> method is overloaded. As events can take on different representation classes in Java, the <literal>sendEvent</literal> takes parameters to reflect the different 
			types of events that can be send into the engine. The <xref linkend="event_representation"/> section explains the types of events 
			accepted.
        </para>
		<programlisting><![CDATA[EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPRuntime runtime = epService.getEPRuntime();

// Send an example event containing stock market data
runtime.sendEvent(new MarketDataBean('IBM', 75.0));		
]]></programlisting>

        <para>
			Events, in theoretical terms, are observations of a state change that occured in the past. Since one cannot change an event that happened in the past, events are best modelled as immutable objects. 
        </para>

        <para>
			Note that the Esper engine relies on events that are sent into an engine to not change their state. Typically, applications create a new event object for every new event, to represent that new event. Application should not modify an existing event that was sent into the engine.
        </para>

        <para>
			Another important method in the runtime interface is the <literal>route</literal> method. This method is designed for use by <literal>UpdateListener</literal> implementations that
			need to send events into an engine instance.
        </para>

        <para>
			The <literal>emit</literal> and <literal>addEmittedListener</literal> methods can be used to emit events from a runtime to a registered set of one or more emitted event listeners. 
			This mechanism is available as a service to enable channel-based publish-subscribe of events emitted from an engine instance via the <literal>emit</literal> method. Emitting events is not integrated with EQL and is available only via the <literal>EPRuntime</literal> interface.
			Events are emitted on an event channel identified by a name. Listeners are implementations of the <literal>EmittedListener</literal> interface. Via the <literal>addEmittedListener</literal> method a listener can be added to the specified event channel. The lister receives only those events posted to that channel. The channel parameter to <literal>addEmittedListener</literal> also allows null values. If a null channel value is specified, the listeners receives emitted events posted on any channel.
        </para>
    </sect1>

    <sect1 id="api-controlling-time">
        <title>Time-Keeping Events</title>

        <para>
			Special events are provided that can be used to control the time-keeping of an engine instance. There are two models for an engine to keep track of time.
			Internal clocking is when the engine instance relies on the <literal>java.util.Timer</literal> class for time tick events. External clocking can be used to supply time ticks to the engine. The latter is useful for testing time-based event sequences or for synchronizing the engine with an external time source.
        </para>

        <para>
			By default, the Esper engine uses internal time ticks. This behavior can be changed by sending a timer control event to the engine as shown below.
        </para>

		<programlisting><![CDATA[EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPRuntime runtime = epService.getEPRuntime();
// switch to external clocking
runtime.sendEvent(new TimerControlEvent(TimerControlEvent.ClockType.CLOCK_EXTERNAL));

// send a time tick
long timeInMillis = System.currentTimeMillis();	// Or get the time somewhere else
runtime.sendEvent(new CurrentTimeEvent(timeInMillis));
]]></programlisting>
    </sect1>

    <sect1 id="api-events-received">
        <title>Events Received from the Engine</title>

        <para>
			The Esper engine posts events to registered <literal>UpdateListener</literal> instances ('push' method for receiving events). For many statements events can also be pulled from statements via the <literal>iterator</literal> method. Both pull and push supply <literal>EventBean</literal> instances representing the events generated by the engine or events supplied to the engine. Each <literal>EventBean</literal> instance represents an event, with each event being either an artificial event, composite event or an event supplied to the engine via its runtime interface.
        </para>
			
        <para>
			The <literal>getEventType</literal> method supplies an event's event type information represented by an <literal>EventType</literal> instance. The <literal>EventType</literal> supplies event property names and types as well as information about the underlying object to the event.
        </para>

        <para>
			The engine may generate artificial events that contain information derived from event streams. A typical example for artificial events is the events posted for a statement to calculate univariate statistics on an event property. The below example shows such a statement and queries the generated events for an average value.
        </para>
		<programlisting><![CDATA[// Derive univariate statistics on price for the last 100 market data events
String stmt = "select * from MarketDataBean(symbol='IBM').win:length(100).stat:uni('price')";
EPStatement priceStatsView = epService.getEPAdministrator().createEQL(stmt);
priceStatsView.addListener(testListener);
]]></programlisting>
		<programlisting><![CDATA[// Example listener code
public class MyUpdateListener implements UpdateListener
{
    public void update(EventBean[] newData, EventBean[] oldData)
    {
        // Interrogate events
        System.out.println("new average price=" + newData[0].get("average");
	}
}
]]></programlisting>

        <para>
			Composite events are events that aggregate one or more other events. Composite events are typically created by the engine for statements that join two event streams, and for event patterns in which the causal events are retained and reported in a composite event. The example below shows such an event pattern.
        </para>

		<programlisting><![CDATA[// Look for a pattern where BEvent follows AEvent
String pattern = "a=AEvent -> b=BEvent";
EPStatement stmt = epService.getEPAdministrator().createPattern(pattern);
stmt.addListener(testListener);
]]></programlisting>
		<programlisting><![CDATA[// Example listener code
public class MyUpdateListener implements UpdateListener
{
    public void update(EventBean[] newData, EventBean[] oldData)
    {
        System.out.println("a event=" + newData[0].get("a").getUnderlying());
        System.out.println("b event=" + newData[0].get("b").getUnderlying());
	}
}
]]></programlisting>

    </sect1>

    <sect1 id="api-threading">
        <title>Engine Threading and Concurrency</title>

        <para>
			Esper is designed from the ground up to operate as a component to multi-threaded, highly-concurrent applications that require efficient use of Java VM resources. In addition, multi-threaded execution requires guarantees in predictability of results and deterministic processing. This section discusses these concerns in detail. 
        </para>

		<para>
In Esper, an engine instance is a unit of separation. Applications can obtain and discard (initialize) one or more engine instances within the same Java VM and can provide the same or different engine configurations to each instance. An engine instance efficiently shares resources between statements. For example, consider two statements that declare the same data window. The engine matches up view declarations provided by each statements and can thus provide a single data window representation shared between the two statements.
        </para>

        <para>
			Applications can use Esper APIs to concurrently, by multiple threads of execution, perform such functions as creating and 
managing statements, or sending events into an engine instance for processing. Applications can use one or more thread pools or any set of same or different threads of execution with any of the public Esper APIs. There are no restrictions towards threading other then those noted in specific sections of this document. 
        </para>
        
        <para>
Applications using Esper retain full control over threading, allowing an engine to be easily embedded and used as a component or library in your favorite Java container or process. It is up to the application code to use multiple threads for processing events by the engine, if so desired. All event processing takes places within your application thread call stack. The exception is timer-based processing if your engine instance relies on the internal timer (default).
        </para>

        <para>
The fact that event processing takes places within an application thread call stack makes developing applications with Esper easier: Any common Java integrated development environment (IDE) can host an Esper engine instance. This allows developers to easily set up test cases, debug through listener code and inspect input or output events, or trace their call stack.
        </para>
        
		<para>
To send events into an engine concurrently by multiple execution threads, typically applications use the Java <literal>java.lang.Thread</literal> or <literal>java.lang.Runnable</literal> classes or Java 5 concurrent utilities that include abstractions for thread pools and blocking in-memory queues.
        </para>

		<para>
Each engine instance maintains a single timer thread (internal timer) providing for time or schedule-based processing within the engine. The default resolution at which the timer operates is 100 milliseconds. The internal timer thread can be disabled and applications can instead send external time events to an engine instance to perform timer or scheduled processing at the resolution required by an application.
        </para>
        
		<para>
Each engine instance performs minimal locking to enable high levels of concurrency. An engine instance locks on a statement level to protect statement resources.
        </para>

		<para>
For an engine instance to produce predictable results from the viewpoint of listeners to statements, an engine instance by default ensures that 
it dispatches statement result events to listeners in the order in which a statement produced result events. Applications that require the highest possible concurrency and do not require predictable order of delivery of events to listeners, this feature can be turned off via configuration.
        </para>

		<para>
In multithreaded environments, when one or more statements make result events available via the <literal>insert into</literal> clause to further statements, the engine preserves the order of events inserted into the generated insert-into stream, allowing statements that consume other statement's events to behave deterministic. This feature can also be turned off via configuration.
        </para>

		<para>
We generally recommended that listener implementations do not block. By implementing listener code as non-blocking code execution threads can often achieve higher levels of concurrency. 
        </para>
    </sect1>

</chapter>
