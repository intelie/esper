<chapter id="api">
    <title>API Reference</title>

    <sect1 id="api-reference-intro">
        <title>API Overview</title>

        <para>
			Esper has 2 primary interfaces that this section outlines: The administrative interface and the runtime interface.
        </para>

        <para>
			Use Esper's administrative interface to create and manage EQL and pattern statements, and set runtime configurations, as discussed in <xref linkend="eql-intro"/> and <xref linkend="event-pattern-intro"/>. 
        </para>
        
        <para>
			Use Esper's runtime interface to send events into the engine, emit events and get statistics for an engine instance.
        </para>
        
		<para>
			The JavaDoc documentation is also a great source for API information.
        </para>

    </sect1>
    
    <sect1 id="api-engine-instances">
        <title>Engine Instances</title>

        <para>
			Each instance of an Esper engine is completely independent of other engine instances and has its own administrative and runtime interface.
        </para>

        <para>
			An instance of the Esper engine is obtained via static methods on the <literal>EPServiceProviderManager</literal> class.
			The <literal>getDefaultProvider</literal> method and the <literal>getProvider(String URI)</literal> methods return an instance of the Esper engine.
			The latter can be used to obtain multiple instances of the engine for different URI values. The <literal>EPServiceProviderManager</literal>
			determines if the URI matches all prior URI values and returns the same engine instance for the same URI value. If the URI has not been seen before, it creates a new engine instance.
        </para>

        <para>
			The code snipped below gets the default instance Esper engine. Subsequent calls to get the default engine instance return the same instance.
        </para>
		<programlisting><![CDATA[EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();]]></programlisting>

        <para>
			This code snippet gets an Esper engine for URI <literal>RFIDProcessor1</literal>. Subsequent calls to get an engine with the same URI return the same instance.
        </para>
		<programlisting><![CDATA[EPServiceProvider epService = EPServiceProviderManager.getProvider("RFIDProcessor1");]]></programlisting>
      
        <para>
			An existing Esper engine instance can be reset via the <literal>initialize</literal> method on the <literal>EPServiceProvider</literal> instance. This stops and removes all statements in the Engine.
        </para>
    </sect1>

    <sect1 id="api-administrative">
        <title>The Administrative Interface</title>

		<sect2 id="api-admin-creating">
        <title>Creating Statements</title>
			<para>
				Create event pattern expression and EQL statements via the administrative interface <literal>EPAdministrator</literal>.
			</para>
	
			<para>
				This code snippet gets an Esper engine then creates an event pattern and an EQL statement.
			</para>
			<programlisting><![CDATA[EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPAdministrator admin = epService.getEPAdministrator();

EPStatement 10secRecurTrigger = admin.createPattern(
  "every timer:at(*, *, *, *, *, */10)");

EPStatement countStmt = admin.createEQL(
  "select count(*) from MarketDataBean.win:time(60 sec)");
]]></programlisting>

			<para>
				Note that event pattern expressions can also occur within EQL statements. This is outlined in more detail in <xref linkend="eql-from-clause-patterns"/>.
			</para>
	
			<para>
				The <literal>create</literal> methods on <literal>EPAdministrator</literal> are overloaded and allow an optional statement name to be passed to the engine. A statement name can be useful for retrieving a statement
				by name from the engine at a later time. The engine assigns a statement name if no statement name is supplied on statement creation.
			</para>

			<para>
				The <literal>createPattern</literal> and <literal>createEQL</literal> methods return <literal>EPStatement</literal> instances. Statements are automatically started and active when created. A statement can also be stopped and started again via the <literal>stop</literal> and <literal>start</literal> methods shown in the code snippet below.
			</para>
			<programlisting><![CDATA[countStmt.stop();
countStmt.start();]]></programlisting>
	
	  </sect2>

	  <sect2 id="api-admin-listeners">		
			<title>Adding Listeners</title>
			<para>
				We can subscribe to updates posted by a statement via the <literal>addListener</literal> and <literal>removeListener</literal> methods on <literal>EPStatement</literal> . We need to provide an implementation of the <literal>UpdateListener</literal> or the <literal>StatementAwareUpdateListener</literal> interface to the statement:
			</para>
			<programlisting><![CDATA[UpdateListener myListener = new MyUpdateListener();
countStmt.addListener(myListener);]]></programlisting>

			<para>			
				EQL statements and event patterns publish old data and new data to registered <literal>UpdateListener</literal> listeners. 
				New data published by statements is the events representing the new values of derived data held by the statement.
				Old data published by statements constists of the events representing the prior values of derived data held by the statement.
			</para>		

			<para>			
				A second listener interface is the <literal>StatementAwareUpdateListener</literal> interface. A <literal>StatementAwareUpdateListener</literal> is especially useful for registering the same listener object with multiple statements, 
				as the listener receives the statement instance and engine instance in addition to new and old data when the engine indicates new results to a listener.
			</para>		
			<programlisting><![CDATA[StatementAwareUpdateListener myListener = new MyStmtAwareUpdateListener();
statement.addListener(myListener);]]></programlisting>

			<para>			
				To indicate results the engine invokes this method on <literal>StatementAwareUpdateListener</literal> listeners: <literal>update(EventBean[] newEvents, EventBean[] oldEvents, EPStatement statement, EPServiceProvider epServiceProvider)</literal>
			</para>		

	  </sect2>

	  <sect2 id="api-admin-iterators">		
			<title>Using Iterators</title>
			<para>
				Subscribing to events posted by a statement is following a push model. The engine pushes data to listeners when events are received that cause data to change or patterns to match. Alternatively, statements can also serve up data in a pull model via the <literal>iterator</literal> method. This can come in handy if we are not interested in all new updates, but only want to perform a frequent poll for the latest data. For example, an event pattern that fires every 5 seconds could be used to pull data from an EQL statement. The code snippet below demonstrates some pull code.			
			</para>
			<programlisting><![CDATA[Iterator<EventBean> eventIter = countStmt.iterator();
for (EventBean event : eventIter) {
   // .. do something ..
}]]></programlisting>

			<para>
				This is a second example:
			</para>
			<programlisting><![CDATA[double averagePrice = (Double) eqlStatement.iterator().next().get("average");]]></programlisting>
			
			<para>
				The <literal>iterator</literal> method can be used to pull results out of most statements, including statements that contain aggregation functions, pattern statements, and statements that contain a <literal>where</literal> clause, <literal>group by</literal> clause, <literal>having</literal> clause or <literal>order by</literal> clause.
			</para>

			<para>
				For statements without an <literal>order by</literal> clause, the <literal>iterator</literal> method returns events in the order maintained by the data window. For statements that contain an <literal>order by</literal> clause, the <literal>iterator</literal> method returns events in the order indicated by the <literal>order by</literal> clause.
			</para>

			<para>
				Esper places the following restrictions on the pull API and usage of the <literal>iterator</literal> method:
			</para>
	
			<orderedlist spacing="compact">
				<listitem>
					<para>
						EQL statements joining multiple event streams do not support the pull API.
					</para>
				</listitem>
				<listitem>
					<para>
						Since the <literal>iterator</literal> method returns events to the application immediately, the iterator does not honor an output rate limiting clause, if present.
					</para>
				</listitem>
				<listitem>
					<para>
						In multithreaded applications, the <literal>iterator</literal> method does not hold any locks and modifications to the underlying data window may throw runtime exceptions in the face of concurrent modifications.
					</para>
				</listitem>
			</orderedlist>
		</sect2>

	    <sect2 id="api-admin-mgmt-stmt">		
			<title>Managing Statements</title>

			<para>
				The <literal>EPAdministrator</literal> interface provides the facilities for managing statements:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Use the <literal>getStatement</literal> method to obtain an existing started or stopped statement by name
					</para>
				</listitem>
				<listitem>
					<para>
						Use the <literal>getStatementNames</literal> methods to obtain a list of started and stopped statement names
					</para>
				</listitem>
				<listitem>
					<para>
						Use the <literal>startAllStatements</literal>, <literal>stopAllStatements</literal> and <literal>destroyAllStatements</literal> methods to manage all statements in one operation
					</para>
				</listitem>
			</itemizedlist>				
	    </sect2>

	    <sect2 id="api-admin-runtime-config">		
			<title>Runtime Engine Configuration</title>
			<para>
				Certain configuration changes are available to perform on an engine instance while in operation. Such configuration operations are available via the <literal>getConfiguration</literal> method on <literal>EPAdministrator</literal>,
				which returns an <literal>ConfigurationOperations</literal> object.
			</para>

			<para>
				The  configuration operations available on a running engine instance are as follows. Please see <xref linkend="configuration"/> for more information. 
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Add an new event type for a JavaBean class, legacy Java class or custom Java class
					</para>
				</listitem>
				<listitem>
					<para>
						Add an new DOM XML event type
					</para>
				</listitem>
				<listitem>
					<para>
						Add an new Map-based event type
					</para>
				</listitem>
			</itemizedlist>				
	    </sect2>

    </sect1>

    <sect1 id="api-runtime">
        <title>The Runtime Interface</title>

        <para>
			The <literal>EPRuntime</literal> interface is used to send events for processing into an Esper engine, and to emit Events from an engine instance to the outside world.
        </para>
        
        <para>
			The below code snippet shows how to send a Java object event to the engine. Note that the <literal>sendEvent</literal> method is overloaded. As events can take on different representation classes in Java, the <literal>sendEvent</literal> takes parameters to reflect the different 
			types of events that can be send into the engine. The <xref linkend="event_representation"/> section explains the types of events 
			accepted.
        </para>
		<programlisting><![CDATA[EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPRuntime runtime = epService.getEPRuntime();

// Send an example event containing stock market data
runtime.sendEvent(new MarketDataBean('IBM', 75.0));		
]]></programlisting>

        <para>
			Events, in theoretical terms, are observations of a state change that occured in the past. Since one cannot change an event that happened in the past, events are best modelled as immutable objects. 
        </para>

        <para>
			Note that the Esper engine relies on events that are sent into an engine to not change their state. Typically, applications create a new event object for every new event, to represent that new event. Application should not modify an existing event that was sent into the engine.
        </para>

        <para>
			Another important method in the runtime interface is the <literal>route</literal> method. This method is designed for use by <literal>UpdateListener</literal> implementations that
			need to send events into an engine instance.
        </para>

        <para>
			The <literal>emit</literal> and <literal>addEmittedListener</literal> methods can be used to emit events from a runtime to a registered set of one or more emitted event listeners. 
			This mechanism is available as a service to enable channel-based publish-subscribe of events emitted from an engine instance via the <literal>emit</literal> method. Emitting events is not integrated with EQL and is available only via the <literal>EPRuntime</literal> interface.
			Events are emitted on an event channel identified by a name. Listeners are implementations of the <literal>EmittedListener</literal> interface. Via the <literal>addEmittedListener</literal> method a listener can be added to the specified event channel. The lister receives only those events posted to that channel. The channel parameter to <literal>addEmittedListener</literal> also allows null values. If a null channel value is specified, the listeners receives emitted events posted on any channel.
        </para>
    </sect1>

    <sect1 id="api-controlling-time">
        <title>Time-Keeping Events</title>

        <para>
			Special events are provided that can be used to control the time-keeping of an engine instance. There are two models for an engine to keep track of time.
			Internal clocking is when the engine instance relies on the <literal>java.util.Timer</literal> class for time tick events. External clocking can be used to supply time ticks to the engine. The latter is useful for testing time-based event sequences or for synchronizing the engine with an external time source.
        </para>

        <para>
			By default, the Esper engine uses internal time ticks. This behavior can be changed by sending a timer control event to the engine as shown below.
        </para>

		<programlisting><![CDATA[EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPRuntime runtime = epService.getEPRuntime();
// switch to external clocking
runtime.sendEvent(new TimerControlEvent(TimerControlEvent.ClockType.CLOCK_EXTERNAL));

// send a time tick
long timeInMillis = System.currentTimeMillis();	// Or get the time somewhere else
runtime.sendEvent(new CurrentTimeEvent(timeInMillis));
]]></programlisting>

		<para>
			We recommend that when disabling the internal timer, applications send an external timer event setting the start time before creating statements,
			such that statement start time is well-defined.
		</para>
    </sect1>

    <sect1 id="api-events-received">
        <title>Events Received from the Engine</title>

        <para>
			The Esper engine posts events to registered <literal>UpdateListener</literal> instances ('push' method for receiving events). For many statements events can also be pulled from statements via the <literal>iterator</literal> method. Both pull and push supply <literal>EventBean</literal> instances representing the events generated by the engine or events supplied to the engine. Each <literal>EventBean</literal> instance represents an event, with each event being either an artificial event, composite event or an event supplied to the engine via its runtime interface.
        </para>
			
        <para>
			The <literal>getEventType</literal> method supplies an event's event type information represented by an <literal>EventType</literal> instance. The <literal>EventType</literal> supplies event property names and types as well as information about the underlying object to the event.
        </para>

        <para>
			The engine may generate artificial events that contain information derived from event streams. A typical example for artificial events is the events posted for a statement to calculate univariate statistics on an event property. The below example shows such a statement and queries the generated events for an average value.
        </para>
		<programlisting><![CDATA[// Derive univariate statistics on price for the last 100 market data events
String stmt = "select * from MarketDataBean(symbol='IBM').win:length(100).stat:uni('price')";
EPStatement priceStatsView = epService.getEPAdministrator().createEQL(stmt);
priceStatsView.addListener(testListener);
]]></programlisting>
		<programlisting><![CDATA[// Example listener code
public class MyUpdateListener implements UpdateListener
{
    public void update(EventBean[] newData, EventBean[] oldData)
    {
        // Interrogate events
        System.out.println("new average price=" + newData[0].get("average");
	}
}
]]></programlisting>

        <para>
			Composite events are events that aggregate one or more other events. Composite events are typically created by the engine for statements that join two event streams, and for event patterns in which the causal events are retained and reported in a composite event. The example below shows such an event pattern.
        </para>

		<programlisting><![CDATA[// Look for a pattern where BEvent follows AEvent
String pattern = "a=AEvent -> b=BEvent";
EPStatement stmt = epService.getEPAdministrator().createPattern(pattern);
stmt.addListener(testListener);
]]></programlisting>
		<programlisting><![CDATA[// Example listener code
public class MyUpdateListener implements UpdateListener
{
    public void update(EventBean[] newData, EventBean[] oldData)
    {
        System.out.println("a event=" + newData[0].get("a").getUnderlying());
        System.out.println("b event=" + newData[0].get("b").getUnderlying());
	}
}
]]></programlisting>

        <para>
			Note that the <literal>update</literal> method can receive multiple events at once as it accepts an array of <literal>EventBean</literal> instances. For example, a time batch window may post multiple events to listeners representing a batch of events received during a given time period. 
        </para>
			
        <para>
			Pattern statements can also produce multiple events delivered to update listeners in one invocation. The pattern statement below, for instance, delivers an event for each A event that was not followed by a B event with the same <literal>id</literal> property within 60 seconds of the A event. The engine may deliver all matching A events as an array of events in a single invocation of the <literal>update</literal> method of each listener to the statement:
        </para>
		<programlisting><![CDATA[every a=A -> (timer:interval(60 sec) and not B(id=a.id))]]></programlisting>
        
    </sect1>

    <sect1 id="api-threading">
        <title>Engine Threading and Concurrency</title>

        <para>
			Esper is designed from the ground up to operate as a component to multi-threaded, highly-concurrent applications that require efficient use of Java VM resources. In addition, multi-threaded execution requires guarantees in predictability of results and deterministic processing. This section discusses these concerns in detail. 
        </para>

		<para>
In Esper, an engine instance is a unit of separation. Applications can obtain and discard (initialize) one or more engine instances within the same Java VM and can provide the same or different engine configurations to each instance. An engine instance efficiently shares resources between statements. For example, consider two statements that declare the same data window. The engine matches up view declarations provided by each statement and can thus provide a single data window representation shared between the two statements.
        </para>

        <para>
			Applications can use Esper APIs to concurrently, by multiple threads of execution, perform such functions as creating and 
managing statements, or sending events into an engine instance for processing. Applications can use one or more thread pools or any set of same or different threads of execution with any of the public Esper APIs. There are no restrictions towards threading other then those noted in specific sections of this document. 
        </para>
        
        <para>
Applications using Esper retain full control over threading, allowing an engine to be easily embedded and used as a component or library in your favorite Java container or process. It is up to the application code to use multiple threads for processing events by the engine, if so desired. All event processing takes places within your application thread call stack. The exception is timer-based processing if your engine instance relies on the internal timer (default).
        </para>

        <para>
The fact that event processing takes places within an application thread call stack makes developing applications with Esper easier: Any common Java integrated development environment (IDE) can host an Esper engine instance. This allows developers to easily set up test cases, debug through listener code and inspect input or output events, or trace their call stack.
        </para>
        
		<para>
To send events into an engine concurrently by multiple execution threads, typically applications use the Java <literal>java.lang.Thread</literal> or <literal>java.lang.Runnable</literal> classes or Java 5 concurrent utilities that include abstractions for thread pools and blocking in-memory queues.
        </para>

		<para>
Each engine instance maintains a single timer thread (internal timer) providing for time or schedule-based processing within the engine. The default resolution at which the timer operates is 100 milliseconds. The internal timer thread can be disabled and applications can instead send external time events to an engine instance to perform timer or scheduled processing at the resolution required by an application.
        </para>
        
		<para>
Each engine instance performs minimal locking to enable high levels of concurrency. An engine instance locks on a statement level to protect statement resources.
        </para>

		<para>
For an engine instance to produce predictable results from the viewpoint of listeners to statements, an engine instance by default ensures that 
it dispatches statement result events to listeners in the order in which a statement produced result events. Applications that require the highest possible concurrency and do not require predictable order of delivery of events to listeners, this feature can be turned off via configuration.
        </para>

		<para>
In multithreaded environments, when one or more statements make result events available via the <literal>insert into</literal> clause to further statements, the engine preserves the order of events inserted into the generated insert-into stream, allowing statements that consume other statement's events to behave deterministic. This feature can also be turned off via configuration.
        </para>

		<para>
We generally recommended that listener implementations do not block. By implementing listener code as non-blocking code execution threads can often achieve higher levels of concurrency. 
        </para>
    </sect1>

    <sect1 id="api-soda">
        <title>Statement Object Model</title>
        
        <para>
			The statement object model is a set of classes that provide an object-oriented representation of an EQL or pattern statement. The object model classes are found in package <literal>net.esper.client.soda</literal>. An instance of <literal>EPStatementObjectModel</literal> represents a statement's object model.
        </para>

        <para>
			The statement object model classes are a full and complete specification of a statement. All EQL and pattern constructs including expressions and sub-queries are available via the statement object model. 
        </para>
        
        <para>
			In conjunction with the administrative API, the statement object model provides the means to build, change or interrogate statements beyond the EQL or pattern syntax string representation. The object graph of the statement object model is fully navigable for easy querying by code, and is also serializable allowing applications to persist or transport statements in object form, when required.
        </para>

        <para>
			The statement object model supports full round-trip from object model to EQL statement string and back to object model: A statement object model can be rendered into an EQL string representation via the <literal>toEQL</literal> method on <literal>EPStatementObjectModel</literal>. Further, the administrative API allows to compile a statement string into an object model representation via the <literal>compileEQL</literal> method on <literal>EPAdministrator</literal>.
        </para>

		<para>
			The <literal>create</literal> method on <literal>EPAdministrator</literal> creates and starts a statement as represented by an object model. In order to obtain an object model from an existing statement, obtain the statement expression text of the statement via the <literal>getText</literal> method on <literal>EPStatement</literal> and use the <literal>compileEQL</literal> method to obtain the object model.
		</para>

		<para>
			The following limitations apply:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Statement object model classes are not safe for sharing between threads other then for read access. 
				</para>
			</listitem>
			<listitem>
				<para>
					Between versions of Esper, the serialized form of the object model is subject to change. Esper makes no guarantees that the serialized object model of one version will be fully compatible with the 
					serialized object model generated by another version of Esper. Please consider this issue when storing Esper object models in persistent store. 
				</para>
			</listitem>
		</itemizedlist>

		<sect2 id="api-soda-building-step1">
			<title>Building an Object Model</title>

			<para>
				A <literal>EPStatementObjectModel</literal> consists of an object graph representing all possible clauses that can be part of an EQL statement. 
			</para>
				
			<para>
				Among all clauses, the <literal>SelectClause</literal> and <literal>FromClause</literal> objects are required clauses that must be present, in order to define what to select and where to select from.
			</para>
				
			<table frame="topbot" id="soda-building-classes-1" revision="2">
				<title>Required Statement Object Model Instances</title>
				<tgroup cols="2">
					<colspec colwidth="1*"/>
					<colspec colwidth="2.0*"/>
					<thead>
						<row>
							<entry>Class</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry><emphasis>EPStatementObjectModel</emphasis></entry>
							<entry>All statement clauses for a statement, such as the select-clause and the from-clause, are specified within the object graph of an instance of this class</entry>
						</row>
						<row>
							<entry><emphasis>SelectClause</emphasis></entry>
							<entry>A list of the selection properties or expressions, or a wildcard</entry>
						</row>
						<row>
							<entry><emphasis>FromClause</emphasis></entry>
							<entry>A list of one or more streams; A stream can be a filter-based, a pattern-based or a SQL-based stream; Views are added to streams to provide data window or other projections</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			
			<para>
				Part of the statement object model package are convenient builder classes that make it easy to build a new object model or change an existing object model. The <literal>SelectClause</literal> and <literal>FromClause</literal> are such builder classes and provide convenient <literal>create</literal> methods.
			</para>

			<para>
				Within the from-clause we have a choice of different streams to select on. The <literal>FilterStream</literal> class represents a stream that is filled by events of a certain type and that pass an optional filter expression.
			</para>

			<para>
				We can use the classes introduced above to create a simple statement object model:
			</para>

		<programlisting><![CDATA[EPStatementObjectModel model = new EPStatementObjectModel();
model.setSelectClause(SelectClause.createWildcard());
model.setFromClause(FromClause.create(FilterStream.create("com.chipmaker.ReadyEvent")));]]></programlisting>

			<para>
				The model as above is equivalent to the EQL:
			</para>

			<programlisting><![CDATA[select * from com.chipmaker.ReadyEvent]]></programlisting>

			<para>
				Last, the code snippet below creates a statement from the object model:
			</para>

			<programlisting><![CDATA[EPStatement stmt = epService.getEPAdministrator().create(model);]]></programlisting>
		</sect2>
		
		<sect2 id="api-soda-building-step2">
			<title>Building Complex Expressions</title>
			
			<para>
				The <literal>EPStatementObjectModel</literal> includes an optional where-clause. The where-clause is a filter expression that the engine applies to events in one or more streams. The key interface for all expressions is the <literal>Expression</literal> interface.
			</para>

			<para>
				The <literal>Expressions</literal> class provides a convenient way of obtaining <literal>Expression</literal> instances for all possible expressions. Please consult the JavaDoc for detailed method information. 
				The next example discusses sample where-clause expressions.
			</para>
			
			<para>
				Use the <literal>Expressions</literal> class as a service for creating expression instances, and add additional expressions via the <literal>add</literal> method that most expressions provide.
			</para>

			<para>
				In the next example we add a simple where-clause to the EQL as shown earlier:
			</para>
			<programlisting><![CDATA[select * from com.chipmaker.ReadyEvent where line=8]]></programlisting>

			<para>
				And the code to add a where-clause to the object model is below.
			</para>			
			<programlisting><![CDATA[model.setWhereClause(Expressions.eq("line", 8));]]></programlisting>

			<para>
				The following example considers a more complex where-clause. Assume we need to build an expression using logical-and and logical-or:
			</para>			
			<programlisting><![CDATA[select * from com.chipmaker.ReadyEvent 
where (line=8) or (line=10 and age<5)]]></programlisting>
			
			<para>
				The code for building such a where-clause by means of the object model classes is:
			</para>			

			<programlisting><![CDATA[model.setWhereClause(Expressions.or()
  .add(Expressions.eq("line", 8))
  .add(Expressions.and()
      .add(Expressions.eq("line", 10))
      .add(Expressions.lt("age", 5))
  ));]]></programlisting>
		</sect2>
		
		<sect2 id="api-soda-building-step3">
			<title>Building Patterns</title>
			
			<para>
				The <literal>Patterns</literal> class is a factory for building pattern expressions. It provides convenient methods to create all pattern expressions of the pattern language.
			</para>

			<para>
				Patterns in EQL are seen as a stream of events that consist of patterns matches. The <literal>PatternStream</literal> class represents a stream of pattern matches and contains a pattern expression within. 
			</para>

			<para>
				 For instance, consider the following pattern statement.
			</para>
			<programlisting><![CDATA[select * from pattern [every a=MyAEvent and not b=MyBEvent]]]></programlisting>

			<para>
				The next code snippet outlines how to use the statement object model and specifically the <literal>Patterns</literal> class to create a statement object model that is equivalent to the pattern statement above.
			</para>			
			<programlisting><![CDATA[EPStatementObjectModel model = new EPStatementObjectModel();
model.setSelectClause(SelectClause.createWildcard());
PatternExpr pattern = Patterns.and()
  .add(Patterns.everyFilter("MyAEvent", "a"))
  .add(Patterns.notFilter("MyBEvent", "b"));
model.setFromClause(FromClause.create(PatternStream.create(pattern)));]]></programlisting>
		</sect2>

		<sect2 id="api-soda-building-step4">
			<title>Building Complete Statements</title>
			
			<para>
				In this section we build a complete example statement and include all optional clauses in one EQL statement, to demonstrate the object model API.
			</para>

			<para>
				A sample statement:
			</para>

			<programlisting><![CDATA[insert into ReadyStreamAvg(line, avgAge) 
select line, avg(age) as avgAge 
from com.chipmaker.ReadyEvent(line in (1, 8, 10)).win:time(10) as RE
where RE.waverId != null
group by line 
having avg(age) < 0
output every 10.0 seconds 
order by line]]></programlisting>

			<para>
				Finally, this code snippet builds the above statement from scratch:
			</para>			
			<programlisting><![CDATA[EPStatementObjectModel model = new EPStatementObjectModel();
model.setInsertInto(InsertIntoClause.create("ReadyStreamAvg", "line", "avgAge"));
model.setSelectClause(SelectClause.create()
    .add("line")
    .add(Expressions.avg("age"), "avgAge"));
Filter filter = Filter.create("com.chipmaker.ReadyEvent", Expressions.in("line", 1, 8, 10));
model.setFromClause(FromClause.create(
    FilterStream.create(filter, "RE").addView("win", "time", 10)));
model.setWhereClause(Expressions.isNotNull("RE.waverId"));
model.setGroupByClause(GroupByClause.create("line"));
model.setHavingClause(Expressions.lt(Expressions.avg("age"), Expressions.constant(0)));
model.setOutputLimitClause(OutputLimitClause.create(10, OutputLimitUnit.SECONDS));
model.setOrderByClause(OrderByClause.create("line"));]]></programlisting>
		</sect2>

    </sect1>

    <sect1 id="api-prepared">
        <title>Prepared Statement and Substitution Parameters</title>
        
        <para>
			The <literal>prepare</literal> method that is part of the administrative API pre-compiles an EQL statement and stores the precompiled statement in an <literal>EPPreparedStatement</literal> object. This 
			object can then be used to efficiently start the parameterized statement multiple times.
        </para>

        <para>
			Substitution parameters are inserted into an EQL statement as a single question mark character <literal>'?'</literal>. The engine assigns the first substitution parameter an index of 1 and subsequent parameters increment the index by one.
        </para>

        <para>
			Substitution parameters can be inserted into any EQL construct that takes an expression. They are therefore valid in any clauses such as the select-clause, from-clause filters, where-clause, group-by-clause, having-clause or order-by-clause. 
			Substitution parameters cannot be used as parameters to views, pattern observers and guards. They also cannot be used where a numeric constant is required rather then an expression.
        </para>

        <para>
			All substitution parameters must be replaced by actual values before a statement with substitution parameters can be started. Substitution parameters can be replaced with an actual value using the <literal>setObject</literal> method for each index. Substitution parameters can be set to new values and new statements can be created from the same <literal>EPPreparedStatement</literal> object more then once.
        </para>

        <para>
			While the <literal>setObject</literal> method allows substitution parameters to assume any actual value including application Java objects or enumeration values, the application must provide the correct type of  substitution parameter that matches the requirements of the expression the parameter resides in.
        </para>

        <para>
			In the following example of setting parameters on a prepared statement and starting the prepared statement, <literal>epService</literal> represents an engine instance:
        </para>

		<programlisting><![CDATA[String stmt = "select * from com.chipmaker.ReadyEvent(line=?)";
EPPreparedStatement prepared = epService.getEPAdministrator().prepareEQL(stmt);
prepared.setObject(1, 8);
EPStatement statement = epService.getEPAdministrator().create(prepared);]]></programlisting>
	
  </sect1>
      
</chapter>
