<chapter id="event_representation">
    <title>Event Representations</title>
    
    <para>
		This section outlines the different means to model and represent events.
    </para>

    <para>
		Please see the <xref linkend="api-event"/> section for APIs.
    </para>

    <sect1 id="eventrep_intro">
        <title>Event Underlying Java Objects</title>

		<indexterm><primary>event</primary><secondary>underlying representation</secondary></indexterm>
        <para>
			An event is an immutable record of a past occurrence of an action or state change. Event properties capture the state information for an event.
        </para>

        <para>
			In Esper, an event can be represented by any of the following underlying Java objects:
        </para>
        
		<table frame="topbot">
			<title>Event Underlying Java Objects</title>
			<tgroup cols="2">
				<colspec colwidth="1.5*"/>
				<colspec colwidth="2*"/>
				<thead>
					<row>
						<entry>Java Class</entry>
						<entry>Description</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry><literal>java.lang.Object</literal></entry>
						<entry>Any Java POJO (plain-old java object) with getter methods following JavaBean conventions;  Legacy Java classes not following JavaBean conventions can also serve as events .</entry>
					</row>
					<row>
						<entry><literal>java.util.Map</literal></entry>
						<entry>Map events are key-values pairs and can also contain objects, further Map, and arrays thereof.</entry>
					</row>
					<row>
						<entry><literal>org.w3c.dom.Node</literal></entry>
						<entry>XML document object model (DOM).</entry>
					</row>
					<row>
						<entry><literal>org.apache.axiom.om.OMDocument or OMElement</literal></entry>
						<entry>XML - Streaming API for XML (StAX) - Apache Axiom (provided by EsperIO package).</entry>
					</row>
					<row>
						<entry>Application classes</entry>
						<entry>Plug-in event representation via the extension API.</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
	</sect1>      

	<sect1 id="eventrep-properties">
	   <title>Event Properties</title>
           
		<indexterm><primary>event</primary><secondary>properties</secondary></indexterm>
		<para>
			 Event properties capture the state information for an event. Event properties be simple as well as indexed, mapped and nested event properties. The table below outlines the different types of properties and their syntax in an event expression. This syntax allows statements to query deep JavaBean objects graphs, XML structures and Map events. 
		</para>

		<table frame="topbot">
			<title>Types of Event Properties</title>
			<tgroup cols="4">
				<colspec colwidth="1*"/>
				<colspec colwidth="2.5*"/>
				<colspec colwidth="1.5*"/>
				<colspec colwidth="1.5*"/>
				<thead>
					<row>
						<entry>Type</entry>
						<entry>Description</entry>
						<entry>Syntax</entry>
						<entry>Example</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Simple</entry>
						<entry>A property that has a single value that may be retrieved.</entry>
						<entry><synopsis>name</synopsis></entry>
						<entry><synopsis>sensorId</synopsis></entry>
					</row>
					<row>
						<entry>Indexed</entry>
						<entry>An indexed property stores an ordered collection of objects (all of the same type) that can be individually accessed by an integer-valued, non-negative index (or subscript).</entry>
						<entry><synopsis>name[<emphasis>index</emphasis>]</synopsis></entry>
						<entry><synopsis>sensor[0]</synopsis></entry>
					</row>
					<row>
						<entry>Mapped</entry>
						<entry>A mapped property stores a keyed collection of objects (all of the same type).</entry>
						<entry><synopsis>name('<emphasis>key</emphasis>')</synopsis></entry>
						<entry><synopsis>sensor('light')</synopsis></entry>
					</row>
					<row>
						<entry>Nested</entry>
						<entry>A nested property is a property that lives within another property of an event.</entry>
						<entry><synopsis>name.nestedname</synopsis></entry>
						<entry><synopsis>sensor.value</synopsis></entry>
					</row>
				</tbody>
			</tgroup>
		</table> 

		<para>
			Combinations are also possible. For example, a valid combination could be <literal>person.address('home').street[0]</literal>.
		</para>

		<para>
			If your application uses <literal>java.util.Map</literal> or XML to represent events, then event property names may themselves contain the dot ('.') character. The backslash ('\') character can be used to escape dot characters in property names, allowing a property name to contain dot characters. 
		</para>
		
		<para>
			For example, the EPL as shown below expects a property by name <literal>part1.part2</literal> to exist on event type <literal>MyEvent</literal>:
		</para>
		<programlisting>select part1\.part2 from MyEvent</programlisting> 
	</sect1>
		
	<sect1 id="eventrep-dyncproperties">
	   <title>Dynamic Event Properties</title>
           
		<indexterm><primary>dynamic event properties</primary></indexterm>
		<indexterm><primary>event</primary><secondary>dynamic properties</secondary></indexterm>
		<para>
			Dynamic (unchecked) properties are event properties that need not be known at statement compilation time. Such properties are resolved during runtime: they provide duck typing functionality.
		</para>
			
		<para>
			The idea behind dynamic properties is that for a given underlying event representation we don't always know all properties in advance. An underlying event may have additional properties that are not known at statement compilation time, that we want to query on. The concept is especially useful for events that represent rich, object-oriented domain models.
		</para>

		<para>
			The syntax of dynamic properties consists of the property name and a question mark. Indexed, mapped and nested properties can also be dynamic properties:
		</para>

		<table frame="topbot">
			<title>Types of Event Properties</title>
			<tgroup cols="2">
				<colspec colwidth="1*"/>
				<colspec colwidth="2.5*"/>
				<thead>
					<row>
						<entry>Type</entry>
						<entry>Syntax</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Dynamic Simple</entry>
						<entry><synopsis>name?</synopsis></entry>
					</row>
					<row>
						<entry>Dynamic Indexed</entry>
						<entry><synopsis>name[<emphasis>index</emphasis>]?</synopsis></entry>
					</row>
					<row>
						<entry>Dynamic Mapped</entry>
						<entry><synopsis>name('<emphasis>key</emphasis>')?</synopsis></entry>
					</row>
					<row>
						<entry>Dynamic Nested</entry>
						<entry><synopsis>name?.nestedPropertyName</synopsis></entry>
					</row>
				</tbody>
			</tgroup>
		</table> 

		<para>
			 Dynamic properties always return the <literal>java.lang.Object</literal> type. Also, dynamic properties return a <literal>null</literal> value if the dynamic property does not exist on events processed at runtime. 
		</para>

		<para>
			As an example, consider an OrderEvent event that provides an "item" property. The "item" property is of type <literal>Object</literal> and holds a reference to an instance of either a Service or Product. 
		</para>

		<para>
			Assume that both Service and Product classes provide a property named "price". Via a dynamic property we can specify a query that obtains the price property from either object (Service or Product):
		</para>
		<programlisting><![CDATA[select item.price? from OrderEvent]]></programlisting>		

		<para>
			 As a second example, assume that the Service class contains a "serviceName" property that the Product class does not possess. The following query returns the value of the "serviceName" property for Service objects. It returns a <literal>null</literal>-value for Product objects that do not have the "serviceName" property:
		</para>
		<programlisting><![CDATA[select item.serviceName? from OrderEvent]]></programlisting>		

		<para>
			Consider the case where OrderEvent has multiple implementation classes, some of which have a "timestamp" property. The next query returns the timestamp property of those implementations of the OrderEvent interface that feature the property:
		</para>
		<programlisting><![CDATA[select timestamp? from OrderEvent]]></programlisting>		
		
		<para>
			The query as above returns a single column named "timestamp?" of type <literal>Object</literal>. 			
		</para>

		<para>
			When dynamic properties are nested, then all properties under the dynamic property are also considered dynamic properties. In the below example the query asks for the "direction" property of the object returned by the "detail" dynamic property:
		</para>
		<programlisting><![CDATA[select detail?.direction from OrderEvent
// equivalent to 
select detail?.direction? from OrderEvent]]></programlisting>		

		<para>
			The functions that are often useful in conjunction with dynamic properties are:
		</para>

		<itemizedlist>
			<listitem>
				<para>
                    The <literal>cast</literal> function casts the value of a dynamic property (or the value of an expression) to a given type.
                </para>
			</listitem>
			<listitem>
				<para>
                    The <literal>exists</literal> function checks whether a dynamic property exists. It returns <literal>true</literal> if the event has a property of that name, or false if the property does not exist on that event.
                </para>
			</listitem>
			<listitem>
				<para>
                    The <literal>instanceof</literal> function checks whether the value of a dynamic property (or the value of an expression) is of any of the given types.
                </para>
			</listitem>
		</itemizedlist>

		<para>
			Dynamic event properties work with all event representations outlined next: Java objects, Map-based and XML DOM-based events.
		</para>

	</sect1>

	<sect1 id="eventrep-fragment">
	   <title>Fragment and Fragment Type</title>
		<para>
			Sometimes an event can have properties that are itself events. Esper uses the term <emphasis>fragment</emphasis> and <emphasis>fragment type</emphasis> for such event pieces. The best example is a pattern
			that matches two or more events and the output event contains the matching events as fragments. In other words, output events can be a composite event that consists or further events, the fragments.
		</para>

		<para>
			Fragments have the same metadata available as their enclosing composite events. The metadata for enclosing composite events contains information about which properties are fragments, or have a property value that can be 
			represented as a fragment and therefore as an event itself.
		</para>

		<para>
			Fragments and type metadata can allow your application to navigate composite events without the need for using the Java reflection API and reducing the coupling to the underlying event representation.
			The API is further described in <xref linkend="api-event"/>.
		</para>		
	</sect1>

	<sect1 id="eventrep-javabean">
	   <title>Plain-Old Java Object Events</title>

		<indexterm><primary>event</primary><secondary>Java object</secondary></indexterm>
		<para>
			Plain-old Java object events are object instances that expose event properties through JavaBeans-style getter methods. Events classes or interfaces do not have to be fully compliant to the JavaBean specification; however for the Esper engine to obtain event properties, the required JavaBean getter methods must be present.
		</para>

		<para>
			Esper supports JavaBeans-style event classes that extend a superclass or implement one or more interfaces. Also, Esper event pattern and EPL statements can refer to Java interface classes and abstract classes. 
		</para>

		<para>
			Classes that represent events should be made immutable. As events are recordings of a state change or action that occurred in the past, the relevant event properties should not be changeable. However this is not a hard requirement and the Esper engine accepts events that are mutable as well.
		</para>

		<para>
			The <literal>hashCode</literal> and <literal>equals</literal> methods do not need to be implemented. The implementation of these methods by a Java event class does not affect the behavior of the engine in any way.
		</para>

		<para>
			Please see <xref linkend="configuration"/> on options for naming event types represented by Java object event classes.
		</para>

        <sect2 id="event-properties">
           <title>Java Object Event Properties </title>
           
			<para>
				As outlined earlier, the different property types are supported by the standard JavaBeans specification, and some of which are uniquely supported by Esper:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						<emphasis>Simple</emphasis> properties have a single value that may be retrieved. The underlying property type might be a Java language primitive (such as int, a simple object (such as a java.lang.String), or a more complex object whose class is defined either by the Java language, by the application, or by a class library included with the application.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Indexed</emphasis> - An indexed property stores an ordered collection of objects (all of the same type) that can be individually accessed by an integer-valued, non-negative index (or subscript). Alternatively, the entire set of values may be retrieved using an array. 
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Mapped</emphasis> - As an extension to standard JavaBeans APIs, Esper considers any property that accepts a String-valued key a mapped property. 
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Nested</emphasis> - A nested property is a property that lives within another Java object which itself is a property of an event. 
					</para>
				</listitem>
			</itemizedlist>
		
			<para>
				Assume there is an EmployeeEvent event class as shown below. The mapped and indexed properties in this example return Java objects but could also return Java language primitive types (such as int or String). The Address object and Employee objects can themselves have properties that are nested within them, such as a streetName in the Address object or a name of the employee in the Employee object.
			</para>
<programlisting><![CDATA[public class EmployeeEvent {
	public String getFirstName();
	public Address getAddress(String type);
	public Employee getSubordinate(int index);
	public Employee[] getAllSubordinates();
}
]]></programlisting>

			<para>
				<emphasis>Simple</emphasis> event properties require a getter-method that returns the property value. In this example, the <literal>getFirstName</literal> getter method returns the <literal>firstName</literal> event property of type String.
			</para>
	
			<para>
				<emphasis>Indexed</emphasis> event properties require either one of the following getter-methods. A method that takes an integer-type key value and returns the property value, such as the <literal>getSubordinate</literal> method. Or a method that returns an array-type such as the <literal>getSubordinates</literal> getter method, which returns an array of Employee. In an EPL or event pattern statement, indexed properties are accessed via the <literal>property[index]</literal> syntax.
			</para>
	
			<para>
				<emphasis>Mapped</emphasis> event properties require a getter-method that takes a String-typed key value and returns the property value, such as the <literal>getAddress</literal> method. In an EPL or event pattern statement, mapped properties are accessed via the <literal>property('key')</literal> syntax.
			</para>
	
			<para>
				<emphasis>Nested</emphasis> event properties require a getter-method that returns the nesting object. The <literal>getAddress</literal> and <literal>getSubordinate</literal> methods are mapped and indexed properties that return a nesting object. In an EPL or event pattern statement, nested properties are accessed via the <literal>property.nestedProperty</literal> syntax.
			</para>

			<para>
				All event pattern and EPL statements allow the use of indexed, mapped and nested properties (or a combination of these) anywhere where one or more event property names are expected. The below example shows different combinations of indexed, mapped and nested properties in filters of event pattern expressions:
			</para>

<programlisting><![CDATA[every EmployeeEvent(firstName='myName')
every EmployeeEvent(address('home').streetName='Park Avenue')
every EmployeeEvent(subordinate[0].name='anotherName')
every EmployeeEvent(allSubordinates[1].name='thatName')
every EmployeeEvent(subordinate[0].address('home').streetName='Water Street')
]]></programlisting>

			<para>
				Similarly, the syntax can be used in EPL statements in all places where an event property name is expected, such as in select lists, where-clauses or join criteria.
			</para>

<programlisting><![CDATA[select firstName, address('work'), subordinate[0].name, subordinate[1].name
from EmployeeEvent
where address('work').streetName = 'Park Ave'
]]></programlisting>

			<para>
				Property names follows Java standards: the class <literal>java.beans.Introspector</literal> and method <literal>getBeanInfo</literal> returns the property names as derived from the name of getter methods. In addition, Esper configuration provides a flag to turn off case-sensitive property names. A sample list of getter methods and property names is: 
			</para>

			<table frame="topbot">
				<title>JavaBeans-style Getter Methods and Property Names</title>
				<tgroup cols="3">
					<colspec colwidth="1*"/>
					<colspec colwidth="1*"/>
					<colspec colwidth="2*"/>
					<thead>
						<row>
							<entry>Method</entry>
							<entry>Property Name</entry>
							<entry>Example</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry><literal>getPrice()</literal></entry>
							<entry>price</entry>
							<entry><synopsis>select price from MyEvent</synopsis></entry>
						</row>
						<row>
							<entry><literal>getNAME()</literal></entry>
							<entry>NAME</entry>
							<entry><synopsis>select NAME from MyEvent</synopsis></entry>
						</row>
						<row>
							<entry><literal>getItemDesc()</literal></entry>
							<entry>itemDesc</entry>
							<entry><synopsis>select itemDesc from MyEvent</synopsis></entry>
						</row>
						<row>
							<entry><literal>getQ()</literal></entry>
							<entry>q</entry>
							<entry><synopsis>select q from MyEvent</synopsis></entry>
						</row>
						<row>
							<entry><literal>getQN()</literal></entry>
							<entry>QN</entry>
							<entry><synopsis>select QN from MyEvent</synopsis></entry>
						</row>
						<row>
							<entry><literal>getqn()</literal></entry>
							<entry>qn</entry>
							<entry><synopsis>select qn from MyEvent</synopsis></entry>
						</row>
						<row>
							<entry><literal>gets()</literal></entry>
							<entry>s</entry>
							<entry><synopsis>select s from MyEvent</synopsis></entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</sect2>
		
		<indexterm><primary>constants</primary></indexterm>
		<indexterm><primary>enumeration</primary></indexterm>
		<para>
			Constants are public static final fields in Java that may also participate in expressions of all kinds, as this example shows:
		</para>
		<programlisting><![CDATA[select * from MyEvent where property=MyConstantClass.FIELD_VALUE]]></programlisting>

		<para>
			Event properties that are enumeration values can be compared by their enumeration value:
		</para>
		<programlisting><![CDATA[select * from MyEvent where enumProp=EnumClass.ENUM_VALUE_1]]></programlisting>

		<para>
			Alternatively, a static method may be employed on a class, such as the enumeration class 'EnumClass' as below:
		</para>
		<programlisting><![CDATA[select * from MyEvent where enumProp=EnumClass.valueOf('ENUM_VALUE_1')]]></programlisting>

		<para>
			If your application does not import, through configuration, the package that contains the enumeration class, then it must also specify the package name of the class. Enumeration
			classes that are inner classes must be qualified with <literal>$</literal> following Java conventions.
		</para>
		<para>
			For example, the Color enumeration as an inner class to <literal>MyEvent</literal> in package <literal>org.myorg</literal> can be referenced as shown:
		</para>
		<programlisting><![CDATA[select * from MyEvent(enumProp=org.myorg.MyEvent$Color.GREEN).std:firstevent()]]></programlisting>

		<para>
			Instance methods may also be invoked on event instances by specifying a stream name, as shown below:
		</para>
		<programlisting><![CDATA[select myevent.computeSomething() as result from MyEvent as myevent]]></programlisting>

		<para>
			Java classes that do not follow JavaBean conventions, such as legacy Java classes that expose public fields, or methods not following naming conventions, require additional configuration. Via configuration it is also possible to control case sensitivity in property name resolution. The relevant section in the chapter on configuration is <xref linkend="config-java-legacy"/>.
		</para>
    </sect1>
    
	<sect1 id="eventrep-java-util-map">
	   <title><literal>java.util.Map</literal> Events</title>
	   
		<indexterm><primary>map event representation</primary></indexterm>
		<indexterm><primary>event</primary><secondary>Map representation</secondary></indexterm>

		<para>
			A given Map event type can have one or more supertypes that must also be Map event types. All properties available on any of the Map supertypes are available on the type itself. In addition, anywhere within EPL that an event type alias of a Map supertype is used, any of its Map subtypes and their subtypes match that expression.
		</para>

		<para>
			Your application can add properties to an existing Map event type during runtime using the configuration operation <literal>updateMapEventType</literal>. Properties may not be updated or deleted - properties can only be added, and nested properties can be added as well. The method accepts a Map structure that may include previously listed properties or can also contain only the newly added fields.
		</para>

		<para>
			The engine can process <literal>java.util.Map</literal> events via the <literal>sendEvent(Map map, String eventTypeAlias)</literal> method on the <literal>EPRuntime</literal> interface. Entries in the Map represent event properties. Keys must be of type <literal>java.util.String</literal> for the engine to be able to look up event property names specified by pattern or EPL statements. 
		</para>

		<sect2 id="eventrep-map-overview">
		   <title>Overview</title>
			<para>
				Events can also be represented by objects that implement the <literal>java.util.Map</literal> interface. 
				Event properties of <literal>Map</literal> events are the values in the map accessible through the <literal>get</literal> method exposed by the <literal>java.util.Map</literal> interface.
			</para>
	
			<para>
				The Map event type is a comprehensive type system that can eliminate the need to use Java classes as event types, thereby making it easier to change types at runtime or generate type information from another source.
			</para>
	
			<para>
				A given Map event type can have one or more supertypes that must also be Map event types. All properties available on any of the Map supertypes are available on the type itself. In addition, anywhere within EPL that an event type alias of a Map supertype is used, any of its Map subtypes and their subtypes match that expression.
			</para>
	
			<para>
				Your application can add properties to an existing Map event type during runtime using the configuration operation <literal>updateMapEventType</literal>. Properties may not be updated or deleted - properties can only be added, and nested properties can be added as well. The runtime configuration also allows removing Map event types and adding them back with new type information.
			</para>
	
			<para>
				After your application configures a Map event type by providing a type name, the type name can be used when defining further Map event types by specifying the type name as a property type or an array property type.
			</para>
	
			<para>
				One-to-Many relationships in Map event types are represented via arrays. A property in a Map event type may be an array of primitive, an array of Java object or an array of Map. 
			</para>
	
			<para>
				The engine can process <literal>java.util.Map</literal> events via the <literal>sendEvent(Map map, String eventTypeAlias)</literal> method on the <literal>EPRuntime</literal> interface. Entries in the Map represent event properties. Keys must be of type <literal>java.util.String</literal> for the engine to be able to look up event property names specified by pattern or EPL statements. 
			</para>
		</sect2>
			
		<sect2 id="eventrep-map-properties">
		   <title>Map Properties</title>
			<para>
				Map event properties can be of any type. Map event properties that are Java application objects or that are of type <literal>java.util.Map</literal> (or arrays thereof) offer additional power:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Properties that are Java application objects can be queried via the nested, indexed, mapped and dynamic property syntax as outlined earlier. 
					</para>
				</listitem>
				<listitem>
					<para>
						Properties that are of type <literal>Map</literal> allow Maps to be nested arbitrarily deep and thus can be used to represent complex domain information. The nested, indexed, mapped and dynamic property syntax can be used to query Maps within Maps and arrays of Maps within Maps. 					
					</para>
				</listitem>
			</itemizedlist>

			<para>
				In order to use <literal>Map</literal> events, the event type name and property names and types must be made known to the engine via Configuration. Please see the examples in <xref linkend="config-java-util-map"/>.
			</para>
											
			<para>
				The code snippet below creates and processes a <literal>Map</literal> event. It defines a <literal>CarLocationUpdateEvent</literal> event type first:
			</para>
	
			<programlisting><![CDATA[Map event = new HashMap();
event.put("carId", carId);
event.put("direction", direction);
epRuntime.sendEvent(event, "CarLocUpdateEvent");]]></programlisting>
	
			<para>
				The <literal>CarLocUpdateEvent</literal> can now be used in a statement:
			</para>
			<programlisting>select carId from CarLocUpdateEvent.win:time(1 min) where direction = 1</programlisting> 
			
			<para>
				The engine can also query Java objects as values in a <literal>Map</literal> event via the nested property syntax. Thus <literal>Map</literal> events can be used to 
				aggregate multiple data structures into a single event and query the composite information in a convenient way. The example below demonstrates a <literal>Map</literal> event with a transaction and an account object.
			</para>
			<programlisting><![CDATA[Map event = new HashMap();
event.put("txn", txn);
event.put("account", account);
epRuntime.sendEvent(event, "TxnEvent");]]></programlisting>

			<para>
				An example statement could look as follows.
			</para>
			<programlisting>select account.id, account.rate * txn.amount 
from TxnEvent.win:time(60 sec) 
group by account.id</programlisting> 		
		</sect2>

		<sect2 id="eventrep-map-supertype">
		   <title>Map Supertypes</title>
		   
		   <para>
			   Your <literal>Map</literal> event type may declare one or more supertypes when configuring the type at engine initialization time or at runtime through the administrative interface. 
		   </para>

		   <para>
			   Supertypes of a <literal>Map</literal> event type must also be Map event types. All property names and types of a supertype are also available on a subtype and override such same-name properties of the subtype. In addition, anywhere within EPL that an event type alias of a Map supertype is used, any of its Map subtypes also matches that expression (similar to the concept of interface in Java).
		   </para>
		   
		   <para>
			   This example assumes that the <literal>BaseUpdate</literal> event type has been declared and acts as a supertype to the <literal>AccountUpdate</literal> event type (both Map event types): 
		   </para>
		<programlisting><![CDATA[epService.getEPAdministrator().getConfiguration().
    addEventTypeAliasNestable("AccountUpdate", accountUpdateDef, 
    new String[] {"BaseUpdate"});]]></programlisting>

		   <para>
			   Your application EPL statements may select <literal>BaseUpdate</literal> events and receive both <literal>BaseUpdate</literal> and <literal>AccountUpdate</literal> events, as well as any other subtypes of <literal>BaseUpdate</literal> and their subtypes.
		   </para>
			<programlisting><![CDATA[// Receive BaseUpdate and any subtypes including subtypes of subtypes
select * from BaseUpdate]]></programlisting>

		   <para>
			   Your application Map event type may have multiple supertypes. The multiple inheritance hierarchy between Maps can be arbitrarily deep, however cyclic dependencies are not allowed. If using runtime configuration, supertypes must exist before a subtype to a supertype can be added.
		   </para>
		   
		   <para>
			   See <xref linkend="config-java-util-map"/> for more information on configuring Map event types.
		   </para>

	   </sect2>

		<sect2 id="eventrep-map-advanced">
		   <title>Advanced Map Property Types</title>

			<sect3 id="eventrep-map-nested">
			   <title>Nested Properties</title>
			   
			   <para>
				   Strongly-typed nested <literal>Map</literal>-within-<literal>Map</literal> events can be used to build rich, type-safe event types on the fly. Use the <literal>addEventTypeAliasNestable</literal> method on <literal>Configuration</literal> or <literal>ConfigurationOperations</literal> for initialization-time and runtime-time type definition.
			   </para>
	
			   <para>
				   Noteworthy points are:
			   </para>
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							JavaBean (POJO) objects can appear as properties in <literal>Map</literal>-within-<literal>Map</literal>. 
						</para>
					</listitem>
					<listitem>
						<para>
							One may represent Map-within-Map and Map-Array within Map using the name of a previously registered Map event type.
						</para>
					</listitem>
					<listitem>
						<para>
							There is no limit to the number of nesting levels.
						</para>
					</listitem>
					<listitem>
						<para>
							Dynamic properties can be used to query <literal>Map</literal>-within-<literal>Map</literal> keys that may not be known in advance. 
						</para>
					</listitem>
					<listitem>
						<para>
							The engine returns a <literal>null</literal> value for properties for which the access path into the nested structure cannot be followed where map entries do not exist.
						</para>
					</listitem>
				</itemizedlist>
	
			   <para>
				   For demonstration, in this example our top-level event type is an <literal>AccountUpdate</literal> event, which has an <literal>UpdatedField</literal> structure as a property. Inside the <literal>UpdatedField</literal> structure the example defines various fields, as well as a property by name 'history' that holds a JavaBean class <literal>UpdateHistory</literal> to represent the update history for the account. The code snippet to define the event type is thus:
			   </para>

			<programlisting><![CDATA[Map<String, Object> updatedFieldDef = new HashMap<String, Object>();
updatedFieldDef.put("name", String.class);
updatedFieldDef.put("addressLine1", String.class);
updatedFieldDef.put("history", UpdateHistory.class);

Map<String, Object> accountUpdateDef = new HashMap<String, Object>();
accountUpdateDef.put("accountId", long.class);
accountUpdateDef.put("fields", updatedFieldDef);

epService.getEPAdministrator().getConfiguration().
    addEventTypeAliasNestable("AccountUpdate", accountUpdateDef);]]></programlisting>

			   <para>
				   The next code snippet populates a sample event and sends the event into the engine:
			   </para>
	
			<programlisting><![CDATA[Map<String, Object> updatedField = new HashMap<String, Object>();
updatedField.put("name", "Joe Doe");
updatedField.put("addressLine1", "40 Popular Street");
updatedField.put("history", new UpdateHistory());

Map<String, Object> accountUpdate = new HashMap<String, Object>();
accountUpdate.put("accountId", 10009901);
accountUpdate.put("fields", updatedField);

epService.getEPRuntime().sendEvent(accountUpdate, "AccountUpdate");]]></programlisting>

			   <para>
				   Last, a sample query to interrogate <literal>AccountUpdate</literal> events is as follows:
			   </para>
				<programlisting><![CDATA[select accountId, fields.name, fields.addressLine1, fields.history.lastUpdate
from AccountUpdate]]></programlisting>

				<para>
					Note that type information for nested maps is only available to the immediately selecting stream. For example, the second select-query does not work:
				</para>			
				<programlisting><![CDATA[insert into MyStream select fields from NestedMapEvent
// this does not work ... instead select the individual fields in the insert-into statement
select fields.name from MyStream ]]></programlisting>
		   </sect3>
	
			<sect3 id="eventrep-map-typereuse">
			   <title>Map Event Type Properties</title>
			   
			   <para>
				   Your application may declare a Map event type for reuse within other Map event types or for one-to-many properties represented by an array of Maps.
			   </para>
	
			   <para>
				   This example declares a Map event type by name <literal>AmountCurrency</literal> with amount and currency properties:
			   </para>
	
			<programlisting><![CDATA[Map<String, Object> amountAndCurr = new HashMap<String, Object>();
amountAndCurr.put("amount", double.class);
amountAndCurr.put("currency", String.class);

epService.getEPAdministrator().getConfiguration().
    addEventTypeAliasNestable("AmountCurrency", amountAndCurr);]]></programlisting>

			   <para>
				   The <literal>AmountCurrency</literal> type is now available for use as a property type itself. Below code snippet declares <literal>OrderItem</literal> to hold an item number and <literal>AmountCurrency</literal>:
			   </para>
	
			<programlisting><![CDATA[Map<String, Object> orderItem = new HashMap<String, Object>();
orderItem.put("itemNum", int.class);
orderItem.put("price", "AmountCurrency");    // The property type is the name itself

epService.getEPAdministrator().getConfiguration().
    addEventTypeAliasNestable("OrderItem", orderItem);]]></programlisting>

		   </sect3>
	
			<sect3 id="eventrep-map-array">
			   <title>One-to-Many Relationships</title>
			   
			   <para>
				   To model repeated properties within a Map, you may use arrays as properties in a Map. You may use an array of primitive types or an array of JavaBean objects or an array of a previously declared Map event type.
			   </para>
	
			   <para>
				   When using a previously declared Map event type as an array property, the literal <literal>[]</literal> must be appended after the event type name.
			   </para>

			   <para>
				   This following example defines a Map event type by name <literal>Sale</literal> to hold array properties of the various types. It assumes a <literal>SalesPerson</literal> Java class exists and a Map event type by name <literal>OrderItem</literal> was declared:
			   </para>
	
			<programlisting><![CDATA[Map<String, Object> sale = new HashMap<String, Object>();
sale.put("userids", int[].class);
sale.put("salesPersons", SalesPerson[].class);
sale.put("items", "OrderItem[]");	 // The property type is the name itself appended by []

epService.getEPAdministrator().getConfiguration().
    addEventTypeAliasNestable("SaleEvent", sale);]]></programlisting>

			   <para>
				   The three properties that the above example declares are:
			   </para>
			   <itemizedlist>
				   <listitem>
					   <para>
						 An integer array of user ids.
					   </para>
				   </listitem>
				   <listitem>
					   <para>
						 An array of <literal>SalesPerson</literal> Java objects.
					   </para>
				   </listitem>
				   <listitem>
					   <para>
						 An array of Maps for order items.
					   </para>
				   </listitem>			   
			   </itemizedlist>
			   
			   <para>
				   The next EPL statement is a sample query asking for property values held by arrays:
			   </para>
	
			<programlisting><![CDATA[select userids[0], salesPersons[1].name, 
    items[1], items[1].price.amount from SaleEvent]]></programlisting>

		   </sect3>
		</sect2>
    </sect1>

	<sect1 id="eventrep-xml-dom">
	   <title><literal>org.w3c.dom.Node</literal> XML Events</title>
	   
		<indexterm><primary>XML event representation</primary></indexterm>
		<indexterm><primary>event</primary><secondary>XML representation</secondary></indexterm>
		<para>
			Events can also be represented as <literal>org.w3c.dom.Node</literal> instances and send into the engine via the <literal>sendEvent</literal> method on <literal>EPRuntime</literal>. Please note that configuration is required for allowing the engine to map the event type alias to <literal>Node</literal> element names. See <xref linkend="configuration"/>.
		</para>
		
		<para>
			Esper allows configuring XPath expressions as event properties. You can specify arbitrary XPath functions or expressions and provide a property name by which their result values will be available for use in expressions. For XML documents that follow an XML schema, Esper can load and interrogate your schema and validate event property names and types against the schema information. 
		</para>
			
		<para>
			Nested, mapped and indexed event properties are also supported in expressions against <literal>org.w3c.dom.Node</literal> events. Thus XML trees can conveniently be
			interrogated using the existing event property syntax for querying JavaBean objects, JavaBean object graphs or <literal>java.util.Map</literal> events.
		</para>

		<para>
			Let's look at how a sample XML document could be queried, given the sample XML below.
		</para>
		
<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<Sensor>
	<ID>urn:epc:1:4.16.36<ID>
	<Observation Command="READ_PALLET_TAGS_ONLY">
		<ID>00000001<ID>
		<Tag>
			<ID>urn:epc:1:2.24.400<ID>
		</Tag>
		<Tag>
			<ID>urn:epc:1:2.24.401<ID>
		</Tag>
	</Observation>
</Sensor>]]></programlisting>

		<para>
			To configure the engine for processing Sensor documents, simply configure a <literal>SensorEvent</literal> event type alias for the <literal>Sensor</literal> element name via Configuration. Now the document can be queried as below.
		</para>
<programlisting><![CDATA[select ID, Observation.ID, Observation.Command, Observation.Tag[0], countTags
from SensorEvent.win:time(30 sec)]]></programlisting>

		<para>
			The equivalent XPath expressions to each of the properties are listed below.
		</para>
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					The equivalent XPath expression to <literal>Observeration.ID</literal> is <literal>/Sensor/Observation/ID</literal>
				</para>
			</listitem>
			<listitem>
				<para>
					The equivalent XPath expression to <literal>Observeration.Command</literal> is <literal>/Sensor/Observation/@Command</literal>
				</para>
			</listitem>
			<listitem>
				<para>
					The equivalent XPath expression to <literal>Observeration.Tag[0]</literal> is <literal>/Sensor/Observation/Tag[position() = 1]</literal>
				</para>
			</listitem>
			<listitem>
				<para>
					The equivalent XPath expression to <literal>countTags</literal> is <literal>count(/Sensor/Observation/Tag)</literal> for returning a count of tag elements. This assumes the <literal>countTags</literal> property has been configured as an XPath property.
				</para>
			</listitem>
		</itemizedlist>

		<para>
			By specifying an event property such below:
		</para>			
		<programlisting><![CDATA[nestedElement.mappedElement('key').indexedElement[1]]]></programlisting>

		<para>
			The equivalent XPath expression is as follows:
		</para>
		<programlisting><![CDATA[/simpleEvent/nestedElement/mappedElement[@id='key']/indexedElement[position() = 2]]]></programlisting>

	</sect1>
   
	<sect1 id="eventrep-plug-in">
	   <title>Additional Event Representations</title>
	   
		<indexterm><primary>event</primary><secondary>additional representations</secondary></indexterm>
		<para>
		    Part of the extension and plug-in features of Esper is an event representation API. This set of classes allow an application to create new event types and event instances based on information available elsewhere, statically or dynamically at runtime when EPL statements are created. Please see <xref linkend="custom-event-representation"/> for details.
		</para>
		    
		<para>
			Creating a plug-in event representation can be useful when your application has existing Java classes that carry event metadata and event property values and your application does not want to (or cannot) extract or transform
such event metadata and event data into one of the built-in event representations (POJO Java objects, Map or XML DOM).
		</para>

		<para>
			Further use of a plug-in event representation is to provide a faster or short-cut access path to event data. For example, access to event data stored in an XML format through the Streaming API for XML (StAX) is known to be very efficient. A plug-in event representation can also provide network lookup and dynamic resolution of event type and dynamic sourcing of event instances.
		</para>
		
		<para>
			Currently, EsperIO provides the following additional event representations:
		</para>
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Apache Axiom: Streaming API for XML (StAX) implementation
				</para>
			</listitem>
		</itemizedlist>
		
		<para>
			Please see the EsperIO documentation for details on the above.
		</para>
		
		<para>
			The chapter on <xref linkend="custom-event-representation"/> explains how to create your own custom event representation.
		</para>
	</sect1>

	<sect1 id="eventrep-update">
	   <title>Updating and Versioning Events</title>
	   
		<indexterm><primary>event</primary><secondary>update</secondary></indexterm>
		<indexterm><primary>event</primary><secondary>version</secondary></indexterm>

        <para>
			To summarize, an event is an immutable record of a past occurrence of an action or state change, and event properties contain useful information about an event.
        </para>

        <para>
			The length of time an event is of interest to the event processing engine (retention time) depends on your EPL statements, and especially the data window, pattern and output rate 
			limiting clauses of your statements.
        </para>

        <para>
			During the retention time of an event more information about the event may become available, such as additional properties or changes to existing properties. 
			Esper provides the concept of revision event type to handle such situations. A revision event type instructs the engine that new versions of an existing event are to be processed that update, amend or add to an existing event.
        </para>
        
        <para>
			Revision event types work together with the named window feature of the engine: A named window provides an explicit expiration policy for event instances that can be updated,
			thereby allowing the engine to retain only those versions that are relevant to any retained event and discarding updates to events not retained.
        </para>

		<para>
			Please see <xref linkend="named_update"/> for further instructions and examples.
		</para>

		<para>
			Note that patterns do not reflect changes to past events. For the temporal nature of patterns, any changes to events that were observed in the past do not reflect upon current pattern state.
		</para>
	</sect1>

</chapter>






