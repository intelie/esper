<chapter id="epl_clauses">
    <title>EPL Reference: Clauses</title>
        
    <sect1 id="epl-intro">
        <title>EPL Introduction</title>

        <para>
			The Event Processing Language (EPL) is a SQL-like language with <literal>SELECT</literal>, <literal>FROM</literal>, <literal>WHERE</literal>, <literal>GROUP BY</literal>, <literal>HAVING</literal> and <literal>ORDER BY</literal> clauses. Streams replace tables as the source of data with events replacing rows as the basic unit of data. Since events are composed of data, the SQL concepts of correlation through joins, filtering and aggregation through grouping can be effectively leveraged. The <literal>INSERT INTO</literal> clause is recast as a means of forwarding events to other streams for further downstream processing. External data accessible through JDBC may be queried and joined with the stream data. Additional clauses such as the <literal>PATTERN</literal> and <literal>OUTPUT</literal> clauses are also available to provide the missing SQL language constructs specific to event processing.
        </para>

        <para>
			EPL statements are used to derive and aggregate information from one or more streams of events, and to join or merge event streams. This section outlines EPL syntax. It also outlines the built-in views, which are the building blocks for deriving and aggregating information from event streams. 
        </para>
        
        <para>
			EPL statements contain definitions of one or more views. Similar to tables in a SQL statement, views define the data available for querying and filtering. 
			Some views represent windows over a stream of events. Other views derive statistics from event properties, group events or handle unique event property values.
            Views can be staggered onto each other to build a chain of views. The Esper engine makes sure that views are reused among EPL statements for efficiency.
        </para>
        
        <para>
			The built-in set of views is:
         </para>

		<orderedlist spacing="compact">
			<listitem>
				<para>
					Data window views: <literal>win:length</literal>, <literal>win:length_batch</literal>, <literal>win:time</literal>, <literal>win:time_batch</literal>, <literal>win:time_length_batch</literal>, <literal>win:time_accum</literal>, <literal>win:ext_timed</literal>, <literal>ext:sort_window</literal>, <literal>ext:time_order</literal>, <literal>std:unique</literal>, <literal>std:groupby</literal>, <literal>std:lastevent</literal>, <literal>std:firstevent</literal>, <literal>std:firstunique</literal>, <literal>win:firstlength</literal>,  <literal>win:firsttime</literal>.
				</para>
			</listitem>
			<listitem>
				<para>
					Views that derive statistics: <literal>std:size</literal>, <literal>stat:uni</literal>, <literal>stat:linest</literal>, <literal>stat:correl</literal>, <literal>stat:weighted_avg</literal>.
				</para>
			</listitem>
		</orderedlist>

        <para>
			EPL provides the concept of <emphasis>named window</emphasis>. Named windows are data windows that can be inserted-into and deleted-from by one or more statements, and that can queried by one or more statements. Named windows have a global character, being visible and shared across an engine instance beyond a single statement. Use the <literal>CREATE WINDOW</literal> clause to create named windows. Use the <literal>INSERT INTO</literal> clause to insert data into a named window, the <literal>ON DELETE</literal> clause to remove events from a named window, and the <literal>ON SELECT</literal> clause to perform a non-continuous fire-once query on a named window. Finally, the name of the named window can occur in a statement's <literal>FROM</literal> clause to query a named window or include the named window in a join or subquery.
        </para>

        <para>
			<emphasis>Variables</emphasis> can come in handy to parameterize statements and change parameters on-the-fly and in response to events. Variables can be used in an expression anywhere in a statement as well as in the output clause for dynamic control of output rates.
        </para>

        <para>
			Esper can be extended by plugging-in custom developed views and aggregation functions.
        </para>

    </sect1>

    <sect1 id="epl-select-syntax">
        <title>EPL Syntax</title>
        
		<para>
			EPL queries are created and stored in the engine, and publish results to listeners as events are received by the engine or timer events occur that match the criteria specified in the query. Events can also be obtained from running EPL queries via the <literal>safeIterator</literal> and <literal>iterator</literal> methods that provide a pull-data API.
		</para>

		<para>
			The <literal>select</literal> clause in an EPL query specifies the event properties or events to retrieve. The <literal>from</literal> clause in an EPL query specifies the event stream definitions and stream names to use. The <literal>where</literal> clause in an EPL query specifies search conditions that specify which event or event combination to search for. For example, the following statement returns the average price for IBM stock ticks in the last 30 seconds.
		</para>

			<programlisting><![CDATA[select avg(price) from StockTick.win:time(30 sec) where symbol='IBM']]></programlisting>

		<para>
			EPL queries follow the below syntax. EPL queries can be simple queries or more complex queries. A simple select contains only a <literal>select</literal> clause and a single stream definition. Complex EPL queries can be build that feature a more elaborate select list utilizing expressions, may join multiple streams, may contain a <literal>where</literal> clause with search conditions and so on.
		</para>

<synopsis>[insert into <emphasis>insert_into_def</emphasis>]
select <emphasis>select_list</emphasis>
from <emphasis>stream_def</emphasis> [as name] [, <emphasis>stream_def</emphasis> [as name]] [,...]
[where <emphasis>search_conditions</emphasis>]
[group by <emphasis>grouping_expression_list</emphasis>]
[having <emphasis>grouping_search_conditions</emphasis>]
[output <emphasis>output_specification</emphasis>]
[order by <emphasis>order_by_expression_list</emphasis>]
[limit <emphasis>num_rows</emphasis>]
</synopsis>

		<sect2 id="epl-syntax-time-periods">
			<title>Specifying Time Periods</title>
			
			<para>
					Time-based windows as well as pattern observers and guards take a time period as a parameter. Time periods follow the syntax below.
			</para>
		
			<synopsis>time-period : [<emphasis>day-part</emphasis>] [<emphasis>hour-part</emphasis>] [<emphasis>minute-part</emphasis>] [<emphasis>seconds-part</emphasis>] [<emphasis>milliseconds-part</emphasis>]

day-part : <emphasis>(number|variable_name)</emphasis> ("days" | "day")
hour-part : <emphasis>(number|variable_name)</emphasis> ("hours" | "hour")
minute-part : <emphasis>(number|variable_name)</emphasis> ("minutes" | "minute" | "min")
seconds-part : <emphasis>(number|variable_name)</emphasis> ("seconds" | "second" | "sec")
milliseconds-part : <emphasis>(number|variable_name)</emphasis> ("milliseconds" | "millisecond" | "msec")</synopsis>
                
			<para>
					Some examples of time periods are:
			</para>
			<programlisting>10 seconds
10 minutes 30 seconds
20 sec 100 msec
1 day 2 hours 20 minutes 15 seconds 110 milliseconds
0.5 minutes</programlisting>

			<para>
					Variable names and substitution parameters '<literal>?</literal>' for prepared statements are also allowed as part of a time period expression.
			</para>
		</sect2>
		
		<sect2 id="epl-syntax-comments">
			<title>Using Comments</title>
			<para>
				Comments can appear anywhere in the EPL or pattern statement text where whitespace is allowed. Comments can be written in two ways: slash-slash (<literal>// ...</literal>) comments and slash-star (<literal>/* ... */</literal>) comments.
			</para>
	
			<para>
				Slash-slash comments extend to the end of the line:
			</para>
			<programlisting><![CDATA[// This comment extends to the end of the line.
// Two forward slashes with no whitespace between them begin such comments.

select * from MyEvent  // this is a slash-slash comment

// All of this text together is a valid statement.]]></programlisting>
	
			<para>
				Slash-star comments can span multiple lines:
			</para>
			<programlisting><![CDATA[/* This comment is a "slash-star" comment that spans multiple lines.
 * It begins with the slash-star sequence with no space between the '/' and '*' characters.
 * By convention, subsequent lines can begin with a star and are aligned, but this is 
 * not required.
 */		
select * from MyEvent  /* this also works */]]></programlisting>

			<para>
				Comments styles can also be mixed:
			</para>
			<programlisting><![CDATA[select field1, // first comment
  /* second comment*/  field2
  from MyEvent]]></programlisting>
		</sect2>

		<sect2 id="epl-syntax-keywords">
			<title>Reserved Keywords</title>
			<indexterm><primary>keywords</primary></indexterm>

			<para>
				Certain words such as <literal>select</literal>, <literal>delete</literal> or <literal>set</literal> are reserved and may not be used as identifiers. Please consult <xref linkend="appendix_keywords"/> for the list of reserved keywords and permitted keywords.
			</para>

			<para>
				Names of built-in functions and certain auxiliary keywords are permitted as event property names and in the rename syntax of the <literal>select</literal> clause. For example, <literal>count</literal> is acceptable. 
			</para>
			
			<para>
				Consider the example below, which assumes that <literal>'last'</literal> is an event property of MyEvent:
			</para>
			<programlisting><![CDATA[// valid
select last, count(*) as count from MyEvent]]></programlisting>
		
			<para>
				This example shows an incorrect use of a reserved keyword:
			</para>
			<programlisting><![CDATA[// invalid
select insert from MyEvent]]></programlisting>

			<para>
				EPL offers an escape syntax for reserved keywords: Event properties as well as event or stream names may be escaped via the backwards apostrophe <literal>`</literal> (ASCII 96) character.
			</para>

			<para>
				The next example queries an event type by name <literal>Order</literal> (a reserved keyword) that provides a property by name <literal>insert</literal> (a reserved keyword):
			</para>
			<programlisting><![CDATA[// valid
select `insert` from `Order`]]></programlisting>
		</sect2>

		<sect2 id="epl-syntax-datatype">
			<title>Data Types</title>
			<indexterm><primary>data types</primary></indexterm>
			
			<para>
				EPL honors all Java built-in primitive and boxed types, including <literal>java.math.BigInteger</literal> and <literal>java.math.BigDecimal</literal>.
			</para>

			<para>
				EPL also follows Java standards in terms of widening, performing widening automatically in cases where widening type conversion is allowed without loss of precision, for both boxed and primitive types and including <literal>BigInteger</literal> and <literal>BigDecimal</literal>:
			</para>
			<orderedlist spacing="compact">
				<listitem>
					<para>
						byte to short, int, long, float, double, BigInteger or BigDecimal
					</para>
				</listitem>
				<listitem>
					<para>
						short to int, long, float, or double, BigInteger or BigDecimal
					</para>
				</listitem>
				<listitem>
					<para>
						char to int, long, float, or double, BigInteger or BigDecimal
					</para>
				</listitem>
				<listitem>
					<para>
						int to long, float, or double, BigInteger or BigDecimal
					</para>
				</listitem>
				<listitem>
					<para>
						long to float or double, BigInteger or BigDecimal
					</para>
				</listitem>
				<listitem>
					<para>
						float to double or BigDecimal
					</para>
				</listitem>
				<listitem>
					<para>
						double to BigDecimal
					</para>
				</listitem>
			</orderedlist>

			<para>
				In cases where loss of precision is possible because of narrowing requirements, EPL compilation outputs a compilation error.
			</para>

			<para>
				EPL supports casting via the <literal>cast</literal> function.
			</para>

			<para>
				EPL returns double-type values for division regardless of operand type. EPL can also be configured to follow Java rules for integer arithmetic instead as described in <xref linkend="config-engine-expression"/>.
			</para>

			<para>
				Division by zero returns positive or negative infinity. Division by zero can be configured to return null instead.
			</para>

			<sect3 id="epl-syntax-datatype-constants">
				<title>Data Type of Constants</title>
				<indexterm><primary>constants</primary></indexterm>
				<indexterm><primary>literals</primary></indexterm>
	
				<para>
					An EPL constant is a number or a character string that indicates a fixed value. Constants can be used as expressions in many EPL statements, including variable assignment and case-when statements. They can also be used as parameter values for many built-in objects and clauses. Constants are also called literals.				
				</para>
				
				<para>
					EPL supports the standard SQL constant notation as well as Java data type literals.
				</para>
	
				<para>
					The following are types of EPL constants:
				</para>
	
				<table frame="topbot">
					<title>Types of EPL constants</title>
					<tgroup cols="3">
						<colspec colwidth="0.20*"/>
						<colspec colwidth="1*"/>
						<colspec colwidth="0.75*"/>
						<thead>
							<row>
								<entry>Type</entry>
								<entry>Description</entry>
								<entry>Examples</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>string</entry>
								<entry>A single character to an unlimited number of characters. Valid delimiters are the single quote (') or double quote (").</entry>
								<entry><programlisting><![CDATA[select 'volume' as field1,
   "sleep" as field2, 
  "\u0041" as unicodeA]]></programlisting></entry>
							</row>
							<row>
								<entry>boolean</entry>
								<entry>A boolean value.</entry>
								<entry><programlisting><![CDATA[select true as field1, 
  false as field2]]></programlisting></entry>
							</row>
							<row>
								<entry>integer</entry>
								<entry>An integer value (4 byte).</entry>
								<entry><programlisting><![CDATA[select 1 as field1, 
  -1 as field2, 
  1e2 as field3]]></programlisting></entry>
							</row>
							<row>
								<entry>long</entry>
								<entry>A long value (8 byte). Use the "L" or "l" (lowercase L) suffix.</entry>
								<entry><programlisting><![CDATA[select 1L as field1, 
  1l as field2]]></programlisting></entry>
							</row>
							<row>
								<entry>double</entry>
								<entry>A double-precision 64-bit IEEE 754 floating point.</entry>
								<entry><programlisting><![CDATA[select 1.67 as field1, 
  167e-2 as field2, 
  1.67d as field3]]></programlisting></entry>
							</row>
							<row>
								<entry>float</entry>
								<entry>A single-precision 32-bit IEEE 754 floating point. Use the "f" suffix.</entry>
								<entry><programlisting><![CDATA[select 1.2f as field1, 
  1.2F as field2]]></programlisting></entry>
							</row>
							<row>
								<entry>byte</entry>
								<entry>A 8-bit signed two's complement integer.</entry>
								<entry><programlisting><![CDATA[select 0x10 as field1]]></programlisting></entry>
							</row>
						</tbody>
					</tgroup>				
				</table>
				
				<para>
					EPL does not have a single-byte character data type for its literals. Single character literals are treated as string.
				</para>
				
				<para>
					Internal byte representation and boundary values of constants follow the Java standard.
				</para>

			</sect3>

			<sect3 id="epl-syntax-datatype-bignumber">
				<title>BigInteger and BigDecimal</title>

				<para>
					EPL automatically performs widening of numbers to <literal>BigInteger</literal> and <literal>BigDecimal</literal> as required, and employs the respective <literal>equals</literal>, <literal>compareTo</literal> and arithmetic methods provided by <literal>BigInteger</literal> and <literal>BigDecimal</literal>.
				</para>
	
				<para>
					To explicitly create <literal>BigInteger</literal> and <literal>BigDecimal</literal> constants in EPL, please use the cast syntax : <literal>cast(<emphasis>value</emphasis>, BigInteger)</literal>.
				</para>
				
				<para>
					Note that since <literal>BigDecimal.valueOf(1.0)</literal> is not the same as <literal>BigDecimal.valueOf(1)</literal> (in terms of equality through <literal>equals</literal>), care should be taken towards the consistent use of scale.
				</para>
				
				<para>
					When using aggregation functions for <literal>BigInteger</literal> and <literal>BigDecimal</literal> values, please note these limitations:
				</para>
				<orderedlist spacing="compact">
					<listitem>
						<para>
							The <literal>median</literal>, <literal>stddev</literal> and <literal>avedev</literal> aggregation functions operate on the double value of the object and return a double value.
						</para>
					</listitem>
					<listitem>
						<para>
							All other aggregation functions return <literal>BigDecimal</literal> or <literal>BigInteger</literal> values (except <literal>count</literal>).
						</para>
					</listitem>
				</orderedlist>

			</sect3>

		</sect2>

    </sect1>

    <sect1 id="epl-select-list">
        <title>Choosing Event Properties And Events: the <emphasis>Select</emphasis> Clause</title>
        
		<indexterm><primary>select clause</primary></indexterm>
		<indexterm><primary>EPL</primary><secondary>select clause</secondary></indexterm>
		<para>
			The <literal>select</literal> clause is required in all EPL statements. The <literal>select</literal> clause can be used to select all properties via the wildcard <literal>*</literal>, or to specify a list of event properties and expressions. The <literal>select</literal> clause defines the event type (event property names and types) of the resulting events published by the statement, or pulled from the statement via the iterator methods.
		</para>

		<para>
			The <literal>select</literal> clause also offers optional <literal>istream</literal>, <literal>irstream</literal> and <literal>rstream</literal> keywords to control whether input stream, remove stream or input and remove stream events are posted to <literal>UpdateListener</literal> instances and observers to a statement. By default, the engine provides only the insert stream to listener and observers. See <xref linkend="config-engine-stream-selection"/> on how to change the default.
		</para>

		<para>
			The syntax for the <literal>select</literal> clause is summarized below.
		</para>

		<synopsis>select [istream | irstream | rstream] * | <emphasis>expression_list</emphasis> ... </synopsis>

		<para>
			The <literal>istream</literal> keyword is the default, and indicates that the engine only delivers insert stream events to listeners and observers. The <literal>irstream</literal> keyword indicates that the engine delivers both insert and remove stream. Finally, the <literal>rstream</literal> keyword tells the engine to deliver only the remove stream.
		</para>

        <sect2 id="epl-select-all-props" >
           <title>Choosing all event properties: select *</title>

			<para>
				The syntax for selecting all event properties in a stream is:
			</para>
			<synopsis>select * from <emphasis>stream_def</emphasis></synopsis>

			<para>
				The following statement selects StockTick events for the last 30 seconds of IBM stock ticks.
			</para>
			<programlisting><![CDATA[select * from StockTick(symbol='IBM').win:time(30 sec)]]></programlisting>

			<para>
				The <literal>*</literal> wildcard and expressions can also be combined in a <literal>select</literal> clause. The combination selects all event properties and in addition the computed values
				as specified by any additional expressions that are part of the <literal>select</literal> clause. Here is an example that selects all properties of stock tick events plus a computed product of price and volume that the 
				statement names 'pricevolume':
			</para>
			<programlisting><![CDATA[select *, price * volume as pricevolume from StockTick(symbol='IBM')]]></programlisting>

			<para>
				When using wildcard (*), Esper does not actually copy your event properties out of your event or events. It simply wraps your native type in an <literal>EventBean</literal> interface. Your application has access to
				the underlying event object through the <literal>getUnderlying</literal> method and has access to the property values through the <literal>get</literal> method.
			</para>

			<para>
				In a join statement, using the <literal>select *</literal> syntax selects one event property per stream to hold the event for that stream. The property name is the stream name in the <literal>from</literal> clause. 
			</para>
		</sect2>

        <sect2 id="epl-select-event-props" >
           <title>Choosing specific event properties</title>
			<para>
				To choose the particular event properties to return:
			</para>
			<synopsis>select <emphasis>event_property</emphasis> [, <emphasis>event_property</emphasis>] [, ...] from <emphasis>stream_def</emphasis></synopsis>

			<para>
				The following statement simply selects the symbol and price properties of stock ticks, and the total volume for stock tick events in a 60-second time window. 
			</para>
			<programlisting><![CDATA[select symbol, price, sum(volume) from StockTick(symbol='IBM').win:time(60 sec)
]]></programlisting>

			<para>
				The following statement declares a further view onto the event stream of stock ticks: the univariate statistics view (<literal>stat:uni</literal>). The statement selects the properties that this view derives from the stream, for the last 100 events of IBM stock ticks in the length window.
			</para>
			<programlisting><![CDATA[select datapoints, total, average, variance, stdev, stdevpa 
from StockTick(symbol='IBM').win:length(100).stat:uni(volume)]]></programlisting>
		</sect2>

        <sect2 id="epl-select-expressions" >
           <title>Expressions</title>
			<para>
				The <literal>select</literal> clause can contain one or more expressions.
			</para>
			<synopsis>select <emphasis>expression</emphasis> [, <emphasis>expression</emphasis>] [, ...] from <emphasis>stream_def</emphasis></synopsis>

			<para>
				The following statement selects the volume multiplied by price for a time batch of the last 30 seconds of stock tick events. 
			</para>
			<programlisting><![CDATA[select volume * price from StockTick.win:time_batch(30 sec)]]></programlisting>
		</sect2>

        <sect2 id="epl-select-renaming" >
            <title>Renaming event properties</title>
			<para>
				Event properties and expressions can be renamed using below syntax.
			</para>
			<synopsis>select [<emphasis>event_property</emphasis> | <emphasis>expression</emphasis>] as <emphasis>identifier</emphasis> [, ...]</synopsis>

			<para>
				The following statement selects volume multiplied by price and specifies the name <emphasis>volPrice</emphasis> for the resulting column.
			</para>
			<programlisting><![CDATA[select volume * price as volPrice from StockTick.win:length(100)]]></programlisting>

			<para>
				Identifiers cannot contain the "." (dot) character, i.e. "vol.price" is not a valid identifier for the rename syntax.
			</para>
		</sect2>
		
        <sect2 id="epl-select-all-join">
           <title>Choosing event properties and events in a join</title>
           
			<para>
				If your statement is joining multiple streams, your may specify property names that are unique among the joined streams, or use wildcard (*) as explained earlier.
			</para>

			<para>
				In case the property name in your <literal>select</literal> or other clauses is not unique considering all joined streams, you will need to use the name of the stream as a prefix to the property.
			</para>

			<para>
				This example is a join between the two streams StockTick and News, respectively named as 'tick' and 'news'. The example selects from the StockTick event the symbol value using the 'tick' stream name as a prefix:
			</para>
			<programlisting><![CDATA[select tick.symbol from StockTick.win:time(10) as tick, News.win:time(10) as news]]></programlisting>

			<para>
				Use the wildcard (*) selector in a join to generate a property for each stream, with the property value being the event itself. The output events of the statement below have two properties: the 'tick' property holds the StockTick event and the 'news' property holds the News event:
			</para>
			<programlisting><![CDATA[select * from StockTick.win:time(10) as tick, News.win:time(10) as news]]></programlisting>

			<para>
				The following syntax can also be used to specify what stream's properties to select:
			</para>
			<synopsis>select <emphasis>stream_name</emphasis>.* [as <emphasis>name</emphasis>] from ...</synopsis>

			<para>
				The selection of <literal>tick.*</literal> selects the StockTick stream events only:
			</para>
			<programlisting><![CDATA[select tick.* from StockTick.win:time(10) as tick, News.win:time(10) as news
where tick.symbol = news.symbol]]></programlisting>

			<para>
				The next example uses the <literal>as</literal> keyword to name each stream's joined events. This instructs the engine to create a property for each named event:
			</para>
			<programlisting><![CDATA[select tick.* as stocktick, news.* as news 
from StockTick.win:time(10) as tick, News.win:time(10) as news
where stock.symbol = news.symbol]]></programlisting>

			<para>
				The output events of the above example have two properties 'stocktick' and 'news' that are the StockTick and News events.
			</para>

			<para>
				The stream name itself, as further described in <xref linkend="epl-from-clause-stream-name"/>, may be used within expressions or alone. 
			</para>
			
			<para>
				This example passes events to a user-defined function named <literal>compute</literal> and also shows <literal>insert-into</literal> to populate an event stream of combined events:
			</para>
			<programlisting><![CDATA[insert into TickNewStream select tick, news, MyLib.compute(news, tick) as result
from StockTick.win:time(10) as tick, News.win:time(10) as news
where tick.symbol = news.symbol

// second statement that uses the TickNewStream stream
select tick.price, news.text, result from TickNewStream]]></programlisting>

			<para>
				In summary, the <emphasis>stream_name.*</emphasis> streamname wildcard syntax can be used to select a stream as the underlying event or as a property, but cannot appear within an expression. While the <emphasis>stream_name</emphasis> syntax (without wildcard) always selects a property (and not as an underlying event), and can occur anywhere within an expression.
			</para>
		</sect2>

        <sect2 id="epl-select-pattern" >
           <title>Choosing event properties and events from a pattern</title>
           
			<para>
				If your statement employs pattern expressions, then your pattern expression tags events with a tag name. Each tag name becomes available for use as a property in the <literal>select</literal> clause and all other clauses.
			</para>
			
			<para>
				For example, here is a very simple pattern that matches on every StockTick event received within 30 seconds after start of the statement. The sample selects the symbol and price properties of the matching events:
			</para>
			<programlisting><![CDATA[select tick.symbol as symbol, tick.price as price
from pattern[every tick=StockTick where timer:within(10 sec)]]]></programlisting>

			<para>
				The use of the wildcard selector, as shown in the next statement, creates a property for each tagged event in the output. The next statement outputs events that hold a single 'tick' property whose value is the event itself:
			</para>
			<programlisting><![CDATA[select * from pattern[every tick=StockTick where timer:within(10 sec)]]]></programlisting>

			<para>
				You may also select the matching event itself using the <literal>tick.*</literal> syntax. The engine outputs the StockTick event itself to listeners:
			</para>
			<programlisting><![CDATA[select tick.* from pattern[every tick=StockTick where timer:within(10 sec)]]]></programlisting>

			<para>
				A tag name as specified in a pattern is a valid expression itself. This example uses the <literal>insert into</literal> clause to make available the events matched by a pattern to further statements:
			</para>
			<programlisting><![CDATA[// make a new stream of ticks and news available
insert into StockTickAndNews 
select tick, news from pattern [every tick=StockTick -> news=News(symbol=tick.symbol)]
      
// second statement to select from the stream of ticks and news
select tick.symbol, tick.price, news.text from StockTickAndNews]]></programlisting>
		</sect2>

        <sect2 id="epl-select-using-istream-rstream" >
            <title>Selecting <literal>insert</literal> and <literal>remove</literal> stream events</title>

			<para>
				The optional <literal>istream</literal>, <literal>irstream</literal> and <literal>rstream</literal> keywords in the <literal>select</literal> clause control the event streams posted to listeners and observers to a statement. 
			</para>

			<para>
				If neither keyword is specified, and in the default engine configuration, the engine posts only 
				insert stream events via the <literal>newEvents</literal> parameter to the <literal>update</literal> method of <literal>UpdateListener</literal> instances listening to 
				the statement. The engine does not post remove stream events, by default.
				</para>
			
			<para>
				The insert stream consists of the events entering the respective window(s) or stream(s) or aggregations, while the remove stream consists of the events leaving the respective window(s) or the changed aggregation result.
				See <xref linkend="processingmodel"/> for more information on insert and remove streams.
				</para>

			<para>
				The engine posts remove stream events to the <literal>oldEvents</literal> parameter of the <literal>update</literal> method only if either the <literal>irstream</literal> or the <literal>rstream</literal> keyword
				occurs in the <literal>select</literal> clause. This behavior can be changed via engine-wide configuration as described in <xref linkend="config-engine-stream-selection"/>.
			</para>

			<para>
				By specifying the <literal>istream</literal> keyword you can instruct the engine to only post insert stream events via the <literal>newEvents</literal> parameter to the <literal>update</literal> method on listeners. The engine will then not post any remove stream events, and the <literal>oldEvents</literal> parameter is always a null value.
			</para>
				
			<para>
				By specifying the <literal>irstream</literal> keyword you can instruct the engine to post both insert stream and remove stream events.
			</para>

			<para>
				By specifying the <literal>rstream</literal> keyword you can instruct the engine to only post remove stream events via the <literal>newEvents</literal> parameter to the <literal>update</literal> method on listeners. The engine will then not post any insert stream events, and the <literal>oldEvents</literal> parameter is also always a null value.
			</para>

			<para>
				The following statement selects only the events that are leaving the 30 second time window.
			</para>
			<programlisting><![CDATA[select rstream * from StockTick.win:time(30 sec)]]></programlisting>

			<para>
				The <literal>istream</literal> and <literal>rstream</literal> keywords in the <literal>select</literal> clause are matched by same-name keywords available in the <literal>insert into</literal> clause. While the keywords in the <literal>select</literal> clause control the event stream posted to listeners to the statement, the same keywords in the <literal>insert into</literal> clause specify the event stream that the engine makes available to other statements.
			</para>
		</sect2>

		<sect2 id="epl-syntax-prefix-propsandstream">
			<title>Qualifying property names and stream names</title>
			
			<para>
				Property or column names can optionally be qualified by a stream name and the provider URI. The syntax is:
			</para>
			<synopsis>[[<emphasis>provider_URI</emphasis>.]<emphasis>stream_name</emphasis>.]<emphasis>property_name</emphasis></synopsis>

			<para>
				The <emphasis>provider_URI</emphasis> is the URI supplied to the <literal>EPServiceProviderManager</literal> class, or the string <literal>default</literal> for the default provider.
			</para>
		
			<para>
				This example assumes the provider is the default provider:
			</para>
			<programlisting>select MyEvent.myProperty from MyEvent
// ... equivalent to ...
select default.MyEvent.myProperty from MyEvent</programlisting>

			<para>
				Stream names can also be qualified by the provider URI. The syntax is:
			</para>
			<synopsis>[<emphasis>provider_URI</emphasis>.]<emphasis>stream_name</emphasis></synopsis>

			<para>
				The next example assumes a provider URI by name of <literal>Processor</literal>:
			</para>
			<programlisting>select Processor.MyEvent.myProperty from Processor.MyEvent</programlisting>

		</sect2>

    </sect1>

    <sect1 id="epl-from-clause">
        <title>Specifying Event Streams: the <emphasis>From</emphasis> Clause</title>

		<indexterm><primary>join</primary><secondary>from clause</secondary></indexterm>
		<indexterm><primary>from clause</primary></indexterm>
		<indexterm><primary>EPL</primary><secondary>from clause</secondary></indexterm>
		<para>
			The <literal>from</literal> clause is required in all EPL statements. It specifies one or more event streams or named windows. Each event stream or named window can optionally be given a name by means of the <literal>as</literal> keyword.
		</para>
		<synopsis>from <emphasis>stream_def</emphasis> [as <emphasis>name</emphasis>] [unidirectional] [retain-union | retain-intersection] 
    [, <emphasis>stream_def</emphasis> [as <emphasis>stream_name</emphasis>]] [, ...]</synopsis>

		<para>
			The event stream definition <emphasis>stream_def</emphasis> as shown in the syntax above can consists of either a filter-based event stream definition or a pattern-based event stream definition. 
		</para>

		<para>
			For joins and outer joins, specify two or more event streams. Joins between pattern-based and filter-based event streams are also supported. Joins and the <literal>unidirectional</literal> keyword are described in more detail in <xref linkend="epl-join"/>.
		</para>

		<para>
			Esper supports joins against relational databases for access to historical or reference data as explained in <xref linkend="histdata_overview"/>. Esper can also join results returned by an arbitrary method invocation, as discussed in <xref linkend="joining_method"/>.
		</para>

		<para>
			The <emphasis>stream_name</emphasis> is an optional identifier assigned to the stream. The stream name can itself occur in any expression and provides access to the event itself from the named stream. Also, a stream name may be combined with a method name to invoke instance methods on events of that stream.
		</para>

		<para>
			For all streams with the exception of historical sources your query may employ data window views as outlined below. The <literal>retain-intersection</literal> (the default) and <literal>retain-union</literal> keywords build a union or intersection of two or more data windows as described in <xref linkend="epl-from-clause-view-multidatawindow"/>.
		</para>

        <sect2 id="epl-from-clause-filter" >
           <title>Filter-based Event Streams</title>

			<para>
				The <emphasis>stream_def</emphasis> syntax for a filter-based event stream is as below:
			</para>
	
			<synopsis><emphasis>event_stream_name</emphasis> [(<emphasis>filter_criteria</emphasis>)] [<emphasis>contained_selection</emphasis>] [.<emphasis>view_spec</emphasis>] [.<emphasis>view_spec</emphasis>] [...]</synopsis>
	
			<para>
			  The <emphasis>event_stream_name</emphasis> is either the name of an event type or name of an event stream populated by an <literal>insert into</literal> statement or the name of a named window.
			</para>
			
			<para>
			  The <emphasis>filter_criteria</emphasis> is optional and consists of a list of expressions filtering the events of the event stream, within parenthesis after the event stream name.
			</para>

			<para>
			  The <emphasis>contained_selection</emphasis> is optional and is for use with coarse-grained events that have properties that are themselves one or more events, see <xref linkend="epl-containedeventselect"/> for the synopsis and examples.
			</para>
			
			<para>
			  The <emphasis>view_spec</emphasis> are optional view specifications, which are combinable definitions for retaining events and for deriving information from events.
			</para>

			<para>
				The following EPL statement shows event type, filter criteria and views combined in one statement. It selects all event properties for the last 100 events of IBM stock ticks for volume. In the example, the event type is the fully qualified Java class name <literal>org.esper.example.StockTick</literal>. The expression filters for events where the property <literal>symbol</literal> has a value of "IBM". The optional view specifications for deriving data from the StockTick events are a length window and a view for computing statistics on volume. The name for the event stream is "volumeStats".
			</para>
			<programlisting><![CDATA[select * from 
  org.esper.example.StockTick(symbol='IBM').win:length(100).stat:uni(volume) as volumeStats]]></programlisting>
	
			<para>
				Esper filters out events in an event stream as defined by filter criteria before it sends events to subsequent views. Thus, compared to search conditions in a <literal>where</literal> clause, filter criteria remove unneeded events early. In the above example, events with a symbol other then IBM do not enter the time window.
			</para>

			<sect3 id="epl-filter-event-type" >
			   <title>Specifying an Event Type</title>

				<para>
					The simplest form of filter is a filter for events of a given type without any conditions on the event property values. This filter matches any event of that type regardless of the event's properties. The example below is such a filter. 
				 </para>
				 <programlisting><![CDATA[select * from com.mypackage.myevents.RfidEvent]]></programlisting>

				<para>
					Instead of the fully-qualified Java class name any other event name can be mapped via Configuration to a Java class, making the resulting statement more readable:
				</para>
				<programlisting><![CDATA[select * from RfidEvent]]></programlisting>

				 <para>
					 Interfaces and superclasses are also supported as event types. In the below example <literal>IRfidReadable</literal> is an interface class.
				 </para>
				 <programlisting><![CDATA[select * from org.myorg.rfid.IRfidReadable]]></programlisting>
			</sect3>
		
			<sect3 id="epl-filter-criteria" >
			   <title>Specifying Filter Criteria</title>
				<para>
					The filtering criteria to filter for events with certain event property values are placed within parenthesis after the event type name:
				 </para>
				 <programlisting><![CDATA[select * from RfidEvent(category="Perishable")]]></programlisting>
				 
				<para>
					All expressions can be used in filters, including static methods that return a boolean value:
				 </para>
				 <programlisting><![CDATA[select * from com.mycompany.RfidEvent(MyRFIDLib.isInRange(x, y) or (x < 0 and y < 0))]]></programlisting>
					
				<para>
					Filter expressions can be separated via a single comma '<literal>,</literal>'. The comma represents a logical AND between filter expressions:
				 </para>
				 <programlisting><![CDATA[select * from RfidEvent(zone=1, category=10)
...is equivalent to...
select * from RfidEvent(zone=1 and category=10)]]></programlisting>
	
				<para>
					The following operators are highly optimized through indexing and are the preferred means of filtering in high-volume event streams:
				</para>
		
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							equals <literal>=</literal>
						</para>
					</listitem>
					<listitem>
						<para>
							not equals <literal>!=</literal>
						</para>
					</listitem>
					<listitem>
						<para>
							comparison operators <literal>&lt; , &gt; , &gt;=, &lt;=</literal>
						</para>
					</listitem>
					<listitem>
						<para>
							ranges 
						</para>
						<itemizedlist spacing="compact">
							<listitem>
								<para>
									use the <literal>between</literal> keyword for a closed range where both endpoints are included
								</para>
							</listitem>
							<listitem>
								<para>
									use the <literal>in </literal> keyword and round <literal>()</literal> or square brackets <literal>[]</literal> to control how endpoints are included
								</para>
							</listitem>
							<listitem>
								<para>
									for inverted ranges use the <literal>not</literal> keyword and the <literal>between</literal> or <literal>in</literal> keywords
								</para>
							</listitem>
						</itemizedlist>
					</listitem>
					<listitem>
						<para>
							list-of-values checks using the <literal>in</literal> keyword or the <literal>not in </literal> keywords followed by a comma-separated list of values
						</para>
					</listitem>
				</itemizedlist>
	
				<para>
					At compile time as well as at run time, the engine scans new filter expressions for sub-expressions that can be indexed. Indexing filter values to match event properties of incoming events enables the engine to match incoming events faster. The above list of operators represents the set of operators that the engine can best convert into indexes. The use of comma or logical <literal>and</literal> in filter expressions does not impact optimizations by the engine. 
				</para>
			</sect3>
			
			<sect3 id="epl-filter-ranges" >
				<title>Filtering Ranges</title>
				<para>
					Ranges come in the following 4 varieties. The use of round <literal>()</literal> 
					or square <literal>[]</literal> bracket dictates whether an endpoint is included or excluded. The low point and the high-point of the range are separated by the colon <literal>:</literal> character.
				 </para>
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							Open ranges that contain neither endpoint <literal>(low:high)</literal>
						</para>
					</listitem>
					<listitem>
						<para>
							Closed ranges that contain both endpoints <literal>[low:high]</literal>. The equivalent 'between' keyword also defines a closed range.
						</para>
					</listitem>
					<listitem>
						<para>
							Half-open ranges that contain the low endpoint but not the high endpoint <literal>[low:high)</literal>
						</para>
					</listitem>
					<listitem>
						<para>
							Half-closed ranges that contain the high endpoint but not the low endpoint <literal>(low:high]</literal>
						</para>
					</listitem>
				</itemizedlist>
				
				<para>
					The next statement shows a filter specifying a range for <literal>x</literal> and <literal>y</literal> values of RFID events. The range includes both endpoints therefore uses <literal>[]</literal> hard brackets.
				</para>
				<programlisting><![CDATA[mypackage.RfidEvent(x in [100:200], y in [0:100])]]></programlisting>
	
				<para>
					The <literal>between</literal> keyword is equivalent for closed ranges. The same filter using the <literal>between</literal> keyword is:
				</para>
				<programlisting><![CDATA[mypackage.RfidEvent(x between 100 and 200, y between 0 and 50)]]></programlisting>
	
				<para>
					The <literal>not</literal> keyword can be used to determine if a value falls outside a given range:
				</para>
				<programlisting><![CDATA[mypackage.RfidEvent(x not in [0:100])]]></programlisting>
	
				<para>
					The equivalent statement using the <literal>between</literal> keyword is:
				</para>
				<programlisting><![CDATA[mypackage.RfidEvent(x not between 0 and 100)]]></programlisting>
			</sect3>
			
			<sect3 id="epl-filter-in" >
				<title>Filtering Sets of Values</title>
				<para>
					The <literal>in</literal> keyword for filter criteria determines if a given value matches any value in a list of values.
				 </para>
	
				<para>
					In this example we are interested in RFID events where the category matches any of the given values:
				</para>
				<programlisting><![CDATA[mypackage.RfidEvent(category in ('Perishable', 'Container'))]]></programlisting>
	
				<para>
					By using the <literal>not in </literal>keywords we can filter events with a property value that does not match any of the values in a list of values:
				 </para>
				<programlisting><![CDATA[mypackage.RfidEvent(category not in ('Household', 'Electrical'))]]></programlisting>
			</sect3>
			
			<sect3 id="epl-filter-limitations" >
				<title>Filter Limitations</title>
				<para>
					The following restrictions apply to filter criteria:
				</para>        
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							Range and comparison operators require the event property to be of a numeric type. 
						</para>
					</listitem>
					<listitem>
						<para>
							Aggregation functions are not allowed within filter expressions.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>prev</literal> previous event function and the <literal>prior</literal> prior event function cannot be used in filter expressions.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>
		</sect2>
		
        <sect2 id="epl-from-clause-patterns" >
           <title>Pattern-based Event Streams</title>
			<para>
				Event pattern expressions can also be used to specify one or more event streams in an EPL statement.
				For pattern-based event streams, the event stream definition <emphasis>stream_def</emphasis> consists of the keyword <literal>pattern</literal> and a pattern expression in brackets <literal>[]</literal>. The syntax for an event stream definition using a pattern expression is below. As in filter-based event streams, an optional list of views that derive data from the stream can be supplied.
			</para>
			
			<synopsis>pattern [<emphasis>pattern_expression</emphasis>] [.<emphasis>view_spec</emphasis>] [.<emphasis>view_spec</emphasis>] [...]</synopsis>

			<para>
				The next statement specifies an event stream that consists of both stock tick events and trade events. The example tags stock tick events with the name "tick" and trade events with the name "trade".
			</para>			
            <programlisting><![CDATA[select * from pattern [every tick=StockTickEvent or every trade=TradeEvent]]]></programlisting>
			
			<para>
				This statement generates an event every time the engine receives either one of the event types. The generated events resemble a map with "tick" and "trade" keys. For stock tick events, the "tick" key value is the underlying stock tick event, and the "trade" key value is a null value. For trade events, the "trade" key value is the underlying trade event, and the "tick" key value is a null value.
			</para>			

			<para>
				Lets further refine this statement adding a view the gives us the last 30 seconds of either stock tick or trade events. Lets also select prices and a price total.
			</para>			
            <programlisting><![CDATA[select tick.price as tickPrice, trade.price as tradePrice, 
       sum(tick.price) + sum(trade.price) as total
  from pattern [every tick=StockTickEvent or every trade=TradeEvent].win:time(30 sec)]]></programlisting>

			<para>
				Note that in the statement above <literal>tickPrice</literal> and <literal>tradePrice</literal> can each be null values depending on the event processed. Therefore, an aggregation function such as <literal>sum(tick.price + trade.price))</literal> would always return null values as either of the two price properties are always a null value for any event matching the pattern. Use the <literal>coalesce</literal> function to handle null values, for example: <literal>sum(coalesce(tick.price, 0) + coalesce(trade.price, 0))</literal>.
			</para>			
		</sect2>

        <sect2 id="epl-from-clause-view-spec" >
           <title>Specifying Views</title>
			<para>
				Views are used to derive or aggregate data. Views can be staggered onto each other. See the section <xref linkend="epl-views"/> on the views available that also outlines the different types of views: Data Window views and Derived-Value views.
			</para>
						
			<para>
				Views can optionally take one or more parameters. These parameters are expressions themselves that may consists of any combination of variables, arithmatics, user-define function or substituion parameters for prepared statements, as example.
			</para>

			<para>
				The below example serves to show views and staggering of views. It uses a car location event that contains information about the location of a car on a highway. 
			</para>
				
         <programlisting><![CDATA[select * from CarLocEvent.std:groupby(carId).win:length(4).
  std:groupby(expressway, direction, segment).std:size()]]></programlisting>

			<para>
				The first view <literal>std:groupby(carId)</literal> groups car location events by car id. The second view <literal>win:length(4)</literal> keeps a length window of the 4 last events, with one length window for each car id. The next view <literal>std:groupby(expressway, direction, segment)</literal> groups each event by its expressway, direction and segment property values. Again, the grouping is done for each car id considering the last 4 events only. The last view <literal>std:size()</literal> is used to report the number of events. Thus the below example reports the number of events per car id and per expressway, direction and segment considering the last 4 events for each car id only. 
			</para>
			
			<para>
				When views are staggered onto each other as a chain of views, then the insert and remove stream received by each view is the insert and remove stream made available by the view (or stream) earlier in the chain. 
			</para>

			<para>
				The special keep-all view keeps all events: It does not provide a remove stream, i.e. events are not removed from the keep-all view unless by means of the <literal>on-delete</literal> syntax or by revision events.
			</para>
		</sect2>

		<sect2 id="epl-from-clause-view-multidatawindow" >
		   <title>Multiple Data Window Views</title>
		   <para>
			   Data window views provide an expiry policy that indicates when to remove events from the data window, with the exception of the keep-all data window which has no expiry policy and the group-by view for allocating a new data window per group.
		   </para>
		   
		   <para>
			   EPL allows the freedom to use multiple data window views onto a stream and thus combine expiry policies. Combining data windows into a intersection (the default) or a union can achieve a useful strategy for retaining events and expiring events that are no longer of interest. Named windows and the <literal>on-delete</literal> syntax provide an additional degree of freedom.
		   </para>

		   <para>
			   In order to combine two or more data window views there is no keyword required. The <emphasis>retain-intersection</emphasis> keyword is the default and the <emphasis>retain-union</emphasis> keyword may instead be provided for a stream.
		   </para>

			<para>
				The concept of union and intersection come from Set mathematics. In the language of Set mathematics, two sets A and B can be "added" together: The intersection of A and B is the set of all things which are members of both A and B, i.e. the members two sets have "in common". The union of A and B is the set of all things which are members of either A or B. 
			</para>

		   <para>
			   Use the <emphasis>retain-intersection</emphasis> (the default) keyword to retain an intersection of all events as defined by two or more data windows. All events removed from any of the intersected data windows are entered into the remove stream. This is the default behavior if neither retain keyword is specified.
		   </para>

		   <para>
			   Use the <emphasis>retain-union</emphasis> keyword to retain a union of all events as defined by two or more data windows. Only events removed from all data windows are entered into the remove stream.
		   </para>

		   <para>
				As you can see, it is the remove stream that the combined multiple data windows provide which differs when retaining an intersection and retaining a union, the insert stream is the same to all data windows and their staggered views.
		   </para>

		   <para>
			   The next example statement totals the price of OrderEvent events in a union of the last 30 seconds and unique by product name:
		   </para>
            <programlisting><![CDATA[select sum(price) from OrderEvent.win:time(30 sec).std:unique(productName) retain-union]]></programlisting>		   
		   <para>
			   In the above statement, all OrderEvent events that are either less then 30 seconds old or that are the last event for the product name are considered.
		   </para>		   

		   <para>
			   Here is an example statement totals the price of OrderEvent events in an intersection of the last 30 seconds and unique by product name:
		   </para>
            <programlisting><![CDATA[select sum(price) from OrderEvent.win:time(30 sec).std:unique(productName) retain-intersection]]></programlisting>		   
		   <para>
			   In the above statement, only those OrderEvent events that are both less then 30 seconds old and are the last event for the product name are considered.
		   </para>		   

		   <para>
			   For advanced users and for backward compatibility, it is possible to configure Esper to allow multiple data window views without either of the <literal>retain</literal> keywords, as described in <xref linkend="config-engine-viewresources-multipolicy"/>.
		   </para>
		</sect2>
		
        <sect2 id="epl-from-clause-stream-name" >
           <title>Using the Stream Name</title>
			<para>
				Your <literal>from</literal> clause may assign a name to each stream. This assigned stream name can serve any of the following purposes.
			</para>
						
			<para>
				First, the stream name can be used to disambiguate property names. The <literal>stream_name.property_name</literal> syntax uniquely identifies which property to select if property names overlap between streams. Here is an example:
			</para>
            <programlisting><![CDATA[select prod.productId, ord.productId from ProductEvent as prod, OrderEvent as ord]]></programlisting>

			<para>
				Second, the stream name can be used with a wildcard (*) character to select events in a join, or assign new names to the streams in a join:
			</para>
            <programlisting><![CDATA[// Select ProductEvent only
select prod.* from ProductEvent as prod, OrderEvent

// Assign column names 'product' and 'order' to each event
select prod.* as product, ord.* as order from ProductEvent as prod, OrderEvent as ord]]></programlisting>

			<para>
				Further, the stream name by itself can occur in any expression: The engine passes the event itself to that expression. For example, the engine passes the ProductEvent and the OrderEvent to the user-defined function 'checkOrder':
			</para>
            <programlisting><![CDATA[select prod.productId, MyFunc.checkOrder(prod, ord) 
from ProductEvent as prod, OrderEvent as ord]]></programlisting>

			<para>
				Last, you may invoke an instance method on each event of a stream, and pass parameters to the instance method as well. Instance method calls are allowed anywhere in an expression.
			</para>
				
			<para>
				The next statement demonstrates this capability by invoking a method 'computeTotal' on OrderEvent events and a method 'getMultiplier' on ProductEvent events:
			</para>
            <programlisting><![CDATA[select ord.computeTotal(prod.getMultiplier()) from ProductEvent as prod, OrderEvent as ord]]></programlisting>

		</sect2>

    </sect1>
    
    <sect1 id="epl-where-clause">
        <title>Specifying Search Conditions: the <emphasis>Where</emphasis> Clause</title>

		<indexterm><primary>where clause</primary></indexterm>
		<indexterm><primary>EPL</primary><secondary>where clause</secondary></indexterm>
		<para>
			The <literal>where</literal> clause is an optional clause in EPL statements. Via the <literal>where</literal> clause event streams can be joined and events can be filtered. 
		</para>
		
		<para>
			Comparison operators <literal>=, &lt; , &gt; , &gt;=, &lt;=, !=, &lt;&gt;, is null, is not null</literal> and logical combinations via <literal>and</literal> and <literal>or</literal> are supported in the <literal>where</literal> clause. The <literal>where</literal> clause can also introduce join conditions as outlined in <xref linkend="epl-join"/>. <literal>where</literal> clauses can also contain expressions. Some examples are listed below.
		</para>
		<programlisting>...where fraud.severity = 5 and amount > 500
...where (orderItem.orderId is null) or (orderItem.class != 10)		 
...where (orderItem.orderId = null) or (orderItem.class &lt;&gt; 10)		 
...where itemCount / packageCount > 10		 </programlisting>

    </sect1>

    <sect1 id="epl-grouping-aggregating">
        <title>Aggregates and grouping: the <emphasis>Group-by</emphasis> Clause and the <emphasis>Having</emphasis> Clause</title>

        <sect2 id="epl-grouping-aggregate-functions" >
				<title>Using aggregate functions</title>
			
				<para>
					The aggregate functions are <literal>sum, avg, count, max, min, median, stddev, avedev</literal>. You can use aggregate functions to
					calculate and summarize data from event properties.
					For example, to find out the total price for all stock tick events in the last 30 seconds, type:
				</para>
			    <programlisting>select sum(price) from StockTickEvent.win:time(30 sec)</programlisting>

				<para>
					Here is the syntax for aggregate functions: 
				</para>
				<synopsis><emphasis>aggregate_function</emphasis>( [all | distinct] <emphasis>expression</emphasis>)</synopsis>

				<para>
					You can apply aggregate functions to all events in an event stream window or other view, or to one or more groups of events. From each set of events to which 
					an aggregate function is applied, Esper generates a single value. 
				</para>

				<para>
					<literal>Expression</literal> is usually an event property name. However it can also be a constant, function, or any combination of event property names, constants, 
					and functions connected by arithmetic operators.
				</para>

				<para>
					For example, to find out the average price for all stock tick events in the last 30 seconds if the price was doubled:
				</para>
			    <programlisting>select avg(price * 2) from StockTickEvent.win:time(30 seconds)</programlisting>

				<para>
					You can use the optional keyword <literal>distinct</literal> with all aggregate functions to eliminate duplicate values before the aggregate function is applied. The optional 
					keyword <literal>all</literal> which performs the operation on all events is the default. 
				</para>
			
				<para>
					You can use aggregation functions in a <literal>select</literal> clause and in a <literal>having</literal> clause. You cannot use aggregate functions in a <literal>where</literal> clause, but you can use the <literal>where</literal> clause to restrict the events to which the aggregate is applied. The next query computes the average and sum of the price of stock tick events for the symbol IBM only, for the last 10 stock tick events regardless of their symbol.
				</para>
			    <programlisting>select 'IBM stats' as title, avg(price) as avgPrice, sum(price) as sumPrice
from StockTickEvent.win:length(10)
where symbol='IBM'</programlisting>				
								
				<para>
					In the above example the length window of 10 elements is not affected by the <literal>where</literal> clause, i.e. all events enter and leave the length window regardless of their symbol. If we only care about the last 10 IBM events, we need to add filter criteria as below.
				</para>
			    <programlisting>select 'IBM stats' as title, avg(price) as avgPrice, sum(price) as sumPrice
from StockTickEvent(symbol='IBM').win:length(10)
where symbol='IBM'</programlisting>				

				<para>
					You can use aggregate functions with any type of event property or expression, with the following exceptions:
				</para>

				<orderedlist spacing="compact">
					<listitem>
						<para>
							You can use <literal>sum, avg, median, stddev, avedev</literal> with numeric event properties only	
						</para>
					</listitem>
				</orderedlist>

				<para>
					Esper ignores any null values returned by the event property or expression on which the aggregate function is operating, except for the <literal>count(*)</literal> function, which counts null values as well. All aggregate functions return null if the data set contains no events, or if all events in the data set contain only null values for the aggregated expression.
				</para>
		</sect2>

        <sect2 id="epl-grouping-group-by" >
				 <title>Organizing statement results into groups: the <emphasis>Group-by</emphasis> clause</title>

				<indexterm><primary>group by clause</primary></indexterm>
				<indexterm><primary>EPL</primary><secondary>group by clause</secondary></indexterm>

				<para>
					The <literal>group by</literal> clause is optional in all EPL statements. The <literal>group by</literal> clause divides the output of an EPL statement into groups. You can group by one or more event property names, or by the result of computed expressions. When used with aggregate functions, <literal>group by</literal> retrieves the calculations in each subgroup. You can use <literal>group by</literal> without aggregate functions, but generally that can produce confusing results.
				</para>
	
				<para>
					For example, the below statement returns the total price per symbol for all stock tick events in the last 30 seconds:
				</para>
				<programlisting>select symbol, sum(price) from StockTickEvent.win:time(30 sec) group by symbol</programlisting>
	
				<para>
					The syntax of the <literal>group by</literal> clause is:
				</para>
				<synopsis>group by <emphasis>arregate_free_expression</emphasis> [, <emphasis>arregate_free_expression</emphasis>] [, ...]</synopsis>
			
				<para>
					Esper places the following restrictions on expressions in the <literal>group by</literal> clause:
				</para>
	
				<orderedlist spacing="compact">
					<listitem>
						<para>
							Expressions in the <literal>group by</literal> cannot contain aggregate functions
						</para>
					</listitem>
					<listitem>
						<para>
							Event properties that are used within aggregate functions in the <literal>select</literal> clause cannot also be used in a <literal>group by</literal> expression
						</para>
					</listitem>
				</orderedlist>
				
				<para>
					You can list more then one expression in the <literal>group by</literal> clause to nest groups. Once the sets are established with <literal>group by</literal> the aggregation
					functions are applied. This statement posts the median volume for all stock tick events in the last 30 seconds per symbol and tick data feed. Esper posts one event for each group to statement listeners:
				</para>
				<programlisting>select symbol, tickDataFeed, median(volume) 
from StockTickEvent.win:time(30 sec) 
group by symbol, tickDataFeed</programlisting>
				
				<para>
					In the statement above the event properties in the <literal>select</literal> list (symbol, tickDataFeed) are also listed in the <literal>group by</literal> clause.
					The statement thus follows the SQL standard which prescribes that non-aggregated event properties in the <literal>select</literal> list must match the 
					<literal>group by</literal> columns.
				</para>

				<para>
					Esper also supports statements in which one or more event properties in the <literal>select</literal> list are not listed in the <literal>group by</literal> clause.
					The statement below demonstrates this case. It calculates the standard deviation for the last 30 seconds of stock ticks aggregating by symbol and posting for 
					each event the symbol, tickDataFeed and the standard deviation on price.
				</para>
				<programlisting>select symbol, tickDataFeed, stddev(price) from StockTickEvent.win:time(30 sec) group by symbol</programlisting>
				
				<para>
					The above example still aggregates the <literal>price</literal> event property based on the <literal>symbol</literal>, but produces one event per incoming event, not one 
					event per group.
				</para>

				<para>
					Additionally, Esper supports statements in which one or more event properties in the <literal>group by</literal> clause are not listed in the <literal>select</literal> list.
					This is an example that calculates the mean deviation per <literal>symbol</literal> and <literal>tickDataFeed</literal> and posts one event per group with <literal>symbol</literal> and mean deviation of price in the generated events. Since tickDataFeed is not in the posted results, this can potentially be confusing.
				</para>
				<programlisting>select symbol, avedev(price) 
from StockTickEvent.win:time(30 sec) 
group by symbol, tickDataFeed</programlisting>

				<para>
					Expressions are also allowed in the <literal>group by</literal> list:
				</para>
				<programlisting>select symbol * price, count(*) from StockTickEvent.win:time(30 sec) group by symbol * price</programlisting>
				
				<para>
					If the <literal>group by</literal> expression resulted in a null value, the null value becomes its own group. All null values are aggregated into the same group. If you are using the <literal>count(expression)</literal> aggregate function which does not count null values, the count returns zero if only null values are encountered.								
				</para>

				<para>
					You can use a <literal>where</literal> clause in a statement with <literal>group by</literal>. Events that do not satisfy the conditions in the <literal>where</literal> clause are eliminated before any grouping is done. For example, the statement below posts the number of stock ticks in the last 30 seconds with a volume larger then 100, posting one event per group (symbol).
				</para>
				<programlisting>select symbol, count(*) from StockTickEvent.win:time(30 sec) where volume &gt; 100 group by symbol</programlisting>
		</sect2>

        <sect2 id="epl-grouping-having" >
			 <title>Selecting groups of events: the <emphasis>Having</emphasis> clause</title>

				<indexterm><primary>having clause</primary></indexterm>
				<indexterm><primary>EPL</primary><secondary>having clause</secondary></indexterm>
				<para>
					Use the <literal>having</literal> clause to pass or reject events defined by the <literal>group-by</literal> clause. The <literal>having</literal> clause sets conditions for the <literal>group by</literal> clause in the same way <literal>where</literal> sets conditions for the <literal>select</literal> clause, except <literal>where</literal> cannot include aggregate functions, while <literal>having</literal> often does.
				</para>
			
				<para>
					This statement is an example of a <literal>having</literal> clause with an aggregate function. It posts the total price per symbol for the last 30 seconds of stock tick events for only those symbols in which the total price exceeds 1000. The <literal>having</literal> clause eliminates all symbols where the total price is equal or less then 1000.
				</para>
				<programlisting>select symbol, sum(price) 
from StockTickEvent.win:time(30 sec) 
group by symbol 
having sum(price) &gt; 1000</programlisting>

				<para>
					To include more then one condition in the <literal>having</literal> clause combine the conditions with <literal>and</literal>, <literal>or</literal> or <literal>not</literal>.
					This is shown in the statement below which selects only groups with a total price greater then 1000 and an average volume less then 500.
				</para>
				<programlisting>select symbol, sum(price), avg(volume)
from StockTickEvent.win:time(30 sec) 
group by symbol 
having sum(price) &gt; 1000 and avg(volume) &lt; 500</programlisting>			

				<para>
					Esper places the following restrictions on expressions in the <literal>having</literal> clause:
				</para>
	
				<orderedlist spacing="compact">
					<listitem>
						<para>
							Any expressions that contain aggregate functions must also occur in the <literal>select</literal> clause
						</para>
					</listitem>
				</orderedlist>

				<para>
					A statement with the <literal>having</literal> clause should also have a <literal>group by</literal> clause. If you omit <literal>group-by</literal>, all the events not excluded
					by the <literal>where</literal> clause return as a single group. In that case <literal>having</literal> acts like a <literal>where</literal> except that <literal>having</literal> can have aggregate functions. 
				</para>
				
				<para>
					The <literal>having</literal> clause can also be used without <literal>group by</literal> clause as the below example shows. The example below posts events where the price is less then the current running average price of all stock tick events in the last 30 seconds.
				</para>
				<programlisting>select symbol, price, avg(price) 
from StockTickEvent.win:time(30 sec) 
having price &lt; avg(price)</programlisting>

		</sect2>

        <sect2 id="epl-filter-where-grouping-having-interactions" >
			 <title>How the stream filter, <emphasis>Where</emphasis>, <emphasis>Group By</emphasis> and <emphasis>Having</emphasis> clauses interact</title>
				<para>
					When you include filters, the <literal>where</literal> condition, the <literal>group by</literal> clause and the <literal>having</literal> condition in an EPL statement
					the sequence in which each clause affects events determines the final result:
				</para>

				<orderedlist spacing="compact">
					<listitem>
						<para>
							The event stream's filter condition, if present, dictates which events enter a window (if one is used). The filter discards any events not meeting filter criteria.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>where</literal> clause excludes events that do not meet its search condition.
						</para>
					</listitem>
					<listitem>
						<para>
							Aggregate functions in the select list calculate summary values for each group.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>having</literal> clause excludes events from the final results that do not meet its search condition.
						</para>
					</listitem>
				</orderedlist>

				<para>
					The following query illustrates the use of filter, <literal>where</literal>, <literal>group by</literal> and <literal>having</literal> clauses in one statement with 
					a <literal>select</literal> clause containing an aggregate function.
				</para>
				
				<programlisting>select tickDataFeed, stddev(price)
from StockTickEvent(symbol='IBM').win:length(10) 
where volume > 1000
group by tickDataFeed 
having stddev(price) &gt; 0.8</programlisting>

				<para>
					Esper filters events using the filter criteria for the event stream <literal>StockTickEvent</literal>. In the example above only events with symbol IBM enter the length window over the last 10 events, all other events are simply discarded. The <literal>where</literal> clause removes any events posted by the length window (events entering the window and event leaving the window) that do not match the condition of volume greater then 1000. Remaining events are applied to the <literal>stddev</literal> standard deviation aggregate function for each tick data feed as specified in the <literal>group by</literal> clause. Each <literal>tickDataFeed</literal> value generates one event. Esper applies the <literal>having</literal> clause and only lets events pass for <literal>tickDataFeed</literal> groups with a standard deviation of price greater then 0.8.
				</para>

		</sect2>

        <sect2 id="epl-group-by-versus-view" >
			 <title>Comparing the <emphasis>Group By</emphasis> clause and the <emphasis>std:groupby</emphasis> view</title>

			<para>
				The <emphasis>group by</emphasis> clause as well as the built-in <emphasis>std:groupby</emphasis> view are similar in their ability to group events. This section explains the key differences in their behavior and use.
			</para>
				
			<para>
				The <emphasis>group by</emphasis> clause works together with aggregation functions in your statement to produce an aggregation result per group. In greater detail, this means that when a new event arrives, the engine applies the expressions in the <emphasis>group by</emphasis> clause to determine a grouping key. If the engine has not encountered that grouping key before (a new group), the engine creates a set of new aggregation results for that grouping key and performs the aggregation changing that new set of aggregation results. If the grouping key points to an existing set of prior aggregation results (an existing group), the engine performs the aggregation changing the prior set of aggregation results for that group.
			</para>

			<para>
				The <emphasis>std:groupby</emphasis> view is a built-in view that also groups events. The view is described in greater detail in <xref linkend="view-std-groupby"/>. Its primary use is to create a separate data window per group, or more generally to create separate instances of all its sub-views for each grouping key encountered.
			</para>

			<para>
				The next example shows two queries that produce equivalent results. The query using the <emphasis>group by</emphasis> clause is generally preferable as is easier to read. The second form introduces the <literal>stat:uni</literal> view which computes univariate statistics for a given property:
			</para>

			<programlisting>select symbol, avg(price) from StockTickEvent group by symbol
// ... is equivalent to ...
select symbol, average from StockTickEvent.std:groupby(symbol).stat:uni(price)</programlisting>

			<para>
				The next example shows two queries that are NOT equivalent as the length window is ungrouped in the first query, and grouped in the second query:
			</para>

			<programlisting>select symbol, sum(price) from StockTickEvent.win:length(10) group by symbol
// ... NOT equivalent to ...
select symbol, sum(price) from StockTickEvent.std:groupby(symbol).win:length(10)</programlisting>

			<para>
				The key difference between the two statements is that in the first statement the length window is ungrouped and applies to all events regardless of group. While in the second query each group gets its own instance of a length window. For example, in the second query events arriving for symbol "ABC" get a length window of 10 events, and events arriving for symbol "DEF" get their own length window of 10 events. 
			</para>

		</sect2>

    </sect1>

    <sect1 id="epl-output-rate">
        <title>Stabilizing and Controlling Output: the <emphasis>Output</emphasis> Clause</title>

		<indexterm><primary>output control and stabilizing clause</primary></indexterm>
		<indexterm><primary>EPL</primary><secondary>output control and stabilizing</secondary></indexterm>

        <sect2 id="epl-output-options" >
				<title>Output Clause Options</title>
			
				<para>
					The <literal>output</literal> clause is optional in Esper and is used to control or stabilize the rate at which events are output. The EPL language provides for several different ways to control output rate.
				</para>

				<para>
					Here is the syntax for the <literal>output</literal> clause that specifies a rate in time interval or number of events:
				</para>
				<synopsis>output [all | first | last | snapshot] every <emphasis>output_rate</emphasis> [minutes | seconds | events]</synopsis>

				<para>
					An alternate syntax specifies the time period between output as outlined in <xref linkend="epl-syntax-time-periods"/> :
				</para>
				<synopsis>output [all | first | last | snapshot] every <emphasis>time_period</emphasis></synopsis>

				<para>
					A crontab-like schedule can also be specified. The schedule parameters follow the pattern observer parameters and are further described in <xref linkend="pattern-timer-at"/> :
				</para>
				<synopsis>output [all | first | last | snapshot] at 
  (<emphasis>minutes, hours, days of month, months, days of week [, seconds]</emphasis>)</synopsis>

				<para>
					Last, output can be controlled by an expression that may contain variables, user-defined functions and information about the number of collected events. Output that is controlled by an expression is discussed in detail below.
				</para>

				<para>
					For example, the following statement outputs, every 60 seconds, the total price for all orders in the 30-minute time window:		
				</para>
			    <programlisting>select sum(price) from OrderEvent.win:time(30 min) output snapshot every 60 seconds</programlisting>

				<para>
					The <literal>all</literal> keyword is the default and specifies that all events in a batch should be output, each incoming row in the batch producing an output row.
					Note that for statements that group via the <literal>group by</literal> clause, the <literal>all</literal> keyword provides special behavior as below.
				</para>

				<para>
					The <literal>first</literal> keyword specifies that only the first event in an output batch is to be output.
					Using the <literal>first</literal> keyword instructs the engine to output the first matching event as soon as it arrives, and then ignores matching events for the time interval or number of events specified. 
					After the time interval elapsed, or the number of matching events has been reached, the next first matching event is output again and the following interval the engine again ignores matching events.
				</para>

				<para>
					The <literal>last</literal> keyword specifies to only output the last event at the end of the given time interval or after the given number of matching events
					have been accumulated. Again, for statements that group via the <literal>group by</literal> clause the <literal>last</literal> keyword provides special behavior as below.
				</para>

				<para>
					The <literal>snapshot</literal> keyword indicates that the engine output current computation results considering all events as per views specified and/or current aggregation results. While the other keywords control how a batch of events between output intervals is being considered, the <literal>snapshot</literal> keyword outputs all current state of a statement independent of the last batch. It's output is equivalent to the <literal>iterator</literal> method provided by a statement.
				</para>

				<para>
					The <emphasis>output_rate</emphasis> is the frequency at which the engine outputs events. It can be specified in terms of time or number of events. The value can be a number to denote a fixed output rate, or the name of a variable whose value is the output rate. By means of a variable the output rate can be controlled externally and changed dynamically at runtime. 
				</para>

				<para>
					Please consult the <xref linkend="appendix_outputspec"/> for detailed information on insert and remove stream output for the various <literal>output</literal> clause keywords.
				</para>
				
				<para>
					The time interval can also be specified in terms of minutes; the following statement is identical to the first one.
				</para>
			    <programlisting>select * from StockTickEvent.win:length(5) output every 1.5 minutes</programlisting>

				<para>
					A second way that output can be stabilized is by batching events until a certain number of events have been collected. The next statement only outputs when either 5 (or more) new or 5 (or more) old events have been batched.
				</para>				
			    <programlisting>select * from StockTickEvent.win:time(30 sec) output every 5 events</programlisting>
			    
				<para>
					Additionally, event output can be further modified by the optional <literal>last</literal> keyword, which causes output of only the last event to arrive into an output batch.
				</para>
			    <programlisting>select * from StockTickEvent.win:time(30 sec) output last every 5 events</programlisting>

				<para>
					Using the <literal>first</literal> keyword you can be notified at the start of the interval. The allows to watch for situations such as a rate falling below a threshold
					and only be informed every now and again after the specified output interval, but be informed the moment it first happens. 
				</para>
			    <programlisting>select * from TickRate.win:time(30 seconds) where rate&lt;100 output first every 60 seconds</programlisting>

				<para>
					A sample statement using the Unix "crontab"-command schedule is shown next. See <xref linkend="pattern-timer-at"/> for details on schedule syntax. Here, output occurs every 15 minutes from 8am to 5:45pm (hours 8 to 17 at 0, 15, 30 and 45 minutes past the hour):
				</para>
				<synopsis>select symbol, sum(price) from StockTickEvent group by symbol output at (*/15, 8:17, *, *, *)</synopsis>

				<sect3 id="epl-output-expression" >
					<title>Controlling Output Using an Expression</title>

					<indexterm><primary>output when</primary></indexterm>
					<para>
						Output can also be controlled by an expression that may check variable values, use user-defined functions and query built-in properties that provide additional information. The synopsis is as follows:
					</para>
					<synopsis>output [all | first | last | snapshot] when <emphasis>trigger_expression</emphasis> 
    [then set <emphasis>variable_name</emphasis> = <emphasis>assign_expression</emphasis> [, <emphasis>variable_name</emphasis> = <emphasis>assign_expression</emphasis> [,...]]]</synopsis>

					<para>
						The <literal>when</literal> keyword must be followed by a trigger expression returning a boolean value of true or false, indicating whether to output.
						Use the optional <literal>then</literal> keyword to change variable values after the trigger expression evaluates to true. An assignment expression assigns a new value to variable(s).
					</para>

					<para>
						Lets consider an example. The next statement assumes that your application has defined a variable by name OutputTriggerVar of boolean type. The statement outputs rows only when the OutputTriggerVar variable has a boolean value of true:
					</para>
					<synopsis>select sum(price) from StockTickEvent output when OutputTriggerVar = true</synopsis>

					<para>
						The engine evaluates the trigger expression when streams and data views post one or more insert or remove stream events after considering the <literal>where</literal> clause, if present. It also evaluates the trigger expression when any of the variables used in the trigger expression, if any, changes value. Thus output occurs as follows:
					</para>

					<orderedlist spacing="compact">
						<listitem>
							<para>
								When there are insert or remove stream events and the <literal>when</literal> trigger expression evaluates to true, the engine outputs the resulting rows.
							</para>
						</listitem>
						<listitem>
							<para>
								When any of the variables in the <literal>when</literal> trigger expression changes value, the engine evaluates the expression and outputs results. Result output occurs within the minimum time interval of timer resolution (100 milliseconds).
							</para>
						</listitem>
					</orderedlist>

					<para>
						By adding a <literal>then</literal> part to the EPL, we can reset any variables after the trigger expression evaluated to true:
					</para>
					<synopsis>select sum(price) from StockTickEvent 
  output when OutputTriggerVar = true  
  then set OutputTriggerVar = false</synopsis>

					<para>
						Expressions in the <literal>when</literal> and <literal>then</literal> may, for example, use variables, user defined functions or any of the built-in named properties that are described in the below list.
					</para>
					
					<para>
						The following built-in properties are available for use:
					</para>
					<table frame="topbot" id="epl-output-expression-builtin" revision="2">
						<title>Built-In Properties for Use with Output When</title>
						<tgroup cols="2">
							<colspec colwidth="1*"/>
							<colspec colwidth="2.5*"/>
							<thead>
								<row>
									<entry>Built-In Property Name</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry><literal>last_output_timestamp</literal></entry>
									<entry>Timestamp when the last output occurred for the statement; Initially set to time of statement creation</entry>
								</row>
								<row>
									<entry><literal>count_insert</literal></entry>
									<entry>Number of insert stream events</entry>
								</row>
								<row>
									<entry><literal>count_remove</literal></entry>
									<entry>Number of remove stream events</entry>
								</row>
							</tbody>
						</tgroup>
					</table>

					<para>
						The values provided by <literal>count_insert</literal> and <literal>count_remove</literal> are non-continues: The number returned for these properties may 'jump' up rather then count up by 1.
						The counts reset to zero upon output.
					</para>        
					
					<para>
						The following restrictions apply to expressions used in the output rate clause:
					</para>        
					<itemizedlist spacing="compact">
						<listitem>
							<para>
								Event property names cannot be used in the output clause.
							</para>
						</listitem>
						<listitem>
							<para>
								Aggregation functions cannot be used in the output clause.
							</para>
						</listitem>
						<listitem>
							<para>
								The <literal>prev</literal> previous event function and the <literal>prior</literal> prior event function cannot be used in the output clause.
							</para>
						</listitem>
					</itemizedlist>
				</sect3>

		</sect2>

        <sect2 id="epl-output-groupby" >
				<title>Aggregation, Group By, Having and Output clause interaction</title>
			
				<para>
					Remove stream events can also useful in conjunction with aggregation and the <literal>output</literal> clause: When the engine posts remove stream events for fully-aggregated queries, it presents the aggregation state before the expiring event leaves the data window. Your application can thus easily obtain a delta between the new aggregation value and the prior aggregation value.
				</para>
				
				<para>
					The engine evaluates the having-clause at the granularity of the data posted by views. That is, if you utilize a time window and output every 10 events, the <literal>having</literal> clause applies to each individual event or events entering and leaving the time window (and not once per batch of 10 events).
				</para>

				<para>
					The <literal>output</literal> clause interacts in two ways with the <literal>group by</literal> and <literal>having</literal> clauses. First, in the <literal>output every n events </literal>case, the number <literal>n</literal> refers to the number of events arriving into the <literal>group by clause</literal>. That is, if the <literal>group by</literal> clause outputs only 1 event per group, or if the arriving events don't satisfy the <literal>having</literal> clause, then the actual number of events output by the statement could be fewer than <literal>n</literal>.
				</para>
				
				<para>
					Second, the <literal>last</literal> and <literal>all</literal> keywords have special meanings when used in a statement with aggregate functions and the <literal>group by</literal> clause:
				</para>
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							When no keyword is specified, the engine produces an output row for each row in the batch.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>all</literal> keyword (the default) specifies that the most recent data for <emphasis>all</emphasis> groups seen so far should be output, whether or not these groups' aggregate values have just been updated
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>last</literal> keyword specifies that only groups whose aggregate values have been updated with the most recent batch of events should be output.
						</para>
					</listitem>
				</itemizedlist>

				<para>
					Please consult the <xref linkend="appendix_outputspec"/> for detailed information on insert and remove stream output for aggregation and group-by.
				</para>

				<para>
					By adding an output rate limiting clause to a statement that contains a <emphasis>group by</emphasis> clause we can control output of groups to obtain one row for each group, generating an event per group at the given output frequency:
				</para>
				<programlisting>select symbol, sum(price) from StockTickEvent group by symbol output all every 5 seconds</programlisting>

		</sect2>

        <sect2 id="epl-output-runtime" >
				<title>Runtime Considerations</title>
			
				<para>
					Output rate limiting provides output events to your application in regular intervals. Between intervals, the engine uses a buffer to hold events until the output condition is reached. If your application
					has high-volume streams, you may need to be mindful of the memory needs for output rates.
				</para>
				
				<para>
					The <literal>output</literal> clause with the <literal>snapshot</literal> keyword does not require a buffer, all other output keywords do consume memory until the output condition is reached.
				</para>

		</sect2>

    </sect1>

    <sect1 id="epl-order-by">
        <title>Sorting Output: the <emphasis>Order By</emphasis> Clause</title>

		<indexterm><primary>ordering output</primary></indexterm>
		<indexterm><primary>output ordering</primary></indexterm>
		<indexterm><primary>order by clause</primary></indexterm>
		<indexterm><primary>EPL</primary><secondary>order by clause</secondary></indexterm>

		<para>
			The <literal>order by</literal> clause is optional. It is used for ordering output events by their properties, or by expressions involving those properties. .				
		</para>

		<para>
			For example, the following statement outputs batches of 5 or more stock tick events that are sorted first by price ascending and then by volume ascending:
		</para>
		<programlisting>select symbol from StockTickEvent.win:time(60 sec) 
output every 5 events 
order by price, volume</programlisting>

		<para>
			Here is the syntax for the <literal>order by</literal> clause:				
		</para>
		<synopsis>order by <emphasis>expression</emphasis> [asc | desc] [, <emphasis>expression</emphasis> [asc | desc]] [, ...]</synopsis>

		<para>
			If the <literal>order by</literal> clause is absent then the engine still makes certain guarantees about the ordering of output: 
		</para>
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					If the statement is not a join, does not group via <literal>group by</literal> clause and does not declare grouped data windows via <literal>std:groupby</literal> view, the order in which events are delivered to listeners and through the <literal>iterator</literal> pull API is the order of event arrival.
				</para>
			</listitem>
			<listitem>
				<para>
					If the statement is a join or outer join, or groups, then the order in which events are delivered to listeners and through the <literal>iterator</literal> pull API is not well-defined. Use the <literal>order by</literal> clause if your application requires events to be delivered in a well-defined order.
				</para>
			</listitem>
		</itemizedlist>

		<para>
			Esper places the following restrictions on the expressions in the <literal>order by</literal> clause:
		</para>
		
		<orderedlist spacing="compact">
			<listitem>
				<para>
					All aggregate functions that appear in the <literal>order by</literal> clause must also appear in the <literal>select</literal> expression.
				</para>
			</listitem>
		</orderedlist>
		
		<para>
			Otherwise, any kind of expression that can appear in the <literal>select</literal> clause, 
			as well as any name defined in the <literal>select</literal> clause, is also valid in the order by clause.
		</para>		
		
		<para>
			By default all sort operations on string values are performed via the <literal>compare</literal> method and are thus not locale dependent. To account for differences in language or locale, see <xref linkend="config-engine-language"/> to change this setting.
		</para>
	</sect1>

    <sect1 id="epl-limit">
        <title>Limiting Row Count: the <emphasis>Limit</emphasis> Clause</title>

		<indexterm><primary>limiting output row count</primary></indexterm>
		<indexterm><primary>output row count</primary></indexterm>
		<indexterm><primary>limit clause</primary></indexterm>
		<indexterm><primary>EPL</primary><secondary>limit clause</secondary></indexterm>

		<para>
			The <literal>limit</literal> clause is typically used together with the <literal>order by</literal> and <literal>output</literal> clause to limit your query results to those that fall within a specified range. You can use it to receive the first given number of result rows, or to receive a range of result rows. 
		</para>

		<para>
			There are two syntaxes for the <literal>limit</literal> clause, each can be parameterized by integer constants or by variable names. The first syntax is shown below:				
		</para>
		<synopsis>limit <emphasis>row_count</emphasis> [offset <emphasis>offset_count</emphasis>]</synopsis>

		<para>
			The required <emphasis>row_count</emphasis> parameter specifies the number of rows to output. The <emphasis>row_count</emphasis> can be an integer constant 
			and can also be the name of the integer-type variable to evaluate at runtime.
		</para>

		<para>
			The optional <emphasis>offset_count</emphasis> parameter specifies the number of rows that should be skipped (offset) at the beginning of the result set. A variable can also be used for this parameter.
		</para>

		<para>
			The next sample EPL query outputs the top 10 counts per property 'uri' every 1 minute.
		</para>
		<programlisting>select uri, count(*) from WebEvent 
group by uri 
output snapshot every 1 minute
order by count(*) desc 
limit 10</programlisting>

		<para>
			The next statement demonstrates the use of the <literal>offset</literal> keyword. It outputs ranks 3 to 10 per property 'uri' every 1 minute:
		</para>
		<programlisting>select uri, count(*) from WebEvent 
group by uri 
output snapshot every 1 minute
order by count(*) desc 
limit 8 offset 2</programlisting>

		<para>
			The second syntax for the <literal>limit</literal> clause is for SQL standard compatibility and specifies the offset first, followed by the row count:
		</para>
		<synopsis>limit <emphasis>offset_count</emphasis>[, <emphasis>row_count</emphasis>]</synopsis>

		<para>
			The following are equivalent:
		</para>
		<programlisting>limit 8 offset 2
// ...equivalent to
limit 2, 8</programlisting>

		<para>
			A negative value for <emphasis>row_count</emphasis> returns an unlimited number or rows, and a zero value returns no rows. If variables are used, then the current variable value at the time of output dictates the row count and offset. A variable returning a null value for <emphasis>row_count</emphasis> also returns an unlimited number or rows. 
		</para>
		
		<para>
			A negative value for offset is not allowed. If your variable returns a negative or null value for offset then the value is assumed to be zero (i.e. no offset).
		</para>

		<para>
			The <literal>iterator</literal> pull API also honors the <literal>limit</literal> clause, if present.
		</para>
		
	</sect1>

    <sect1 id="epl-insert-into">
        <title>Merging Streams and Continuous Insertion: the <emphasis>Insert Into</emphasis> Clause</title>

		<indexterm><primary>insert into clause</primary></indexterm>
		<indexterm><primary>EPL</primary><secondary>insert into clause</secondary></indexterm>

		<para>
			The <literal>insert into</literal> clause is optional in Esper. The clause can be specified to make the results of a statement available as an event stream for use
			in further statements, or to insert events into a named window. The clause can also be used to merge multiple event streams to form a single stream of events.
		</para>

		<para>
			The syntax for the <literal>insert into</literal> clause is as follows:
		</para>

		<synopsis>insert [istream | rstream] into <emphasis>event_stream_name</emphasis>  [ (<emphasis>property_name</emphasis> [, property_name] ) ]</synopsis>

		<para>
			The <literal>istream</literal> (default) and <literal>rstream</literal> keywords are optional. If no keyword or the <literal>istream</literal> keyword is specified, the engine supplies the insert stream events generated by the statement. The insert stream consists of the events entering the respective window(s) or stream(s). If the <literal>rstream</literal> keyword is specified, the engine supplies the remove stream events generated by the statement. The remove stream consists of the events leaving the respective window(s). 
		</para>

		<para>
			The <literal>event_stream_name</literal> is an identifier that names the event stream (and also implicitly names the types of events in the stream) generated by the engine. The identifier can be used in further statements to filter and
			process events of that event stream. The <literal>insert into</literal> clause can consist of just an event stream name, or an event stream name and one or more property names.
		</para>

		<para>
			The engine also allows listeners to be attached to a statement that contain an <literal>insert into</literal> clause. Listeners receive all events posted to the event stream.
		</para>

		<para>
			To merge event streams, simply use the same <literal>event_stream_name</literal> identifier in all EPL statements that merge their result event streams. Make sure to use the
			same number and names of event properties and event property types match up.
		</para>

		<para>
			Esper places the following restrictions on the <literal>insert into</literal> clause:
		</para>
		
		<orderedlist spacing="compact">
			<listitem>
				<para>
					The number of elements in the <literal>select</literal> clause must match the number of elements in the <literal>insert into</literal> clause if the clause specifies a list of event property names
				</para>
			</listitem>
			<listitem>
				<para>
					If the event stream name has already been defined by a prior statement or configuration, and the event property names and/or event types do not match, an exception is thrown at statement creation time.
				</para>
			</listitem>
		</orderedlist>

		<para>
			The following sample inserts into an event stream by name CombinedEvent:
		</para>
		<programlisting>insert into CombinedEvent
select A.customerId as custId, A.timestamp - B.timestamp as latency
  from EventA.win:time(30 min) A, EventB.win:time(30 min) B
 where A.txnId = B.txnId</programlisting>

		<para>
			Each event in the <literal>CombinedEvent</literal> event stream has two event properties named "custId" and "latency". The events generated by the above statement can be used in further statements, such as shown in the next statement:
		</para>

		<programlisting>select custId, sum(latency)
  from CombinedEvent.win:time(30 min)
 group by custId</programlisting>

		<para>
			The example statement below shows the alternative form of the <literal>insert into</literal> clause that explicitly defines the property names to use.
		</para>

		<programlisting>insert into CombinedEvent (custId, latency)
select A.customerId, A.timestamp - B.timestamp 
...</programlisting>

		<para>
			The <literal>rstream</literal> keyword can be useful to indicate to the engine to generate only remove stream events. This can be useful if we want to trigger 
			actions when events leave a window rather then when events enter a window. The statement below generates <literal>CombinedEvent</literal> events when
			EventA and EventB leave the window after 30 minutes.
		</para>

		<programlisting>insert rstream into CombinedEvent
select A.customerId as custId, A.timestamp - B.timestamp as latency
  from EventA.win:time(30 min) A, EventB.win:time(30 min) B
 where A.txnId = B.txnId</programlisting>

		<para>
			The <literal>insert into</literal> clause can be used in connection with patterns to provide pattern results to further statements for analysis:
		</para>

		<programlisting>insert into ReUpEvent
select linkUp.ip as ip 
from pattern [every linkDown=LinkDownEvent -> linkUp=LinkUpEvent(ip=linkDown.ip)]</programlisting>

		<sect2 id="insert-into-property-transpose">
			<title>Transposing a Property To a Stream</title>			
			<para>
				Sometimes your events may carry properties that are themselves event objects. Therefore EPL offers a special syntax to insert the value of a property itself as an event into a stream:
			</para>
			<synopsis>insert into <emphasis>stream_name</emphasis> select <emphasis>property_name</emphasis>.* from ...</synopsis>

			<para>
				This feature is only supported for JavaBean events and is not supported for <literal>Map</literal> or <literal>XML</literal> events. Nested property names are also not supported.
			</para>

			<para>
				In this example, the class <literal>Summary</literal> with properties <literal>bid</literal> and <literal>ask</literal> that are of type <literal>Quote</literal> is:
			</para>
			<programlisting><![CDATA[public class Summary {
  private Quote bid;
  private Quote ask;
  ...]]></programlisting>			
  
			<para>
				The statement to populate a stream of <literal>Quote</literal> events is thus:
			</para>
			<programlisting><![CDATA[insert into MyBidStream select bid.* from Summary]]></programlisting>			
		</sect2>

		<sect2 id="insert-into-merging-columns">
			<title>Merging Streams By Event Type</title>			
			<para>
				The <literal>insert into</literal> clause allows to merge multiple event streams into a event single stream. 
				The clause names an event stream to insert into by specifing an <emphasis>event_stream_name</emphasis>. The first statement that inserts into the named stream defines the stream's event types. Further statements that
				insert into the same event stream must match the type of events inserted into the stream as declared by the first statement.
			</para>

			<para>
			    One approach to merging event streams specifies individual colum names either in the <literal>select</literal> clause or in the <literal>insert into</literal> clause of the statement. This approach has been shown in earlier examples.
			</para>
			
			<para>
			    Another approach to merging event streams specifies the wildcard (*) in the <literal>select</literal> clause (or the stream wildcard) to select the underlying event. The events in the event stream must then 
			    have the same event type as generated by the <literal>from</literal> clause.
			</para>
			
			<para>
			    Assume a statement creates an event stream named MergedStream by selecting OrderEvent events:
			</para>
			<programlisting>insert into MergedStream select * from OrderEvent</programlisting>

			<para>
			    A statement can use the stream wildcard selector to select only OrderEvent events in a join:
			</para>
			<programlisting>insert into MergedStream select ord.* from ItemScanEvent, OrderEvent as ord</programlisting>

			<para>
			    And a statement may also use an application-supplied user-defined function to convert events to OrderEvent instances:
			</para>
			<programlisting>insert into MergedStream select MyLib.convert(item) from ItemScanEvent as item</programlisting>			

			<para>
			    Esper specifically recognizes a conversion function: A conversion function must be the only selected column, and it must return either a Java object or <literal>java.util.Map</literal>.
			</para>
		</sect2>

		<sect2 id="insert-into-merging-types">
			<title>Merging Disparate Types of Events: Variant Streams</title>			
			<indexterm><primary>variant stream</primary></indexterm>
			<para>
				A <emphasis>variant stream</emphasis> is a predefined stream into which events of multiple disparate event types can be inserted. 
			</para>

			<para>
				A variant stream name may appear anywhere in a pattern or <literal>from</literal> clause. In a pattern, a filter against a variant stream matches any events of any of the event types inserted into the variant stream. 
				In a <literal>from</literal> clause including for named windows, views declared onto a variant stream may hold events of any of the event types inserted into the variant stream.
			</para>

			<para>
				A variant stream is thus useful in problems that require different types of event to be treated the same.
			</para>

			<para>
				Variant streams are predefined via runtime or initialization-time configuration as described in <xref linkend="config-variantstream"/>. Your application may predefine variant streams to carry events of a limited set of event types, or you may choose the variant stream to carry any and all types of events. This choice affects what event properties are available for consuming statements or patterns of the variant stream.
			</para>
				
			<para>
				Assume that an application predefined a variant stream named <literal>OrderStream</literal> to carry only <literal>ServiceOrder</literal> and <literal>ProductOrder</literal> events. An <literal>insert into</literal> clause inserts events into
				the variant stream:
			</para>
			<programlisting>insert into OrderStream select * from ServiceOrder
insert into OrderStream select * from ProductOrder</programlisting>			

			<para>
				Here is a sample statement that consumes the variant stream and outputs a total price per customer id for the last 30 seconds of <literal>ServiceOrder</literal> and <literal>ProductOrder</literal> events:
			</para>
			<programlisting>select customerId, sum(price) from OrderStream.win:time(30 sec) group by customerId</programlisting>			

			<para>
				If your application predefines the variant stream to hold specific type of events, as the sample above did, then all event properties that are common to all specified types are visible on the variant stream, including nested, indexed and mapped properties. For access to properties that are only available on one of the types, the dynamic property syntax must be used. In the example above, the <literal>customerId</literal> and <literal>price</literal> were properties common to both <literal>ServiceOrder</literal> and <literal>ProductOrder</literal> events.
			</para>		

			<para>
				For example, here is a consuming statement that selects a <literal>service duraction</literal> property that only <literal>ServiceOrder</literal> events have, and that must therefore be casted to double and null values removed in order to aggregate:
			</para>
			<programlisting>select customerId, sum(coalesce(cast(serviceDuraction?, double), 0)) 
from OrderStream.win:time(30 sec) group by customerId</programlisting>			

			<para>
				If your application predefines a variant stream to hold any type of events (the <literal>any</literal> type variance), then all event properties of the variant stream are effectively dynamic properties. 
			</para>		

			<para>
				For example, an application may define an <literal>OutgoingEvents</literal> variant stream to hold any type of event. The next statement is a sample consumer of the <literal>OutgoingEvents</literal> variant stream that looks for the <literal>destination</literal> property and fires for each event in which the property exists with a value of <literal>'email'</literal>:
			</para>		
			<programlisting>select * from OutgoingEvents(destination = 'email')</programlisting>			
		</sect2>

		<sect2 id="insert-into-decorated">
			<title>Decorated Events</title>
			<indexterm><primary>decorated event</primary></indexterm>

			<para>
				Your <literal>select</literal> clause may use the '*' wildcard together with further expressions to populate a stream of events. A sample statement is:				
			</para>
			<programlisting>insert into OrderStream select *, price*units as linePrice from PurchaseOrder</programlisting>			

			<para>
				When using wildcard and selecting additional expression results, the engine produces what is called <emphasis>decorating</emphasis> events for the resulting stream. Decorating events add additional property values to an underlying event.
			</para>

			<para>
				In the above example the resulting OrderStream consists of underlying PurchaseOrder events <emphasis>decorated</emphasis> by a <literal>linePrice</literal> property that is a result of the <literal>price*units</literal> expression.
			</para>

			<para>
				In order to use <literal>insert into </literal> to insert into an existing stream of decorated events, your underlying event type must match, and all additional decorating property names and types of the <literal>select</literal> clause must also match.
			</para>
		</sect2>
		
		<sect2 id="insert-into-eventasproperty">
			<title>Event as a Property</title>
			<indexterm><primary>event as a property</primary></indexterm>

			<para>
				Your <literal>select</literal> clause may use the stream name to populate a stream of events in which each event has properties that are itself an event. A sample statement is:				
			</para>
			<programlisting>insert into CompositeStream select order, service, order.price+service.price as totalPrice 
from PurchaseOrder.std:lastevent() as order, ServiceEvent:std:lastevent() as service</programlisting>			

			<para>
				When using the stream name (or tag in patterns) in the select clause, the engine produces composite events: One or more of the properties of the composite event are events themselves.
			</para>

			<para>
				In the above example the resulting CompositeStream consists of 3 columns: the PurchaseOrder event, the ServiceEvent event and the <literal>totalPrice</literal> property that is a result of the <literal>order.price+service.price</literal> expression.
			</para>

			<para>
				In order to use <literal>insert into </literal> to insert into an existing stream of events in which properties are themselves events, each event column's event type must match, and all additional property names and types of the <literal>select</literal> clause must also match.
			</para>
		</sect2>
		
	</sect1>

    <sect1 id="epl-join">
        <title>Joining Event Streams</title>

		<indexterm><primary>join</primary></indexterm>
		<indexterm><primary>EPL</primary><secondary>join</secondary></indexterm>

		<para>
			Two or more event streams can be part of the <literal>from</literal> clause and thus both (all) streams determine the resulting events. The <literal>where</literal> clause lists the join conditions that Esper uses to relate events in the two or more streams. Reference and historical data such as stored in your relational database, and data returned by a method invocation, can also be included in joins. Please see <xref linkend="histdata_overview"/> and <xref linkend="joining_method"/> for details.
		</para>

		<para>
			Each point in time that an event arrives to one of the event streams, the two event streams are joined and output events are produced according to the <literal>where</literal> clause.
		</para>

		<para>
			This example joins 2 event streams. The first event stream consists of fraud warning events for which we keep the last 30 minutes. The second stream is withdrawal events for which we consider the last 30 seconds. The streams are joined on account number.
		</para>
<programlisting><![CDATA[select fraud.accountNumber as accntNum, fraud.warning as warn, withdraw.amount as amount,
       max(fraud.timestamp, withdraw.timestamp) as timestamp, 'withdrawlFraud' as desc
  from com.espertech.esper.example.atm.FraudWarningEvent.win:time(30 min) as fraud,
       com.espertech.esper.example.atm.WithdrawalEvent.win:time(30 sec) as withdraw
 where fraud.accountNumber = withdraw.accountNumber]]></programlisting>

		<para>
			Joins can also include one or more pattern statements as the next example shows:
		</para>
<programlisting><![CDATA[select * from FraudWarningEvent.win:time(30 min) as fraud,
    pattern [every w=WithdrawalEvent -> PINChangeEvent(acct=w.acct)].std:lastevent() as withdraw
 where fraud.accountNumber = withdraw.w.accountNumber]]></programlisting>

		<para>
			The statement above joins the last 30 minutes of fraud warnings with a pattern. The pattern consists of every withdrawal event that is followed by a PIN change event for the same account number. It joins the two event streams on account number. The last-event view instucts the join to only consider the last pattern match.
		</para>

		<para>
			In a join and outer join, your statement must declare a data window view or other view onto each stream. Streams that are marked as unidirectional and named windows as well as database or methods in a join are an exception and do not require a view to be specified. If you are joining an event to itself via contained-event selection, views also do not need to be specified.
		</para>

		<para>
			The next example joins all FraudWarningEvent events that arrived since the statement was started, with the last 20 seconds of PINChangeEvent events:
		</para>
<programlisting><![CDATA[select * from FraudWarningEvent.win:keepall() as fraud, PINChangeEvent.win:time(20 sec) as pin
 where fraud.accountNumber = pin.accountNumber]]></programlisting>

		<para>
			The above example employed the special keep-all view that retains all events.
		</para>

    </sect1>

    <sect1 id="epl-outerjoin">
        <title>Outer and Inner Joins</title>

		<indexterm><primary>outer join</primary></indexterm>
		<indexterm><primary>inner join</primary></indexterm>
		<indexterm><primary>EPL</primary><secondary>outer join</secondary></indexterm>
		<indexterm><primary>EPL</primary><secondary>inner join</secondary></indexterm>

		<para>
			Esper supports left outer joins, right outer joins, full outer joins and inner joins in any combination between an unlimited number of event streams. Outer and inner joins can also join reference and historical data as explained in <xref linkend="histdata_overview"/>, as well as join data returned by a method invocation as outlined in <xref linkend="joining_method"/>.
		</para>

		<para>
			The keywords <literal>left, right, full</literal> and <literal>inner</literal> control the type of the join between two streams. The <literal>on</literal> clause specifies one or more properties that join each stream. The synopsis is as follows:
		</para>

<synopsis>...from <emphasis>stream_def</emphasis> [as name] 
  ((left|right|full outer) | inner) join <emphasis>stream_def</emphasis> 
  on <emphasis>property</emphasis> = <emphasis>property</emphasis> [and <emphasis>property</emphasis> = <emphasis>property</emphasis> ...]
  [ ((left|right|full outer) | inner) join <emphasis>stream_def</emphasis> on ...]...
</synopsis>

		<para>
			If the outer join is a left outer join, there will be an output event for each event of the stream on the left-hand side of the clause. For example, in the left outer join shown below we will get output for each event in the stream RfidEvent, even if the event does not match any event in the event stream OrderList.
		</para>

<programlisting><![CDATA[select * from RfidEvent.win:time(30 sec) as rfid
       left outer join
       OrderList.win:length(10000) as orderlist
     on rfid.itemId = orderList.itemId]]></programlisting>
		
		<para>
			Similarly, if the join is a Right Outer Join, then there will be an output event for each event of the stream on the right-hand side of the clause. For example, in the right outer join shown below we will get output for each event in the stream OrderList, even if the event does not match any event in the event stream RfidEvent.
		</para>

<programlisting><![CDATA[select * from RfidEvent.win:time(30 sec) as rfid
       right outer join
       OrderList.win:length(10000) as orderlist
       on rfid.itemId = orderList.itemId]]></programlisting>

		<para>
			For all types of outer joins, if the join condition is not met, the select list is computed with the event properties of the arrived event while all other event properties are considered to be null.
		</para>
		
		<para>
			The next type of outer join is a full outer join. In a full outer join, each point in time that an event arrives to one of the event streams, one or more output events are produced. In the example below, when either an RfidEvent or an OrderList event arrive, one or more output event is produced. The next example shows a full outer join that joins on multiple properties:
		</para>

<programlisting><![CDATA[select * from RfidEvent.win:time(30 sec) as rfid
       full outer join
       OrderList.win:length(10000) as orderlist
       on rfid.itemId = orderList.itemId and rfid.assetId = orderList.assetId]]></programlisting>

		<para>
			The last type of join is an inner join. In an inner join, the engine produces an output event for each event of the stream on the left-hand side that matches at least one event on the right hand side considering the join properties. For example, in the inner join shown below we will get output for each event in the RfidEvent stream that matches one or more events in the OrderList data window:
		</para>

<programlisting><![CDATA[select * from RfidEvent.win:time(30 sec) as rfid
       inner join
       OrderList.win:length(10000) as orderlist
       on rfid.itemId = orderList.itemId and rfid.assetId = orderList.assetId]]></programlisting>

		<para>
			Patterns as streams in a join follow this rule: If no data window view is declared for the pattern then the pattern stream retains the last match. Thus a pattern must have matched at least once for the last row to become available in a join. Multiple rows from a pattern stream may be retained by declaring a data window view onto a pattern using the <literal>pattern [...].</literal><emphasis>view_specification</emphasis> syntax.
		</para>

		<para>
			Finally, this example outer joins multiple streams. Here the RfidEvent stream is outer joined to both ProductName and LocationDescription via left outer join:
		</para>

<programlisting><![CDATA[select * from RfidEvent.win:time(30 sec) as rfid
      left outer join ProductName.win:keepall() as refprod
        on rfid.productId = refprod.prodId
      left outer join LocationDescription.win:keepall() as refdesc
        on rfid.location = refdesc.locId]]></programlisting>
    </sect1>

    <sect1 id="epl-unidirectional">
        <title>Unidirectional Joins</title>

		<indexterm><primary>unidirectional joins</primary></indexterm>
		<indexterm><primary>EPL</primary><secondary>join, unidirectional</secondary></indexterm>
		<indexterm><primary>EPL</primary><secondary>outer join, unidirectional</secondary></indexterm>

		<para>
			In a join or outer join your statement lists multiple event streams, views and/or patterns in the <literal>from</literal> clause. As events arrive into the engine, each of the streams (views, patterns) provides insert and remove stream events. The engine evaluates each insert and remove stream event provided by each stream, and joins or outer joins each event against data window contents of each stream, and thus generates insert and remove stream join results.
		</para>
			
		<para>
		    The direction of the join execution depends on which stream or streams are currently providing an insert or remove stream event for executing the join. A join is thus multidirectional, or bidirectional when only two streams are joined.
			A join can be made unidirectional if your application does not want new results when events arrive on a given stream or streams.
		</para>

		<para>
			The <literal>unidirectional</literal> keyword can be used in the <literal>from</literal> clause to identify a single stream that provides the events to execute the join. If the keyword is present for a stream, all other streams in the <literal>from</literal> clause become passive streams. When events arrive or leave a data window of a passive stream then the join does not generate join results. 
		</para>

		<para>
			For example, consider a use case that requires us to join stock tick events (TickEvent) and news events (NewsEvent). The <literal>unidirectional</literal> keyword allows to generate results only when TickEvent events arrive, and not when NewsEvent arrive or leave the 10-second time window:
		</para>
		<programlisting><![CDATA[select * from TickEvent unidirectional, NewsEvent.win:time(10 sec) 
where tick.symbol = news.symbol]]></programlisting>

		<para>
			Aggregation functions in a <literal>unidirectional</literal> join aggregate within the context of each unidirectional event evaluation and are not cumulative.
		</para>
		<para>
			The count function in the next query returns, for each TickEvent, the number of matching NewEvent events:
		</para>
		<programlisting><![CDATA[select count(*) from TickEvent unidirectional, NewsEvent.win:time(10 sec) 
where tick.symbol = news.symbol]]></programlisting>

		<para>
			The following restrictions apply to unidirectional joins:
		</para>

		<orderedlist spacing="compact">
			<listitem>
				<para>
					The <literal>unidirectional</literal> keyword can only be specified for a single stream in the <literal>from</literal> clause. 
				</para>
			</listitem>
			<listitem>
				<para>
					Receiving data from a unidirectional join via the pull API (<literal>iterator</literal> method) is not allowed. This is because the engine holds no state for the single stream that provides the events to execute the join.
				</para>
			</listitem>
			<listitem>
				<para>
					The stream that declares the <literal>unidirectional</literal> keyword cannot declare a data window view or other view for that stream, since remove stream events are not processed for the single stream.
				</para>
			</listitem>
		</orderedlist>
    </sect1>

    <sect1 id="epl-subqueries">
        <title>Subqueries</title>

		<indexterm><primary>subqueries</primary></indexterm>
		<indexterm><primary>EPL</primary><secondary>subqueries</secondary></indexterm>

		<para>
			A subquery is a <literal>select</literal> within another statement. Esper supports subqueries in the <literal>select</literal> clause and in the <literal>where</literal> clause of EPL statements. Subqueries provide an alternative way to perform operations that would otherwise require complex joins. Subqueries can also make statements more readable then complex joins. 
	    </para>

		<para>
			Esper supports both simple subqueries as well as correlated subqueries. In a simple subquery, the inner query is not correlated to the outer query. Here is an example simple subquery within a <literal>select</literal> clause:
	    </para>
			
		<programlisting><![CDATA[select assetId, (select zone from ZoneClosed.std:lastevent) as lastClosed from RFIDEvent]]></programlisting>

		<para>
			If the inner query is dependent on the outer query, we will have a correlated subquery. An example of a correlated subquery is shown below. Notice the <literal>where</literal> clause in the inner query, where the condition involves a stream from the outer query:
	    </para>

		<programlisting><![CDATA[select * from RfidEvent as RFID where 'Dock 1' = 
  (select name from Zones.std:unique(zoneId) where zoneId = RFID.zoneId)]]></programlisting>
		
		<para>
			The example above shows a subquery in the <literal>where</literal> clause. The statement selects RFID events in which the zone name matches a string constant based on zone id. The statement uses the view <literal>std:unique</literal> to guarantee that only the last event per zone id is held from processing by the subquery.
		</para>

		<para>
			The next example is a correlated subquery within a <literal>select</literal> clause. In this statement the <literal>select</literal> clause retrieves the zone name by means of a subquery against the Zones set of events correlated by zone id:
		</para>

		<programlisting><![CDATA[select zoneId, (select name from Zones.std:unique(zoneId) 
  where zoneId = RFID.zoneId) as name from RFIDEvent]]></programlisting>

		<para>
			Note that when a simple or correlated subquery returns multiple rows, the engine returns a <literal>null</literal> value as the subquery result. To limit the number of events returned by a subquery consider using one of the views <literal>std:lastevent</literal>, <literal>std:unique</literal> and <literal>std:groupby</literal>.
		</para>

		<para>
			The <literal>select</literal> clause of a subquery also allows wildcard selects, which return as an event property the underlying event object of the event type as defined in the <literal>from</literal> clause. An example:
		</para>

		<programlisting><![CDATA[select (select * from MarketData.std:lastevent()) as md 
  from pattern [every timer:interval(10 sec)]]]></programlisting>

		<para>
			The output events to the statement above contain the underlying MarketData event in a property named "md". The statement populates the last MarketData event into a property named "md" every 10 seconds following the pattern definition, or populates a <literal>null</literal> value if no MarketData event has been encountered so far.
		</para>

		<para>
			Aggregation functions may be used in the <literal>select</literal> clause of the subselect as this example outlines:
		</para>
		<programlisting><![CDATA[select * from MarketData
where price > (select max(price) from MarketData(symbol='GOOG').std:lastevent())]]></programlisting>

		<para>
			As the sub-select expression is evaluated first, the query above actually never fires for the GOOG symbol, only for other symbols that have a price higher then the current maximum for GOOG. As a sidenote, the <literal>insert into</literal> clause can also be handy to compute aggregation results for use in multiple subqueries.
		</para>
		
		<para>
			The following restrictions apply to subqueries:
		</para>

		<orderedlist spacing="compact">
			<listitem>
				<para>
					The subquery stream definition must define a data window or other view to limit subquery results, reducing the number of events held for subquery execution
				</para>
			</listitem>
			<listitem>
				<para>
					Subqueries can only consist of a <literal>select</literal> clause, a <literal>from</literal> clause and a <literal>where</literal> clause. The <literal>group by</literal> and <literal>having</literal> clauses, as well as joins, outer-joins and output rate limiting are not permitted within subqueries.
				</para>
			</listitem>
			<listitem>
				<para>
					If using aggregation functions in a subquery, note these limitations:
				</para>
				<orderedlist spacing="compact">
					<listitem>
						<para>
							None of the properties of the correlated stream(s) can be used within aggregation functions.
						</para>
					</listitem>
					<listitem>
						<para>
							The properties of the subselect stream must all be within aggregation functions.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>where</literal> clause cannot be used to correlate between the subselect stream and the enclosing stream, since the engine would otherwise be forced to re-evaluate 
							the aggregation considering all events in the subselect-stream data window, which would likely be a very expensive operation.
						</para>
					</listitem>
				</orderedlist>
			</listitem>
		</orderedlist>

		<para>
			The order of evaluation of subqueries relative to the containing statement is guaranteed: If the containing statement and its subqueries are reacting to the same type of event, the subquery will receive the
			event first before the containing statement's clauses are evaluated. This behavior can be changed via configuration. The order of evaluation of subqueries is not guaranteed between subqueries.
		</para>

		<para>
			Performance of your statement containing one or more subqueries principally depends on two parameters. First, if your subquery correlates one or more columns in the subquery stream with the enclosing statement's streams via equals '=', the engine automatically builds the appropriate indexes for fast row retrieval based on the key values correlated (joined). The second parameter is the number of rows found in the subquery stream and the complexity of the filter criteria (<literal>where</literal> clause), as each row in the subquery stream must evaluate against the <literal>where</literal> clause filter.
		</para>

		<sect2 id="epl-subqueries-exists">
			<title>The '<literal>exists</literal>' Keyword</title>

			<para>
				The <literal>exists</literal> condition is considered "to be met" if the subquery returns at least one row. The <literal>not exists</literal> condition is considered true if the subquery returns no rows.
			</para>
			
			<para>
				The synopsis for the <literal>exists</literal> keyword is as follows:
			</para>
			<synopsis>exists (<emphasis>subquery</emphasis>)</synopsis>

			<para>
				Let's take a look at a simple example. The following is an EPL statement that uses the <literal>exists</literal> condition:
			</para>

			<programlisting><![CDATA[select assetId from RFIDEvent as RFID 
  where exists (select * from Asset.std:unique(assetId) where assetId = RFID.assetId)]]></programlisting>

			<para>
				This select statement will return all RFID events where there is at least one event in Assets unique by asset id with the same asset id.
			</para>
		</sect2>

		<sect2 id="epl-subqueries-in">
			<title>The '<literal>in</literal>' and '<literal>not in</literal>' Keywords</title>
			
			<para>
				The <literal>in</literal> subquery condition is true if the value of an expression matches one or more of the values returned by the subquery. Consequently, the <literal>not in</literal> condition is true if the value of an expression matches none of the values returned by the subquery.
			</para>
			
			<para>
				The synopsis for the <literal>in</literal> keyword is as follows:
			</para>
			<synopsis><emphasis>expression</emphasis> in (<emphasis>subquery</emphasis>)</synopsis>

			<para>
				The right-hand side subquery must return exactly one column.
			</para>

			<para>
				The next statement demonstrates the use of the <literal>in</literal> subquery condition: 
			</para>

			<programlisting><![CDATA[select assetId from RFIDEvent
  where zone in (select zone from ZoneUpdate(status = 'closed').win:time(10 min))]]></programlisting>

			<para>
				The above statement demonstrated the <literal>in</literal> subquery to select RFID events for which the zone status is in a closed state. 
			</para>

			<para>
				Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand row yields null, the result of the <literal>in</literal> construct will be null, not false (or true for <literal>not-in</literal>). This is in accordance with SQL's normal rules for Boolean combinations of null values.
			</para>
		</sect2>

		<sect2 id="epl-subqueries-anysome">
			<title>The '<literal>any</literal>' and '<literal>some</literal>' Keywords</title>
			
			<para>
				The <literal>any</literal> subquery condition is true if the expression returns true for one or more of the values returned by the subquery.
			</para>

			<para>
				The synopsis for the <literal>any</literal> keyword is as follows:
			</para>
			<synopsis><emphasis>expression</emphasis> <emphasis>operator</emphasis> any (<emphasis>subquery</emphasis>)
<emphasis>expression</emphasis> <emphasis>operator</emphasis> some (<emphasis>subquery</emphasis>)</synopsis>

			<para>
				The left-hand expression is evaluated and compared to each row of the subquery result using the given operator, which must yield a Boolean result. The result of <literal>any</literal> is "true" if any true result is obtained. The result is "false" if no true result is found (including the special case where the subquery returns no rows). 
			</para>

			<para>
				The <emphasis>operator</emphasis> can be any of the following values: <literal>=, !=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=</literal>.
			</para>

			<para>
				The <literal>some</literal> keyword is a synonym for <literal>any</literal>. The <literal>in</literal> construct is equivalent to <literal>= any</literal>.
			</para>
		
			<para>
				The right-hand side subquery must return exactly one column.
			</para>

			<para>
				The next statement demonstrates the use of the <literal>any</literal> subquery condition: 
			</para>

			<programlisting><![CDATA[select * from ProductOrder as ord
  where quantity < any
    (select minimumQuantity from MinimumQuantity.win:keepall())]]></programlisting>

			<para>
				The above query compares ProductOrder event's quantity value with all rows from the MinimumQuantity stream of events and returns only those ProductOrder events that have a quantity that is less then any of the minimum quantity values of the MinimumQuantity events.
			</para>

			<para>
				Note that if there are no successes and at least one right-hand row yields null for the operator's result, the result of the <literal>any</literal> construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values. 
			</para>
		</sect2>

		<sect2 id="epl-subqueries-all">
			<title>The '<literal>all</literal>' Keyword</title>
			
			<para>
				The <literal>all</literal> subquery condition is true if the expression returns true for all of the values returned by the subquery.
			</para>

			<para>
				The synopsis for the <literal>all</literal> keyword is as follows:
			</para>
			<synopsis><emphasis>expression</emphasis> <emphasis>operator</emphasis> all (<emphasis>subquery</emphasis>)</synopsis>

			<para>
				The left-hand expression is evaluated and compared to each row of the subquery result using the given operator, which must yield a Boolean result. The result of <literal>all</literal> is "true" if all rows yield true (including the special case where the subquery returns no rows). The result is "false" if any false result is found. The result is <literal>null</literal> if the comparison does not return false for any row, and it returns <literal>null</literal> for at least one row.
			</para>

			<para>
				The <emphasis>operator</emphasis> can be any of the following values: <literal>=, !=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=</literal>.
			</para>

			<para>
				The <literal>not in</literal> construct is equivalent to <literal>!= all</literal>.
			</para>
		
			<para>
				The right-hand side subquery must return exactly one column.
			</para>

			<para>
				The next statement demonstrates the use of the <literal>all</literal> subquery condition: 
			</para>

			<programlisting><![CDATA[select * from ProductOrder as ord
  where quantity < all
    (select minimumQuantity from MinimumQuantity.win:keepall())]]></programlisting>

			<para>
				The above query compares ProductOrder event's quantity value with all rows from the MinimumQuantity stream of events and returns only those ProductOrder events that have a quantity that is less then all of the minimum quantity values of the MinimumQuantity events.
			</para>
		</sect2>
    </sect1>

	<sect1 id="histdata_overview" revision="1">
		<title>Accessing Relational Data via SQL</title>
		
		<indexterm><primary>SQL</primary></indexterm>
		<indexterm><primary>join</primary><secondary>relational data via SQL</secondary></indexterm>
		<indexterm><primary>relational databases</primary></indexterm>
		<indexterm><primary>EPL</primary><secondary>joining relational data via SQL</secondary></indexterm>

		<para>
			This chapter outlines how reference data and historical data that are stored in a relational database can be queried via SQL within EPL statements. 
		</para>
			
		<para>
			Esper can access via join and outer join as well as via iterator (poll) API all types of event streams to stored data. In order for such data sources to become accessible to Esper, some configuration is required. The <xref linkend="config-database-ref"/> explains the required configuration for database access in greater detail, and includes information on configuring a query result cache.
		</para>
		
		<para>
			Esper does not parse of otherwise inspect your SQL query. Therefore your SQL can make use of any database-specific SQL language extensions or features that your database provides.
		</para>

		<para>
			If you have enabled query result caching in your Esper database configuration, Esper retains SQL query results in cache following the configured cache eviction policy. 
		</para>
			
		<para>
			Also if you have enabled query result caching in your Esper database configuration and provide EPL <literal>where</literal> clause and/or <literal>on</literal> clause (outer join) expressions, then 
			Esper builds indexes on the SQL query results to enable fast lookup. This is especially useful if your queries return a large number of rows. For building the proper indexes, Esper inspects the expression found in your EPL query <literal>where</literal> clause, if present. For outer joins, Esper also inspects your EPL query <literal>on</literal> clause. Esper analyzes the EPL <literal>on</literal> clause and <literal>where</literal> clause expressions, if present, looking for property comparison with or without logical AND-relationships between properties. When a SQL query returns rows for caching, Esper builds the appropriate index and lookup strategies for fast row matching against indexes.
		</para>

		<para>
			Joins or outer joins in which only SQL statements or method invocations are listed in the <literal>from</literal> clause and no other event streams are termed <emphasis>passive</emphasis> joins. A passive join does not produce an insert or remove stream and therefore does not invoke statement listeners with results. A passive join can be iterated on (polled) using a statement's <literal>safeIterator</literal> and <literal>iterator</literal> methods.
		</para>

		<para>
			There are no restrictions to the number of SQL statements or types of streams joined. The following restrictions currently apply:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Sub-views on an SQL query are not allowed; That is, one cannot create a time or length window on an SQL query. However one can use the <literal>insert into</literal> syntax to make join results available to a further statement.
				</para>
			</listitem>
			<listitem>
				<para>
					Your database software must support JDBC prepared statements that provide statement meta data at compilation time. Most major databases provide this function. A workaround is available for databases that do not provide this function.
				</para>
			</listitem>
			<listitem>
				<para>
					JDBC drivers must support the getMetadata feature. A workaround is available as below for JDBC drivers that don't support getting metadata.
				</para>
			</listitem>
		</itemizedlist>
		
		<para>
			The next sections assume basic knowledge of SQL (Structured Query Language).
		</para>

		<sect2 id="histdata_join" revision="1">
			<title>Joining SQL Query Results</title>
			
			<para>
				To join an event stream against stored data, specify the <literal>sql</literal> keyword followed by the name of the database and a parameterized SQL query. The syntax to use in the <literal>from</literal> clause of an EPL statement is:
			</para>
	
			<synopsis>sql:<emphasis>database_name</emphasis> [" <emphasis>parameterized_sql_query</emphasis> "]</synopsis>
	
			<para>
				The engine uses the <emphasis>database_name</emphasis> identifier to obtain configuration information in order to establish a database connection, as well as settings that control connection creation and removal. Please see <xref linkend="config-database-ref"/> to configure an engine for database access.
			</para>
				
			<para>
				Following the database name is the SQL query to execute. The SQL query can contain one or more substitution parameters. The SQL query string is placed in single brackets <literal>[</literal> and <literal>]</literal>. The SQL query can be placed in either single quotes (') or double quotes ("). The SQL query grammer is passed to your database software unchanged, allowing you to write any SQL query syntax that your database understands, including stored procedure calls.
			</para>

			<para>
				Substitution parameters in the SQL query string take the form <literal>${</literal><emphasis>event_property_name</emphasis><literal>}</literal>. The engine resolves <emphasis>event_property_name</emphasis> at statement execution time to the actual event property value supplied by the events in the joined event stream.
			</para>

			<para>
				The engine determines the type of the SQL query output columns by means of the result set metadata that your database software returns for the statement. The actual 
				query results are obtained via the <literal>getObject</literal> on <literal>java.sql.ResultSet</literal>.
			</para>

			<para>
				The sample EPL statement below joins an event stream consisting of <literal>CustomerCallEvent</literal> events with the results of an SQL query against the database named <literal>MyCustomerDB</literal> and table <literal>Customer</literal>: 
			</para>
			
			<programlisting><![CDATA[select custId, cust_name from CustomerCallEvent,
  sql:MyCustomerDB [' select cust_name from Customer where cust_id = ${custId} ']]]></programlisting>

			<para>
				The example above assumes that <literal>CustomerCallEvent</literal> supplies an event property named <literal>custId</literal>. The SQL query selects the customer name from the Customer table. The <literal>where</literal> clause in the SQL matches the Customer table column <literal>cust_id</literal> with the value of <literal>custId</literal> in each <literal>CustomerCallEvent</literal> event. The engine executes the SQL query for each new <literal>CustomerCallEvent</literal> encountered.
			</para>

			<para>
				If the SQL query returns no rows for a given customer id, the engine generates no output event. Else the engine generates one output event for each row returned by the SQL query. An outer join as described in the next section can be used to control whether the engine should generate output events even when the SQL query returns no rows.
			</para>

			<para>
				The next example adds a time window of 30 seconds to the event stream <literal>CustomerCallEvent</literal>. It also renames the selected properties to customerName and customerId to demonstrate how the naming of columns in an SQL query can be used in the <literal>select</literal> clause in the EPL query. And the example uses explicit stream names via the <literal>as</literal> keyword.
			</para>

			<programlisting><![CDATA[select customerId, customerName from
  CustomerCallEvent.win:time(30 sec) as cce,
  sql:MyCustomerDB ["select cust_id as customerId, cust_name as customerName from Customer 
                  where cust_id = ${cce.custId}"] as cq]]></programlisting>

			<para>
				Any window, such as the time window, generates insert stream (istream) events as events enter the window, and remove stream (rstream) events as events leave the window. The engine executes the given SQL query for each <literal>CustomerCallEvent</literal> in both the insert stream and the remove stream. As a performance optimization, the <literal>istream</literal> or <literal>rstream</literal> keywords in the <literal>select</literal> clause can be used to instruct the engine to only join insert stream or remove stream events, reducing the number of SQL query executions.
			</para>
			
		</sect2>

		<sect2 id="histdata_join_where" revision="1">
			<title>SQL Query and the EPL <literal>Where</literal> Clause</title>
			
			<para>
				Consider using the EPL <literal>where</literal> clause to join the SQL query result to your event stream. Similar to EPL joins and outer-joins that join event streams or patterns, the EPL <literal>where</literal> clause provides join criteria between the SQL query results and the event stream (as a side note, an SQL <literal>where</literal> clause is a filter of rows executed by your database on your database server before returning SQL query results).
			</para>

			<para>
				Esper analyzes the expression in the EPL <literal>where</literal> clause and outer-join <literal>on</literal> clause, if present, and builds the appropriate indexes from that information at runtime, to ensure fast matching of event stream events to SQL query results, even if your SQL query returns a large number of rows. Your applications must ensure to configure a cache for your database using Esper configuration, as such indexes are held with regular data in a cache. If you application does not enable caching of SQL query results, the engine does not build indexes on cached data.
			</para>

			<para>
				The sample EPL statement below joins an event stream consisting of <literal>OrderEvent</literal> events with the results of an SQL query against the database named <literal>MyRefDB</literal> and table <literal>SymbolReference</literal>: 
			</para>
			
			<programlisting><![CDATA[select symbol, symbolDesc from OrderEvent as orders,
  sql:MyRefDB ['select symbolDesc from SymbolReference'] as reference
  where reference.symbol = orders.symbol]]></programlisting>

			<para>
				Notice how the EPL <literal>where</literal> clause joins the <literal>OrderEvent</literal> stream to the <literal>SymbolReference</literal> table. In this example, the SQL query itself does not have a SQL <literal>where</literal> clause 
				and therefore returns all rows from table <literal>SymbolReference</literal>.
			</para>

			<para>
				If your application enables caching, the SQL query fires only at the arrival of the first <literal>OrderEvent</literal> event. When the second <literal>OrderEvent</literal> arrives, the join execution uses the cached query result. If the caching policy that you specified in the Esper database configuration evicts the SQL query result from cache, then the engine fires the SQL query again to obtain a new result and places the result in cache.
			</para>
			
			<para>
				If SQL result caching is enabled and your EPL <literal>where</literal> clause, as show in the above example, provides the properties to join, then the engine indexes the SQL query results in cache and retains the index together with the query result in cache. Thus your application can benefit from high performance index-based lookups as long as the SQL query results are found in cache. 
			</para>

			<para>
				The SQL result caches operate on the level of all result rows for a given parameter set. For example, if your query returns 10 rows for a certain set of parameter values then the cache treats all 10 rows as a single entry keyed by the parameter values, and the expiry policy applies to all 10 rows and not to each individual row.
			</para>

			<para>
				It is also possible to join multiple autonomous database systems in a single query, for example:
			</para>

			<programlisting><![CDATA[select symbol, symbolDesc from OrderEvent as orders,
  sql:My_Oracle_DB ['select symbolDesc from SymbolReference'] as reference,
  sql:My_MySQL_DB ['select orderList from orderHistory'] as history
  where reference.symbol = orders.symbol
  and history.symbol = orders.symbol ]]></programlisting>
		</sect2>

		<sect2 id="histdata_outerjoin" revision="1">
			<title>Outer Joins With SQL Queries</title>

			<para>
				You can use outer joins to join data obtained from an SQL query and control when an event is produced. Use a left outer join, such as in the next statement, if you need an output event for each event regardless of whether or not the SQL query returns rows. If the SQL query returns no rows, the join result populates null values into the selected properties.
			</para>
						
			<programlisting><![CDATA[select custId, custName from
  CustomerCallEvent as cce
  left outer join 
  sql:MyCustomerDB ["select cust_id, cust_name as custName 
                     from Customer where cust_id = ${cce.custId}"] as cq
  on cce.custId = cq.cust_id]]></programlisting>

			<para>
				The statement above always generates at least one output event for each <literal>CustomerCallEvent</literal>, containing all columns selected by the SQL query, even if the SQL query does not return any rows. Note the <literal>on</literal> expression that is required for outer joins. The <literal>on</literal> acts as an additional filter to rows returned by the SQL query.
			</para>
		</sect2>

		<sect2 id="histdata_polling_pattern" revision="1">
			<title>Using Patterns to Request (Poll) Data</title>
			
			<para>
				Pattern statements and SQL queries can also be applied together in useful ways. One such use is to poll or request data from a database at regular intervals or following the schedule of the crontab-like <literal>timer:at</literal>.
			</para>
						
			<para>
				The next statement is an example that shows a pattern that fires every 5 seconds to query the NewOrder table for new orders:
			</para>

			<programlisting><![CDATA[insert into NewOrders
select orderId, orderAmount from
  pattern [every timer:interval(5 sec)],
  sql:MyCustomerDB ['select orderId, orderAmount from NewOrders']]]></programlisting>
			
		</sect2>

		<sect2 id="histdata_polling" revision="1">
			<title>Polling SQL Queries via Iterator</title>
			
			<para>
				Usually your SQL query will take part in a join and thus be triggered by an event or pattern occurrence. Instead, your application may need to poll a SQL query and thus use Esper query execution and caching facilities and obtain event data and metadata.
			</para>
						
			<para>
				Your EPL statement can specify an SQL statement without a join. Such a stand-alone SQL statement does not post new events, and may only be queried via the <literal>iterator</literal> poll API. Your EPL and SQL statement may still use variables.
			</para>

			<para>
				The next statement assumes that a <literal>price_var</literal> variable has been declared. It selects from the relational database table named <literal>NewOrder</literal> all rows in which the <literal>price</literal> column is greater 
				then the current value of the <literal>price_var</literal> EPL variable:
			</para>
			<programlisting><![CDATA[select * from sql:MyCustomerDB ['select * from NewOrder where ${price_var} > price']]]></programlisting>

			<para>
				Use the <literal>iterator</literal> and <literal>safeIterator</literal> methods on <literal>EPStatement</literal> to obtain results. The statement does not post events to listeners, it is strictly passive in that sense.
			</para>
		</sect2>

		<sect2 id="histdata_implementation" revision="1">
			<title>JDBC Implementation Overview</title>

			<para>
				The engine translates SQL queries into JDBC <literal>java.sql.PreparedStatement</literal> statements by replacing ${name} parameters with '?' placeholders. It obtains name and type of result columns from the compiled <literal>PreparedStatement</literal> meta data when the EPL statement is created.
			</para>

			<para>
				The engine supplies parameters to the compiled statement via the <literal>setObject</literal> method on <literal>PreparedStatement</literal>. The engine uses the <literal>getObject</literal> method on the compiled statement <literal>PreparedStatement</literal> to obtain column values.
			</para>
		</sect2>
		
		<sect2 id="histdata_nometadata" revision="1">
			<title>Oracle Drivers and No-Metadata Workaround</title>

			<para>
			   Certain JDBC database drivers are known to not return metadata for precompiled prepared SQL statements. This can be a problem as metadata is required by Esper. Esper obtains SQL result set metadata to validate an EPL statement and to provide column types for output events. JDBC drivers that do not provide metadata for precompiled SQL statements require a workaround. Such drivers do generally provide metadata for executed SQL statements, however do not provide the metadata for precompiled SQL statements.
			</para>
			
			<para>
				Please consult the <xref linkend="configuration"/> for the configuration options available in relation to metadata retrieval.
			</para>

			<para>
				To obtain metadata for an SQL statement, Esper can alternatively fire a SQL statement which returns the same column names and types as the actual SQL statement but without returning any rows. This kind of SQL statement is referred to as a <emphasis>sample</emphasis> statement in below workaround description. The engine can then use the sample SQL statement to retrieve metadata for the column names and types returned by the actual SQL statement.
			</para>

			<para>
				Applications can provide a sample SQL statement to retrieve metadata via the <literal>metadatasql</literal> keyword:
			</para>
			<synopsis>sql:<emphasis>database_name</emphasis> ["<emphasis>parameterized_sql_query</emphasis>" metadatasql "<emphasis>sql_meta_query</emphasis>"] </synopsis>

			<para>
				The <emphasis>sql_meta_query</emphasis> must be an SQL statement that returns the same number of columns, the same type of columns and the same column names as the 
				<emphasis>parameterized_sql_query</emphasis>, and does not return any rows.
			</para>

			<para>
				Alternatively, applications can choose not to provide an explicit sample SQL statement. If the EPL statement does not use the <literal>metadatasql</literal> syntax, the engine applies lexical analysis to the SQL statement. From the lexical analysis Esper generates a sample SQL statement adding a restrictive clause "where 1=0"  to the SQL statement.
			</para>

			<para>
				Alternatively, you can add the following tag to the SQL statement: <literal>${$ESPER-SAMPLE-WHERE}</literal>. If the tag  exists in the SQL statement, the engine does not perform lexical analysis and simply replaces the 
				tag with the SQL <literal>where</literal> clause "where 1=0". Therefore this workaround is applicable to SQL statements that cannot be correctly lexically analyzed. The SQL text after the placeholder is not part of the sample query. For example:
			</para>
			<programlisting><![CDATA[select mycol from sql:myDB [
  'select mycol from mytesttable ${$ESPER-SAMPLE-WHERE} where ....'], ...]]></programlisting>

			<para>
				If your <emphasis>parameterized_sql_query</emphasis> SQL query contains vendor-specific SQL syntax, generation of the metadata query may fail to produce a valid SQL statement. If you experience an SQL error while fetching metadata, use any of the above workarounds with the Oracle JDBC driver. 
			</para>
		</sect2>

	</sect1>
	
	<sect1 id="joining_method" revision="1">
		<title>Accessing Non-Relational Data via Method Invocation</title>
		
		<indexterm><primary>join</primary><secondary>non-relational data via method invocation</secondary></indexterm>
		<indexterm><primary>EPL</primary><secondary>joining non-relational data via method invocation</secondary></indexterm>

		<para>
			Your application may need to join data that originates from a web service, a distributed cache, an object-oriented database or simply data held in memory by your application. Esper accommodates this need by allowing
			a method invocation (or procedure call or function) in the <literal>from</literal> clause of a statement. 
		</para>
			
		<para>
			The results of such a method invocation in the <literal>from</literal> clause plays the same role as a relational database table in an inner and outer join in SQL. The role is thus dissimilar to the role of a user-defined function, which may occur in any expression such as in the <literal>select</literal> clause or the <literal>where</literal> clause. Both are backed by one or more static methods provided by your class library.
		</para>

		<para>
			Esper can join and outer join an unlimited number and all types of event streams to the data returned by your method invocation. In addition, Esper can be configured to cache the data returned by your method invocations.
		</para>
		
		<para>
			Joins or outer joins in which only SQL statements or method invocations are listed in the <literal>from</literal> clause and no other event streams are termed <emphasis>passive</emphasis> joins. A passive join does not produce an insert or remove stream and therefore does not invoke statement listeners with results. A passive join can be iterated on (polled) using a statement's <literal>safeIterator</literal> and <literal>iterator</literal> methods.
		</para>

		<para>
			The following restrictions currently apply:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Sub-views on a method invocations are not allowed; That is, one cannot create a time or length window on a method invocation. However one can use the <literal>insert into</literal> syntax to make join results available to a further statement.
				</para>
			</listitem>
		</itemizedlist>

		<sect2 id="joining_method_syntax" revision="1">
			<title>Joining Method Invocation Results</title>
			<para>
				The syntax for a method invocation in the <literal>from</literal> clause of an EPL statement is:
			</para>
			<synopsis>method:<emphasis>class_name</emphasis>.<emphasis>method_name</emphasis>[(<emphasis>parameter_expressions</emphasis>)]</synopsis>
	
			<para>
				The <literal>method</literal> keyword denotes a method invocation. It is followed by a class name and a method name separated by a dot (.) character. If you have parameters to your method invocation, these are placed in 
				round brackets after the method name. Any expression is allowed as a parameter, and individual parameter expressions are separated by a comma. Expressions may also use event properties of the joined stream. 
			</para>
	
			<para>
				In the sample join statement shown next, the method 'lookupAsset' provided by class 'MyLookupLib' returns one or more rows based on the asset id (a property of the AssetMoveEvent) that is passed to the method:
			</para>
			<programlisting><![CDATA[select * from AssetMoveEvent, method:MyLookupLib.lookupAsset(assetId)]]></programlisting>
	
			<para>
				The following statement demonstrates the use of the <literal>where</literal> clause to join events to the rows returned by a method invocation, which in this example does not take parameters:
			</para>
			<programlisting><![CDATA[select assetId, assetDesc from AssetMoveEvent as asset, 
       method:MyLookupLib.getAssetDescriptions() as desc 
where asset.assetid = desc.assetid]]></programlisting>
	
			<para>
				Your method invocation may return zero, one or many rows for each method invocation. If you have caching enabled through configuration, then Esper can avoid the method invocation and instead use cached results. Similar to SQL joins, Esper also indexes cached result rows such that join operations based on the <literal>where</literal> clause or outer-join <literal>on</literal> clause can be very efficient, especially if your method invocation returns a large number of rows.
			</para>

			<para>
				If the time taken by method invocations is critical to your application, you may configure local caches as <xref linkend="config-method-invocations"/> describes.
			</para>

			<para>
				Esper analyzes the expression in the EPL <literal>where</literal> clause and outer-join <literal>on</literal> clause, if present, and builds the appropriate indexes from that information at runtime, to ensure fast matching of event stream events to method invocation results, even if your method invocation returns a large number of rows. Your applications must ensure to configure a cache for your method invocation using Esper configuration, as such indexes are held with regular data in a cache. If you application does not enable caching of method invocation results, the engine does not build indexes on cached data.
			</para>
			
		</sect2>

		<sect2 id="joining_method_polling" revision="1">
			<title>Polling Method Invocation Results via Iterator</title>
			
			<para>
				Usually your method invocation will take part in a join and thus be triggered by an event or pattern occurrence. Instead, your application may need to poll a method invocation and thus use Esper query execution and caching facilities and obtain event data and metadata.
			</para>
						
			<para>
				Your EPL statement can specify a method invocation in the <literal>from</literal> clause without a join. Such a stand-alone method invocation does not post new events, and may only be queried via the <literal>iterator</literal> poll API. Your EPL statement may still use variables.
			</para>

			<para>
				The next statement assumes that a <literal>category_var</literal> variable has been declared. It polls the <literal>getAssetDescriptions</literal> method passing the current value of the <literal>category_var</literal> EPL variable:
			</para>
			<programlisting><![CDATA[select * from method:MyLookupLib.getAssetDescriptions(category_var)]]]></programlisting>

			<para>
				Use the <literal>iterator</literal> and <literal>safeIterator</literal> methods on <literal>EPStatement</literal> to obtain results. The statement does not post events to listeners, it is strictly passive in that sense.
			</para>
		</sect2>

		<sect2 id="joining_method_exposing" revision="1">
			<title>Providing the Method</title>
			
			<para>
				Your application must provide a Java class that exposes a public static method. The method must accept the same number and type of parameters as listed in the parameter expression list. 
			</para>
			
			<para>
				If your method invocation returns either no row or only one row, then the return type of the method can be a Java class or a <literal>java.util.Map</literal>. If your method invocation can return more then one row, then the return type of the method must be an array of Java class or an array of <literal>Map</literal>.
			</para>
			
			<para>
				If you are using a Java class or an array of Java class as the return type, then the class must adhere to JavaBean conventions: it must expose properties through getter methods.
			</para>

			<para>
				If you are using <literal>java.util.Map</literal> as the return type or an array of <literal>Map</literal>, then the map should have <literal>String</literal>-type keys and object values (<literal>Map&lt;String, Object&gt;</literal>). When using <literal>Map</literal> as the return type, your application must provide a second method that returns property metadata, as the next section outlines.
			</para>

			<para>
				Your application method must return either of the following:
			</para>
			
			<orderedlist>
				<listitem>
					<para>
						A <literal>null</literal> value or an empty array to indicate an empty result (no rows).
					</para>
				</listitem>
				<listitem>
					<para>
						A Java object or <literal>Map</literal> to indicate a one-row result, or an array that consists of a single Java object or <literal>Map</literal>.
					</para>
				</listitem>
				<listitem>
					<para>
						An array of Java objects or <literal>Map</literal> instances to return multiple result rows.
					</para>
				</listitem>
			</orderedlist>
			
			<para>
				As an example, consider the method 'getAssetDescriptions' provided by class 'MyLookupLib' as discussed earlier:
			</para>
			<programlisting><![CDATA[]]>select assetId, assetDesc from AssetMoveEvent as asset,
       method:com.mypackage.MyLookupLib.getAssetDescriptions() as desc 
  where asset.assetid = desc.assetid</programlisting>
																	
			<para>
				The 'getAssetDescriptions' method may return multiple rows and is therefore declared to return an array of the class 'AssetDesc'. The class AssetDesc is a POJO class (not shown here):
			</para>
			<programlisting><![CDATA[public class MyLookupLib {
  ...
  public static AssetDesc[] getAssetDescriptions() {
    ...
    return new AssetDesc[] {...};
  }]]></programlisting>

			<para>
				The example above specifies the full Java class name of the class 'MyLookupLib' class in the EPL statement. The package name does not need to be part of the EPL if your application imports the package using the auto-import configuration through the API or XML, as outlined in <xref linkend="config-class--package-imports"/>.
			</para>
			
		</sect2>

		<sect2 id="joining_method_map" revision="1">
			<title>Using a <literal>Map</literal> Return Type</title>
			
			<para>
				Your application may return <literal>java.util.Map</literal> or an array of <literal>Map</literal> from method invocations. If doing so, your application must provide metadata about each row: it must declare the property name and property type of each <literal>Map</literal> entry of a row. This information allows the engine to perform type checking of expressions used within the statement.
			</para>
			
			<para>
				You declare the property names and types of each row by providing a method that returns property metadata. The metadata method must follow these conventions:
			</para>
			
			<orderedlist>
				<listitem>
					<para>
						The method name providing the property metadata must have same method name appended by the literal <literal>Metadata</literal>.
					</para>
				</listitem>
				<listitem>
					<para>
						The method must have an empty parameter list and must be declared public and static.
					</para>
				</listitem>
				<listitem>
					<para>
						The method providing the metadata must return a <literal>Map</literal> of <literal>String</literal> property name keys and <literal>java.lang.Class</literal> property name types (<literal>Map&lt;String, Class&gt;</literal>).
					</para>
				</listitem>
			</orderedlist>
			
			<para>
				In the following example, a class 'MyLookupLib' provides a method to return historical data based on asset id and asset code:
			</para>
			<programlisting><![CDATA[]]>select assetId, location, x_coord, y_coord from AssetMoveEvent as asset,
       method:com.mypackage.MyLookupLib.getAssetHistory(assetId, assetCode) as history</programlisting>
																	
			<para>
				A sample implementation of the class 'MyLookupLib' is shown below. 
			</para>
			<programlisting><![CDATA[public class MyLookupLib {
  ...
  // For each column in a row, provide the property name and type
  //
  public static Map<String, Class> getAssetHistoryMetadata() {
    Map<String, Class> propertyNames = new HashMap<String, Class>();
    propertyNames.put("location", String.class);
    propertyNames.put("x_coord", Integer.class);
    propertyNames.put("y_coord", Integer.class);
    return propertyNames;
  }
... 
  // Lookup rows based on assetId and assetCode
  // 
  public static Map<String, Object>[] getAssetHistory(String assetId, String assetCode) {
    Map rows = new Map[2];	// this sample returns 2 rows
    for (int i = 0; i < 2; i++) {
      rows[i] = new HashMap();
      rows[i].put("location", "somevalue");
      rows[i].put("x_coord", 100);
      // ... set more values for each row
    }
    return rows;
  }]]></programlisting>

			<para>
				In the example above, the 'getAssetHistoryMetadata' method provides the property metadata: the names and types of properties in each row.  The engine calls this method once per statement to determine event typing information.
			</para>

			<para>
				The 'getAssetHistory' method returns an array of <literal>Map</literal> objects that are two rows. The implementation shown above is a simple example. The parameters to the method are the assetId and assetCode properties of the AssetMoveEvent joined to the method. The engine calls this method for each insert and remove stream event in AssetMoveEvent.
			</para>
			
			<para>
				To indicate that no rows are found in a join, your application method may return either a <literal>null</literal> value or an array of size zero.
			</para>
			
		</sect2>

	</sect1>

	<sect1 id="named_overview" revision="1">
		<title>Creating and Using Named Windows</title>
		
		<indexterm><primary>named window</primary></indexterm>
		<indexterm><primary>EPL</primary><secondary>named window</secondary></indexterm>

		<para>
			A <emphasis>named window</emphasis> is a global data window that can take part in many statement queries, and that can be inserted-into and deleted-from by multiple statements. A named window holds events of the same type or supertype, unless used with a variant stream. 
		</para>
		
		<para>
			The <literal>create window</literal> clause declares a new named window. The named window starts up empty unless populated from an existing named window at time of creation. Events must be inserted into the named window using the <literal>insert into</literal> clause. Events can also be deleted from a named window via the <literal>on delete</literal> clause. 
		</para>	
			
		<para>
			Events enter the named window by means of <literal>insert into</literal> clause of a <literal>select</literal> statement. Events leave a named window either because the expiry policy of the declared data window removes events from the named window, or through statements that use the <literal>on delete</literal> clause to explicitly delete from a named window.
		</para>	
		
		<para>
			To query a named window, simply use the window name in the <literal>from</literal> clause of your statement, including statements that contain subqueries, joins and outer-joins.
		</para>	
		
		<para>
			A named window may also decorate an event to preserve original events as described in <xref linkend="insert-into-decorated"/> and <xref linkend="named-insertinto-decorated"/>.
			In addition, columns of a named window are allowed to hold events themselves, as further explained in <xref linkend="insert-into-eventasproperty"/> and <xref linkend="named-insertinto-eventasproperty"/>.
		</para>

		<sect2 id="named_create" revision="1">
			<title>Creating Named Windows: the <literal>Create Window</literal> clause</title>
			
			<para>
				The <literal>create window</literal> statement creates a named window by specifying a window name and one or more data window views, as well as the type of event to hold in the named window.
			</para>

			<para>
				There are two syntaxes for creating a named window: The first syntax allows to model a named window after an existing event type or an existing named window. The second syntax is similar to the SQL create-table syntax and provides a list of column names and column types. 
			</para>

			<para>
				A new named window starts up empty. It must be explicitly inserted into by one or more statements, as discussed below. A named window can also be populated at time of creation from an existing named window.
			</para>

			<para>
				If your application stops or destroys the statement that creates the named window, any consuming statements no longer receive insert or remove stream events. The named window can also not be deleted from after it was stopped or destroyed.
			</para>

			<para>
				The <literal>create window</literal> statement posts to listeners any events that are inserted into the named window as new data. The statement posts all deleted events or events that expire out of the data window to listeners as the remove stream (old data). The named window contents can also be iterated on via the pull API to obtain the current contents of a named window.
			</para>

			<sect3 id="named_create_modelafter" revision="1">
				<title>Creation by Modelling after an Existing Type</title>

				<para>
					The benefit of modelling a named window after an existing event type is that event properties can be nested, indexed, mapped or other types that your event objects may provide as properties, including the type of the underlying event itself. Also, using the wildcard (*) operator means your EPL does not need to list each individual property explicitly.
				</para>

				<para>
					The syntax for creating a named window by modelling the named window after an existing event type, is as follows: 
				</para>
				<synopsis>create window <emphasis>window_name</emphasis>.<emphasis>view_specifications</emphasis> 
    [as] [select <emphasis>list_of_properties</emphasis> from] <emphasis>event_type_or_windowname</emphasis>
    [insert [where <emphasis>filter_expression</emphasis>]]</synopsis>
						
				<para>
					The <emphasis>window_name</emphasis> you assign to the named window can be any identifier. The name should not already be in use as an event type or stream name.
				</para>
					
				<para>
					The <emphasis>view_specifications</emphasis> are one or more data window views that define the expiry policy for removing events from the data window. Named windows must explicitly declare a data window view. This is required to ensure that the policy for retaining events in the data window is well defined. To keep all events, use the keep-all view: It indicates that the named window should keep all events and only remove events from the named window that are deleted via the <literal>on delete</literal> clause. The view specification can only list data window views, derived-value views are not allowed since these don't represent an expiry policy. Data window views are listed in <xref linkend="epl-views"/>. View parameterization and staggering are described in <xref linkend="epl-from-clause-view-spec"/>.
				</para>
					
				<para>				
					The <literal>select</literal> clause and <emphasis>list_of_properties</emphasis> are optional. If present, they specify the column names and, implicitly by definition of the event type, the column types of events held by the named window. Expressions other then column names are not allowed in the <literal>select</literal> list of properties. Wildcards (*) and wildcards with additional properties can also be used.
				</para>
	
				<para>				
					The <emphasis>event_type_or_windowname</emphasis> is required if using the model-after syntax. It provides the name of the event type of events held in the data window, unless column names and types have been explicitly selected via <literal>select</literal>. The name of an (existing) other named window is also allowed here. Please find more details in <xref linkend="named_populate_named"/>.
				</para>
	
				<para>				
					Finally, the <literal>insert</literal> clause and optional <emphasis>filter_expression</emphasis> are used if the new named windows is modelled after an existing named window, and the data of the existing named window is to be populated, upon time of creation of the new window, from the existing named window. The optional <emphasis>filter_expression</emphasis> can be used to exclude events.
				</para>

				<para>
					The next statement creates a named window 'AllOrdersNamedWindow' for which the expiry policy is simply to keep all events. Assume that the event type 'OrderMapEventType' has been configured. The named window is to hold events of type 'OrderMapEventType':
				</para>
				<programlisting><![CDATA[create window AllOrdersNamedWindow.win:keepall() as OrderMapEventType]]></programlisting>
	
				<para>
					The below sample statement demonstrates the <literal>select</literal> syntax. It defines a named window in which each row has the three properties 'symbol', 'volume' and 'price'. This named window actively removes events from the window that are older then 30 seconds.
				</para>
				<programlisting><![CDATA[create window OrdersTimeWindow.win:time(30 sec) as 
  select symbol, volume, price from OrderEvent]]></programlisting>

				<para>
					In an alternate form, the <literal>as</literal> keyword can be used to rename columns, and constants may occur in the select clause as well:
				</para>
				<programlisting><![CDATA[create window OrdersTimeWindow.win:time(30 sec) as 
  select symbol as sym, volume as vol, price, 1 as alertId from OrderEvent]]></programlisting>
	
			</sect3>
			
			<sect3 id="named_create_explicit" revision="1">
				<title>Creation By Defining Columns Names and Types</title>

				<para>
					The second syntax for creating a named window is by supplying column names and types: 
				</para>
				<synopsis>create window <emphasis>window_name</emphasis>.<emphasis>view_specifications</emphasis> [as] (<emphasis>column_name</emphasis> <emphasis>column_type</emphasis> 
  [,<emphasis>column_name</emphasis> <emphasis>column_type</emphasis> [,...])</synopsis>

				<para>				
					The <emphasis>column_name</emphasis> is an identifier providing the event property name. The <emphasis>column_type</emphasis> is also required for each column. Valid column types are listed in <xref linkend="variable_create"/>
					and are the same as for variable types.
				</para>
		
				<para>
					The next statement creates a named window:
				</para>
				<programlisting><![CDATA[create window SecurityEvent.win:time(30 sec) 
    (ipAddress string, userId String, numAttempts int)]]></programlisting>	
			</sect3>

			<sect3 id="named_create_drop" revision="1">
				<title>Dropping or Removing Named Windows</title>

				<para>
					There is no syntax to drop or remove a named window.
				</para>

				<para>
					The <literal>destroy</literal> method on the <literal>EPStatement</literal> that created the named window removes the named window. However the implicit event type associated with the named window remains active since further statements may continue to use that type. Therefore a named window of the same name can only be created again if the type information matches the prior declaration for a named window.
				</para>
			</sect3>

		</sect2>

		<sect2 id="named_delete" revision="1">
			<title>Deleting From Named Windows: the <literal>On Delete</literal> clause</title>
			
			<indexterm><primary>on-delete</primary></indexterm>
			<indexterm><primary>named window</primary><secondary>deleting from</secondary></indexterm>
			<indexterm><primary>EPL</primary><secondary>named window</secondary><tertiary>deleting from</tertiary></indexterm>

			<para>
				An <literal>on delete</literal> clause removes events from a named window. The clause can be used to remove all events, or only events that match certain criteria, or events that correlate with an arriving event or a pattern of arriving events.
			</para>

			<para>
				The syntax for the <literal>on delete</literal> clause is as follows: 
			</para>
			<synopsis>on <emphasis>event_type</emphasis>[<emphasis>(filter_criteria)</emphasis>] [as <emphasis>stream_name</emphasis>]
delete from <emphasis>window_name</emphasis> [as <emphasis>stream_name</emphasis>]
[where <emphasis>criteria_expression</emphasis>]</synopsis>
				
			<para>
				The <emphasis>event_type</emphasis> is the name of the type of events that trigger removal from the named window. It is optionally followed by <emphasis>filter_criteria</emphasis> which are filter expressions to apply to arriving events. The optional <literal>as</literal> keyword can be used to assign an name for use in the <literal>where</literal> clause. Patterns can also be specified in the <literal>on</literal> clause as described in the next section.
			</para>
				
			<para>
				The <emphasis>window_name</emphasis> is the name of the named window to delete events from. The <literal>as</literal> keyword is also available to assign a name to the named window.
			</para>
				
			<para>
				The optional <literal>where</literal> clause contains a <emphasis>criteria_expression</emphasis> that correlates the arriving (triggering) event to the events to be removed from the named window. The <emphasis>criteria_expression</emphasis> may also simply filter for events in the named window to be removed from the named window.
			</para>

			<para>
				The <literal>iterator</literal> of the <literal>EPStatement</literal> object representing the <literal>on delete</literal> clause can also be helpful: It returns the last batch of deleted events in response to the last triggering event, in any order, or null if the last triggering event did not remove any rows.
			</para>

			<para>				
				Let's look at a couple of examples. In the simplest form, this statement deletes all events from the named window 'AllOrdersNamedWindow' when any 'FlushOrderEvent' arrives:
			</para>
			<programlisting><![CDATA[on FlushOrderEvent delete from AllOrdersNamedWindow]]></programlisting>

			<para>				
				This example adds a <literal>where</literal> clause to the example above. Upon arrival of a triggering 'ZeroVolumeEvent', the statement removes from the named window any orders that have a volume of zero or less:
			</para>
			<programlisting><![CDATA[on ZeroVolumeEvent delete from AllOrdersNamedWindow where volume <= 0]]></programlisting>

			<para>				
				The next example shows a more complete use of the syntax, and correlates the triggering event with events held by the named window:
			</para>
			<programlisting><![CDATA[on NewOrderEvent(volume>0) as myNewOrders
delete from AllOrdersNamedWindow as myNamedWindow 
where myNamedWindow.symbol = myNewOrders.symbol]]></programlisting>

			<para>				
				In the above sample statement, only if a 'NewOrderEvent' event with a volume greater then zero arrives does the statement trigger. Upon triggering, all events in the named window that have the same value for the symbol property as the triggering 'NewOrderEvent' event are then removed from the named window. The statement also showcases the <literal>as</literal> keyword to assign a name for use in the <literal>where</literal> expression.
			</para>

			<para>				
				For correlated queries (as above) that correlate triggering events with events held by a named window, Esper internally creates efficient indexes to enable high performance removal of events especially from named windows that hold large numbers of events.
			</para>

			<para>
				Your application can subscribe a listener to your <literal>on delete</literal> statements to determine removed events. The statement post any events that are deleted from a named window to all listeners attached to the statement as new data. Upon iteration, the statement provides the last deleted event, if any.
			</para>

			<sect3 id="named_delete_pattern" >
			   <title>Using Patterns in the <literal>On Delete</literal> Clause</title>

				<para>
					By means of patterns the <literal>on delete</literal> clause and <literal>on select</literal> clause (described below) can look for more complex conditions to occur, possibly involving multiple events or the passing of time. The syntax for <literal>on delete</literal> with a pattern expression is show next:
				</para>
				<synopsis>on pattern [<emphasis>pattern_expression</emphasis>] [as <emphasis>stream_name</emphasis>]
delete from <emphasis>window_name</emphasis> [as <emphasis>stream_name</emphasis>]
[where <emphasis>criteria_expression</emphasis>]</synopsis>
					
				<para>
					The <emphasis>pattern_expression</emphasis> is any pattern that matches zero or more arriving events. Tags can be used to name events in the pattern and can occur in the optional <literal>where</literal> clause to correlate to events to be removed from a named window.
				</para>
					
				<para>
					In the next example the triggering pattern fires every 10 seconds. The effect is that every 10 seconds the statement removes from 'MyNamedWindow' all rows:
				</para>
				<programlisting><![CDATA[on pattern [every timer:interval(10 sec)] delete from MyNamedWindow]]></programlisting>

				<para>
					The following example shows the use of tags in a pattern: 
				</para>
				<programlisting><![CDATA[on pattern [every ord=OrderEvent(volume>0) or every flush=FlushOrderEvent] 
delete from OrderWindow as win
where ord.id = win.id or flush.id = win.id]]></programlisting>

				<para>
					The pattern above looks for OrderEvent events with a volume value greater then zero and tags such events as 'ord'. 
					The pattern also looks for FlushOrderEvent events and tags such events as 'flush'. The <literal>where</literal> clause deletes from the 'OrderWindow' named window any events that match in the value of the 'id' property either of the arriving events.
				</para>

			</sect3>
		</sect2>

		<sect2 id="named_inserting" revision="1">
			<title>Inserting Into Named Windows</title>
			
			<indexterm><primary>named window</primary><secondary>inserting into</secondary></indexterm>
			<indexterm><primary>EPL</primary><secondary>named window</secondary><tertiary>inserting into</tertiary></indexterm>

			<para>
				The <literal>insert into</literal> clause inserts events into named windows. Your application must ensure that the column names and types match the declared column names and types of the named window to be inserted into.
			</para>
			
			<para>
				In this example we first create a named window using some of the columns of an OrderEvent event type:
			</para>
			<programlisting><![CDATA[create window OrdersWindow.win:keepall() as select symbol, volume, price from OrderEvent]]></programlisting>
			
			<para>
				The insert into the named window selects individual columns to be inserted:
			</para>
			<programlisting><![CDATA[insert into OrdersWindow(symbol, volume, price) select name, count, price from FXOrderEvent
// .. alternative form...
insert into OrdersWindow select name as symbol, vol as volume, price from FXOrderEvent]]></programlisting>

			<para>
				Following above statement, the engine enters every FXOrderEvent arriving into the engine into the named window 'OrdersWindow'.
			</para>

			<para>
				The following EPL creates a named window for an event type backed by a Java class, and inserts into the window any 'OrderEvent' where the symbol value is IBM:
			</para>
			<programlisting><![CDATA[create window OrdersWindow as com.mycompany.OrderEvent
insert into OrdersWindow select * from com.mycompany.OrderEvent(symbol='IBM')]]></programlisting>

			<para>
				The last example adds one column named 'derivedPrice' to the 'OrderEvent' type by specifying a wildcard, and uses a user-defined function to populate the column:
			</para>
			<programlisting><![CDATA[create window OrdersWindow as select *, price as derivedPrice from OrderEvent
insert into OrdersWindow select *, MyFunc.func(price, percent) as derivedPrice from OrderEvent]]></programlisting>

			<para>
				Event representations based on Java base classes or interfaces, and subclasses or implementing classes, are compatible as these statements show:
			</para>
			<programlisting><![CDATA[// create a named window for the base class
create window OrdersWindow as select * from ProductBaseEvent

// The ServiceProductEvent class subclasses the ProductBaseEvent class
insert into OrdersWindow select * from ServiceProductEvent

// The MerchandiseProductEvent class subclasses the ProductBaseEvent class
insert into OrdersWindow select * from MerchandiseProductEvent]]></programlisting>

			<para>
				To avoid duplicate events stored in a named window, use a subquery to test whether an event already exists in the named window:
			</para>
			<programlisting><![CDATA[insert into OrdersWindow
select * from ServiceProductEvent as spe
where not exists (select * from OrdersWindow as win where win.id = spe.id)]]></programlisting>

			<para>
				A statement that removes events from a named window via the <literal>on delete</literal> clause and a statement that inserts events into a named window via the <literal>insert into</literal> can be combined to replace events in the named window, by creating the two statements in the order as indicated by the sample:
			</para>
			<programlisting><![CDATA[// create in this order
on ServiceProductEvent as spe delete from OrdersWindow as win where win.id = spe.id
insert into OrdersWindow select * from ServiceProductEvent]]></programlisting>

			<sect3 id="named-insertinto-decorated" revision="1">
				<title>Named Windows Holding Decorated Events</title>
				<para>
					Decorated events hold an underlying event and add additional properties to the underlying event, as described further in <xref linkend="insert-into-decorated"/>.
				</para>

				<para>
					Here we create a named window that decorates OrderEvent events by adding an additional property named <literal>priceTotal</literal> to each OrderEvent. A matching <literal>insert into</literal> statement is also part of the sample:
				</para>
				<programlisting><![CDATA[create window OrdersWindow as select *, price as priceTotal from OrderEvent

insert into OrdersWindow select *, price * unit as priceTotal from ServiceOrderEvent]]></programlisting>

				<para>
					The property type of the additional <literal>priceTotal</literal> column is the property type of the existing <literal>price</literal> property of OrderEvent.
				</para>
			</sect3>

			<sect3 id="named-insertinto-eventasproperty" revision="1">
				<title>Named Windows Holding Events As Property</title>
				<para>
					Columns in a named window may also hold an event itself. More information on the <literal>insert into</literal> clause providing event columns is in <xref linkend="insert-into-eventasproperty"/>.
				</para>

				<para>
					The next sample creates a named window that specifies two columns: A column that holds an OrderEvent, and a column by name <literal>priceTotal</literal>. A matching <literal>insert into</literal> statement is also part of the sample:
				</para>
				<programlisting><![CDATA[create window OrdersWindow as select this, price as priceTotal from OrderEvent

insert into OrdersWindow select order, price * unit as priceTotal  
from ServiceOrderEvent as order]]></programlisting>

				<para>
					Note that the <literal>this</literal> proprerty must exist on the event and must return the event class itself (JavaBean events only). The property type of the additional <literal>priceTotal</literal> column is the property type of the existing <literal>price</literal> property.
				</para>
			</sect3>
		</sect2>

		<sect2 id="named_selecting" revision="1">
			<title>Selecting From Named Windows</title>
			
			<indexterm><primary>named window</primary><secondary>selecting from</secondary></indexterm>
			<indexterm><primary>EPL</primary><secondary>named window</secondary><tertiary>selecting from</tertiary></indexterm>

			<para>
				A named window can be referred to by any statement in the <literal>from</literal> clause of the statement. Filter criteria can also be specified. Additional views may be used onto named windows however such views cannot include data window views.
			</para>
			
			<para>
				A statement selecting all events from a named window 'AllOrdersNamedWindow' is shown next. The named window must first be created via the <literal>create window</literal> clause before use.
			</para>
			<programlisting><![CDATA[select * from AllOrdersNamedWindow]]></programlisting>
			
			<para>
				The statement as above simply receives the unfiltered insert and remove stream of the named window and reports that stream to its listeners. An iterator on such statement returns all events in the named window, if any.
			</para>

			<para>
				The next statement derives an average price per symbol from all events posted by a named window: 
			</para>
			<programlisting><![CDATA[select symbol, avg(price) from AllOrdersNamedWindow group by symbol]]></programlisting>
			
			<para>
				Your application may create a consuming statement such as above on an empty named window, or your application may create the above statement on an already filled named window. The engine provides correct results in either case: 
				At the time of statement creation the Esper engine internally initializes the consuming statement from the current named window, also taking your declared filters into consideration. Thus, your statement deriving data from a named window does not start empty if the named window already holds one or more events. A consuming statement also sees the remove stream of an already populated named window, if any.
			</para>

			<para>
				If you require a subset of the data in the named window, you can specify one or more filter expressions onto the named window as shown here:
			</para>
			<programlisting><![CDATA[select symbol, avg(price) from AllOrdersNamedWindow(sector='energy') group by symbol]]></programlisting>
			
			<para>
				By adding a filter to the named window, the aggregation and grouping as well as any views that may be declared onto to the named window receive a filtered insert and remove stream. The above statement thus outputs, continuously, the average price per symbol for all orders in the named window that belong to a certain sector.
			</para>

			<para>
				A side note on variables in filters filtering events from named windows: The engine initializes consuming statements at statement creation time and changes aggregation state continuously as events arrive. If the filter criteria contain variables and variable values changes, then the engine does not re-evaluate or re-build aggregation state. In such a case you may want to place variables in the <literal>having</literal> clause which evaluates on already-built aggregation state.
			</para>

			<para>
				The following example further declares a view into the named window. Such a view can be a plug-in view or one of the built-in views, but cannot be a data window view (with the exception of the group-by view which is allowed).
			</para>
			<programlisting><![CDATA[select * from AllOrdersNamedWindow(volume>0, price>0).mycompany:mypluginview()]]></programlisting>
			
			<para>
				Data window views cannot be used onto named windows since named windows post insert and remove streams for the events entering and leaving the named window, thus the expiry policy and batch behavior are well defined by the data window declared for the named window. For example, the following is not allowed and fails at time of statement creation:
			</para>
			<programlisting><![CDATA[// not a valid statement
select * from AllOrdersNamedWindow.win:time(30 sec)]]></programlisting>
		</sect2>

		<sect2 id="named_querying" revision="1">
			<title>Triggered Select on Named Windows: the <literal>On Select</literal> clause</title>
			
			<indexterm><primary>on-select</primary></indexterm>
			<indexterm><primary>named window</primary><secondary>triggered select using On Select</secondary></indexterm>
			<indexterm><primary>EPL</primary><secondary>named window</secondary><tertiary>triggered select using On Select</tertiary></indexterm>

			<para>
				The <literal>on select</literal> clause performs a one-time, non-continuous query on a named window every time a triggering event arrives or a triggering pattern matches. The query can consider all events in the named window, or only events that match certain criteria, or events that correlate with an arriving event or a pattern of arriving events.
			</para>
			
			<para>
				The syntax for the <literal>on select</literal> clause is as follows: 
			</para>
			<synopsis>on <emphasis>event_type</emphasis>[<emphasis>(filter_criteria)</emphasis>] [as <emphasis>stream_name</emphasis>]
[insert into <emphasis>insert_into_def</emphasis>]
select <emphasis>select_list</emphasis>
from <emphasis>window_name</emphasis> [as <emphasis>stream_name</emphasis>]
[where <emphasis>criteria_expression</emphasis>]
[group by <emphasis>grouping_expression_list</emphasis>]
[having <emphasis>grouping_search_conditions</emphasis>]
[order by <emphasis>order_by_expression_list</emphasis>]
</synopsis>
				
			<para>
				The <emphasis>event_type</emphasis> is the name of the type of events that trigger the query against the named window. It is optionally followed by <emphasis>filter_criteria</emphasis> which are filter expressions to apply to arriving events. The optional <literal>as</literal> keyword can be used to assign an stream name. Patterns can also be specified in the <literal>on</literal> clause, see the samples in <xref linkend="named_delete_pattern"/>.
			</para>
				
			<para>
				The <emphasis>insert into</emphasis> clause works as described in <xref linkend="epl-insert-into"/>. The <emphasis>select</emphasis> clause is described in <xref linkend="epl-select-list"/>. For all clauses the semantics are equivalent to a join operation: The properties of the triggering event or events are available in the <literal>select</literal> clause and all other clauses.
			</para>

			<para>
				The <emphasis>window_name</emphasis> in the <literal>from</literal> clause is the name of the named window to select events from. The <literal>as</literal> keyword is also available to assign a stream name to the named window. The <literal>as</literal> keyword is helpful in conjunction with wildcard in the <literal>select</literal> clause to select named window events via the syntax <literal>select streamname.* </literal>.
			</para>
				
			<para>
				The optional <literal>where</literal> clause contains a <emphasis>criteria_expression</emphasis> that correlates the arriving (triggering) event to the events to be considered from the named window. The <emphasis>criteria_expression</emphasis> may also simply filter for events in the named window to be considered by the query.
			</para>

			<para>
				The <literal>group by</literal> clause, the <literal>having</literal> clause and the <literal>order by</literal> clause are all optional and work as described in earlier chapters.
			</para>

			<para>
				The similarities and differences between an <literal>on select</literal> clause and a regular or outer join are as follows: 
			</para>
		<orderedlist>
			<listitem>
				<para>
                    A join is evaluated when any of the streams participating in the join have new events (insert stream) or events leaving data windows (remove stream).  A join is therefore bi-directional or multi-directional. However, the <literal>on select</literal> statement has one triggering event or pattern that causes the query to be evaluated and is thus uni-directional.
                </para>
			</listitem>
			<listitem>
				<para>
					The query within the <literal>on select</literal> statement is not continuous: It executes only when a triggering event or pattern occurs. Aggregation and groups are computed anew considering the contents of the named window at the time the triggering event arrives.
                </para>
			</listitem>
		</orderedlist>

			<para>
				The <literal>iterator</literal> of the <literal>EPStatement</literal> object representing the <literal>on select</literal> clause returns the last batch of selected events in response to the last triggering event, or null if the last triggering event did not select any rows.
			</para>

			<para>
				For correlated queries that correlate triggering events with events held by a named window, Esper internally creates efficient indexes to enable high performance querying of events. It analyzes the <literal>where</literal> clause to build one or more indexes for fast lookup in the named window based on the properties of the triggering event.
			</para>

			<para>				
				The next statement demonstrates the concept. Upon arrival of a QueryEvent event the statement selects all events in the 'OrdersNamedWindow' named window:
			</para>
			<programlisting><![CDATA[on QueryEvent select win.* from OrdersNamedWindow as win]]></programlisting>
			
			<para>
				 The engine executes the query on arrival of a triggering event, in this case a QueryEvent. It posts the query results to any listeners to the statement, in a single invocation, as the new data array. By prefixing the wildcard (*) selector with the stream name, the <literal>select</literal> clause returns only events of the named window and does not also return triggering events.
			 </para>

			<para>
				The <literal>where</literal> clause filters and correlates events in the named window with the triggering event, as shown next: 
			</para>
			<programlisting><![CDATA[on QueryEvent(volume>0) as query
select query.symbol, query.volume, win.symbol  from OrdersNamedWindow as win
where win.symbol = query.symbol]]></programlisting>
			
			<para>
				 Upon arrival of a QueryEvent, if that event has a value for the volume property that is greater then zero, the engine executes the query. The query considers all events currently held by the 'OrdersNamedWindow' that match the symbol property value of the triggering QueryEvent event. The engine then posts query results to the statement's listeners.
			 </para>

			<para>
				Aggregation, grouping and ordering of results are possible as this example shows:
			</para>
			<programlisting><![CDATA[on QueryEvent as queryEvent
select symbol, sum(volume) from OrdersNamedWindow as win
group by symbol
having volume > 0
order by symbol]]></programlisting>
			
			<para>
				 The above statement outputs the total volume per symbol for those groups where the sum of the volume is greater then zero, ordered by symbol ascending. The engine computes and posts the output based on the current contents of the 'OrdersNamedWindow' named window considering all events in the named window, since the query does not have a <literal>where</literal> clause.
			 </para>

			<para>
				 When using wildcard (*) to select from streams in an on-select clause, each stream, that is the the triggering stream and the selected-upon named window, are selected, similar to a join. Therefore your wildcard select
				 returns two columns: the triggering event and the selection result event, for each row.
			</para>
			<programlisting><![CDATA[on QueryEvent as queryEvent
select * from OrdersNamedWindow as win]]></programlisting>
			
			<para>
				 The query above returns a <literal>queryEvent</literal> column and a <literal>win</literal> column for each event. If only a single stream's event is desired in the result, use <literal>select win.*</literal> instead.
			 </para>
		</sect2>

		<sect2 id="named_playback" revision="1">
			<title>Triggered Playback from Named Windows: the <literal>On Insert</literal> clause</title>
			
			<indexterm><primary>on-insert</primary></indexterm>
			<indexterm><primary>named window</primary><secondary>triggered playback using On Insert</secondary></indexterm>
			<indexterm><primary>EPL</primary><secondary>named window</secondary><tertiary>triggered playback using On Insert</tertiary></indexterm>

			<para>
				The <literal>on insert</literal> clause is an <literal>on select</literal> clause as described in the prior chapter with the addition of an <literal>insert into</literal> clause. 
			</para>

			<para>
				Similar to the <literal>on select</literal> clause, the engine executes the query when a triggering event arrives. It then provides the query results as an event stream to further statements. It populates the event stream that is named in the <literal>insert into</literal> clause.
			</para>

			<para>
				The statement below provides the query results to any consumers of the MyOrderStream, upon arrival of a QueryEvent event:
			</para>
			<programlisting><![CDATA[on QueryEvent as query
insert into MyOrderStream
select win.* from OrdersNamedWindow as win]]></programlisting>

			<para>
				Here is a sample consuming statement of the MyOrderStream. The statement further filters the events provided by the <literal>on insert</literal> statement by user id and reports a total of volume per symbol:
			</para>
			<programlisting><![CDATA[select symbol, sum(volume) from MyOrderStream(userId='user1') group by symbol]]></programlisting>
		</sect2>

		<sect2 id="named_populate_named" revision="1">
			<title>Populating a Named Window from an Existing Named Window</title>
			
			<indexterm><primary>create window, insert</primary></indexterm>
			<indexterm><primary>named window</primary><secondary>populating from a named window</secondary></indexterm>
			<indexterm><primary>EPL</primary><secondary>named window</secondary><tertiary>populating from a named window</tertiary></indexterm>
			<para>
				Your EPL statement may specify the name of an existing named window when creating a new named window, and may use the <literal>insert</literal> keyword to indicate that the new named window is to be populated from 
				the events currently held by the existing named window.
			</para>

			<para>
				For example, and assuming the named window <literal>OrdersNamedWindow</literal> already exists, this statement creates a new named window <literal>ScratchOrders</literal> and populates all orders in <literal>OrdersNamedWindow</literal> into the new named window:
			</para>
			<programlisting>create window ScratchOrders as OrdersNamedWindow insert</programlisting>

			<para>
				The <literal>where</literal> keyword is also available to perform filtering, for example:
			</para>
			<programlisting>create window ScratchBuyOrders as OrdersNamedWindow insert where side = 'buy'</programlisting>

		</sect2> 

		<sect2 id="named_update" revision="1">
			<title>Updating and Versioning Events in Named Windows</title>
			
			<indexterm><primary>update</primary></indexterm>
			<indexterm><primary>named window</primary><secondary>updating events</secondary></indexterm>

			<para>
				As outlined in <xref linkend="eventrep-update"/>, revision event types process updates or new versions of events held by a named window.
			</para>

			<para>
			    A revision event type is simply one or more existing event types whose events are related by event properties that provide same key values. The purpose of key values is to 
			    indicate that arriving events are related: An event amends, updates or adds properties to an earlier event that shares the same key values.
			</para>

			<para>
			    Revision event types can be useful in these situations:
			</para>
			<orderedlist spacing="compact">
				<listitem>
					<para>
						Some of your events carry only partial information that is related to a prior event.
					</para>
				</listitem>
				<listitem>
					<para>
						Events arrive that add additional properties or change existing properties of prior events.
					</para>
				</listitem>
				<listitem>
					<para>
						Events may carry properties that have null values or properties that do no exist (for example events backed by Map or XML), and for such properties the earlier value must be used instead.
					</para>
				</listitem>
			</orderedlist>

			<para>
			    To better illustrate, consider a revision event type that represents events for creation and updates to user profiles. Lets assume the user profile creation events carry the user id and a full profile. The profile update events indicate only the user id and the individual properties that actually changed. The user id property shall serve as a key value relating profile creation events and update events.
			</para>

			<para>
			    A revision event type must be configured to instruct the engine which event types participate and what their key properties are. Configuration is described in <xref linkend="config-revisionevent"/> and is not shown here.
			</para>
			
			<para>				
				Assume that an event type <literal>UserProfileRevisions</literal> has been configured to hold profile events, i.e. creation and update events related by user id. This statement creates a named window to hold the last 1 hour of current profiles per user id:
			</para>
			<programlisting><![CDATA[create window UserProfileWindow.win:time(1 hour) select * from UserProfileRevisions
insert into UserProfileWindow select * from UserProfileCreation
insert into UserProfileWindow select * from UserProfileUpdate]]></programlisting>

			<para>				
			    In revision event types, the term <emphasis>base</emphasis> event is used to describe events that are subject to update. Events that update, amend or add additional properties to base events are termed <emphasis>delta</emphasis> events. 
			    In the example, base events are profile creation events and delta events are profile update events. 
			</para>

			<para>				
			    Base events are expected to arrive before delta events. In the case where a delta event arrives and is not related by key value to a base event or a revision of the base event currently held by the named window the engine ignores the delta event. Thus, considering the example, profile update events for a user id that does not have an existing profile in the named window are not applied.
			</para>

			<para>
			    When a base or delta event arrives, the insert and remove stream output by the named window are the current and the prior version of the event. Let's come back to the example. As creation events arrive that are followed by update events or more creation events for the same user id, the engine posts the current version of the profile as insert stream (new data) and the prior version of the profile as remove stream (old data).
			</para>

			<para>				
			    Base events are also implicitly delta events. That is, if multiple base events of the same key property values arrive, then each base event provides a new version. In the example, if multiple profile creation events arrive for the same user id then new versions of the current profile for that user id are output by the engine for each base event, as it does for delta events.
			</para>

			<para>				
			    The expiry policy as specified by view definitions applies to each distinct key value, or multiple distinct key values for composite keys. An expiry policy re-evaluates when new versions arrive. In the example, user profile events expire from the time window when no creation or update event for a given user id has been received for 1 hour.
			</para>

			<para>				
			    Several strategies are available for merging or overlaying events as the configuration chapter describes in greater detail.
			</para>

			<para>				
			    Any of the Map, XML and JavaBean event representations as well as plug-in event representations may participate in a revision event type. For example, profile creation events could be JavaBean events, while profile update events could be <literal>java.util.Map</literal> events.
			</para>

			<para>				
			    Delta events may also add properties to the revision event type. For example, one could add a new event type with security information to the revision event type and such security-related properties become available on the resulting revision event type.
			</para>

			<para>
				The following restrictions apply to revision event types:
			</para>        
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Nested properties are only supported for the JavaBean event representation. Nested properties are not individually versioned; they are instead versioned by the containing property.
					</para>
				</listitem>
				<listitem>
					<para>
						Dynamic, indexed and mapped properties are only supported for nested properties and not as properties of the revision event type itself.
					</para>
				</listitem>
			</itemizedlist>

		</sect2>

	</sect1>
	
	<sect1 id="variables_overview" revision="1">
		<title>Variables</title>
		
		<indexterm><primary>variable</primary></indexterm>
		<indexterm><primary>EPL</primary><secondary>variable</secondary></indexterm>

		<para>
			A <emphasis>variable</emphasis> is a scalar value that is available for use in all statements including patterns. Variables can be used in an expression anywhere in a statement as well as in the <literal>output</literal> clause for output rate limiting.
		</para>
			
		<para>
			Variables must first be declared or configured before use, by defining each variable's type and name. Variables can be created via the <literal>create variable</literal> syntax or declared by configuration. Variables can be assigned new values by using the <literal>on set</literal> syntax or via the <literal>setVariableValue</literal> methods on <literal>EPRuntime</literal>. The <literal>EPRuntime</literal> also provides method to read variable values.
		</para>
			
		<para>
			 The engine guarantees consistency and atomicity of variable reads and writes on a statement-level (this is a soft guarantee, see below). Variables are optimized for fast read access and are also multithread-safe.
		</para>		
		
		<sect2 id="variable_create" revision="1">
			<title>Creating Variables: the <literal>Create Variable</literal> clause</title>

			<para>
				The <literal>create variable</literal> syntax creates a new variable by defining the variable type and name. In alternative to the syntax, variables can also be declared in the runtime and engine configuration options.
			</para>

			<para>
				The synopsis for creating a variable is as follows: 
			</para>
			<synopsis>create variable <emphasis>variable_type</emphasis> <emphasis>variable_name</emphasis> [ = <emphasis>assignment_expression</emphasis> ]</synopsis>
				
			<para>
				The <emphasis>variable_type</emphasis> can be any of the following:
			</para>
			<synopsis>variable_type
	:  string
	|  char 
	|  character
	|  bool 
	|  boolean
	|  byte
	|  short 
	|  int 
	|  integer 
	|  long 
	|  double
	|  float</synopsis>
				
			<para>
				The <emphasis>variable_name</emphasis> is an identifier that names the variable. The variable name should not already be in use by another variable.
			</para>
				
			<para>				
				The <literal>assignment_expression</literal> is optional. Without an assignment expression the initial value for the variable is <literal>null</literal>. If present, it supplies the initial value for the variable.
			</para>

			<para>
				The <literal>EPStatement</literal> object of the <literal>create variable</literal> statement provides access to variable values. The pull API methods <literal>iterator</literal> and <literal>safeIterator</literal> return the current variable value. Listeners to the 
				<literal>create variable</literal> statement subscribe to changes in variable value: the engine posts new and old value of the variable to all listeners when the variable value is updated by an <literal>on set</literal> statement.
			</para>

			<para>
				The example below creates a variable that provides a threshold value. The name of the variable is <literal>var_threshold</literal> and its type is <literal>long</literal>. The variable's initial value is <literal>null</literal> as no other value has been assigned:
			</para>
			<programlisting><![CDATA[create variable long var_threshold]]></programlisting>

			<para>
				This statement creates an integer-type variable named <literal>var_output_rate</literal> and initializes it to the value ten (10):
			</para>
			<programlisting><![CDATA[create variable integer var_output_rate = 10]]></programlisting>

			<para>
				In addition to creating a variable via the <literal>create variable</literal> syntax, the runtime and engine configuration API also allows adding variables. The next code snippet illustrates the
				use of the runtime configuration API to create a string-typed variable:
			</para>
			<programlisting><![CDATA[epService.getEPAdministrator().getConfiguration()
  .addVariable("myVar", String.class, "init value");]]></programlisting>

		</sect2>

		<sect2 id="variable_set" revision="1">
			<title>Setting Variable Values: the <literal>On Set</literal> clause</title>

			<para>
				The <literal>on set</literal> statement assigns a new value to one or more variables when a triggering event arrives or a triggering pattern occurs. Use the <literal>setVariableValue</literal> methods on <literal>EPRuntime</literal> to assign variable values programmatically.
			</para>

			<para>
				The synopsis for setting variable values is: 
			</para>
			<synopsis>on <emphasis>event_type</emphasis>[<emphasis>(filter_criteria)</emphasis>] [as <emphasis>stream_name</emphasis>]
  set <emphasis>variable_name</emphasis> = <emphasis>expression</emphasis> [, <emphasis>variable_name</emphasis> = <emphasis>expression</emphasis> [,...]]
</synopsis>
								
			<para>
				The <emphasis>event_type</emphasis> is the name of the type of events that trigger the variable assignments. It is optionally followed by <emphasis>filter_criteria</emphasis> which are filter expressions to apply to arriving events. The optional <literal>as</literal> keyword can be used to assign an stream name. Patterns can also be specified in the <literal>on</literal> clause.
			</para>
			
			<para>
				The comma-separated list of variable names and expressions set the value of one or more variables. All new variable values are applied atomically: the changes to variable values by the <literal>on set</literal> statement 
				become visible to other statements all at the same time. No changes are visible to other processing threads until the <literal>on set</literal> statement completed processing, and at that time all changes become visible at once.
			</para>

			<para>
				The <literal>EPStatement</literal> object provides access to variable values. The pull API methods <literal>iterator</literal> and <literal>safeIterator</literal> return the current variable values for each of the variables set by the statement. 
				Listeners to the statement subscribe to changes in variable values: the engine posts new variable values of all variables to any listeners.
			</para>

			<para>
				In the following example, a variable by name <literal>var_output_rate</literal> has been declared previously. When a NewOutputRateEvent event arrives, the variable is updated to a new value supplied by the event property 'rate':
			</para>
			<programlisting><![CDATA[on NewOutputRateEvent set var_output_rate = rate]]></programlisting>

			<para>
				The next example shows two variables that are updated when a ThresholdUpdateEvent arrives:
			</para>
			<programlisting><![CDATA[on ThresholdUpdateEvent as t 
  set var_threshold_lower = t.lower,
      var_threshold_higher = t.higher]]></programlisting>

			<para>
				The sample statement shown next counts the number of pattern matches using a variable. The pattern looks for OrderEvent events that are followed by CancelEvent events for the same order id within 10 seconds of the OrderEvent:
			</para>
			<programlisting><![CDATA[on pattern[every a=OrderEvent -> (CancelEvent(orderId=a.orderId) where timer:within(10 sec))]
  set var_counter = var_counter + 1]]></programlisting>
		</sect2>

		<sect2 id="variable_using" revision="1">
			<title>Using Variables</title>

			<para>
				A variable name can be used in any expression and can also occur in an output rate limiting clause. This section presents examples and discusses performance, consistency and atomicity attributes of variables.
			</para>

			<para>
				The next statement assumes that a variable named 'var_threshold' was created to hold a total price threshold value. 
				The statement outputs an event when the total price for a symbol is greater then the current threshold value:
			</para>
			<programlisting><![CDATA[select symbol, sum(price) from TickEvent 
group by symbol 
having sum(price) > var_threshold]]></programlisting>

			<para>
				In this example we use a variable to dynamically change the output rate on-the-fly. The variable 'var_output_rate' holds the current rate at which the statement posts a current count to listeners:
			</para>
			<programlisting><![CDATA[select count(*) from TickEvent output every var_output_rate seconds]]></programlisting>
			
			<para>
				Variables are optimized towards high read frequency and lower write frequency. Variable reads do not incur locking overhead (99% of the time) while variable writes do incur locking overhead. 
			</para>
				
			<para>
				The engine softly guarantees consistency and atomicity of variables when your statement executes in response to an event or timer invocation. Variables acquire a stable value (implemented by versioning) when your statement starts executing in response to an event or timer invocation, and variables do not change value during execution. When one or more variable values are updated via <literal>on set</literal> statements, the changes to all updated variables become visible to statements as one unit and only when the <literal>on set</literal> statement completes successfully.
			</para>

			<para>
				The atomicity and consistency guarantee is a soft guarantee. If any of your application statements, in response to an event or timer invocation, execute for a time interval longer then 15 seconds (default interval length), then the engine may use current variable values after 15 seconds passed, rather then then-current variable values at the time the statement started executing in response to an event or timer invocation.				
			</para>

			<para>
				The length of the time interval that variable values are held stable for the duration of execution of a given statement is by default 15 seconds, but can be configured via engine default settings.
			</para>
		</sect2>
	</sect1>		

	<sect1 id="epl-containedeventselect">
	   <title>Contained-Event Selection</title>
	   
		<para>
			Contained-event selection is for use when an event contains properties that are themselves events. For example when application events are coarse-grained structures and you need to perform bulk operations on the rows of the property graph in an event.
		</para>

		<para>
			Use the contained-event selection syntax in a filter expression such as in a pattern, <literal>from</literal> clause, subselect, on-select and on-delete. This section provides the synopsis and examples.
		</para>

		<para>
			To review, in the <literal>from</literal> clause a <emphasis>contained_selection</emphasis> may appear after the event stream name and filter criteria, and before any view specifications.
		</para>

		<para>
			The synopsis for <emphasis>contained_selection</emphasis> is as follows:
		</para>
		<synopsis>[select <emphasis>select_expressions</emphasis> from] <emphasis>property_expression</emphasis> [as <emphasis>property_alias</emphasis>] [where <emphasis>filter_expression</emphasis>]</synopsis>

		<para>
			The <literal>select</literal> clause and <emphasis>select_expressions</emphasis> are optional and may be used to select specific properties.
		</para>

		<para>
			The <emphasis>property_expression</emphasis> is required and must be a valid property name that returns an event fragment, i.e. a property that can itself be represented as an event by the underlying event representation. Simple values such as integer or string are not fragments.
		</para>
		
		<para>
			The <emphasis>property_alias</emphasis> can be provided to assign a name to the property expression.
		</para>

		<para>
			The <literal>where</literal> clause and <emphasis>filter_expression</emphasis> is optional and may be used to filter out properties.
		</para>

		<para>
			As an example event, consider a media order. A media order consists of order items as well as product descriptions. A media order event can be represented as an object graph (POJO event representation), or a structure of nested Maps (Map event representation) or a XML document (XML DOM or Axiom event representation) or other custom plug-in event representation.
		</para>

		<para>
			To illustrate, a sample media order event in XML event representation is shown below. Also, a XML event type can optionally be strongly-typed with an explicit XML XSD schema that we don't show here. Note that Map and POJO representation can be considered equivalent for the purpose of this example.
		</para>

		<para>
			Let us now assume that we have declared the event type <literal>MediaOrder</literal> as being represented by the root node <literal>&lt;mediaorder&gt;</literal> of such XML snip:
		</para>

	<programlisting><![CDATA[<mediaorder>
  <orderId>PO200901</orderId>
  <items>
    <item>
      <itemId>100001</itemId>
      <productId>B001</productId>
      <amount>10</amount>
      <price>11.95</price>
    </item>
  </items>
  <books>
    <book>
      <bookId>B001</bookId>
      <author>Heinlein</author>
      <review>
        <reviewId>1</reviewId>
        <comment>best book ever</comment>
      </review>
    </book>
    <book>
      <bookId>B002</bookId>
      <author>Isaac Asimov</author>
    </book>
  </books>
</mediaorder>]]></programlisting>

		<para>
			The next query utilizes the contained-event selection syntax to return each book:
		</para>
		<programlisting><![CDATA[select * from MediaOrder[books.book]]]></programlisting>

		<para>
			The result of the above query is one event per book. Output events contain only the book properties and not any of the mediaorder-level properties.
		</para>

		<para>
			Note that, when using listeners, the engine delivers multiple results in one invocation of each listener. Therefore listeners to the above statement can expect a single invocation passing all book events within one media order event as an array.
		</para>
		
		<para>
			 To better illustrate the position of the contained-event selection syntax in a statement, consider the next two queries:
		</para>
		<programlisting><![CDATA[select * from MediaOrder(orderId='PO200901')[books.book]]]></programlisting>

		<para>
			The above query the returns each book only for media orders with a given order id. This query illustrates a contained-event selection and a view: 
		</para>
		<programlisting><![CDATA[select count(*) from MediaOrder[books.book].std:unique(bookId)]]></programlisting>
		
		<para>
			The sample above counts each book unique by book id.
		</para>

		<para>
			Contained-event selection can be staggered. When staggering multiple contained-event selections the staggered contained-event selection is relative to its parent.
		</para>

		<para>
			This example demonstrates staggering contained-event selections by selecting each review of each book:
		</para>
		<programlisting><![CDATA[select * from MediaOrder[books.book][review]]]></programlisting>

		<para>
			Listeners to the query above receive a row for each review of each book. Output events contain only the review properties and not the book or media order properties.
		</para>
		
		<para>
			The following is not valid:
		</para>
		<programlisting><![CDATA[// not valid
select * from MediaOrder[books.book.review]]]></programlisting>

		<para>
			The <literal>book</literal> property in an indexed property (an array or collection) and thereby requires an index in order to determine which book to use. The expression <literal>books.book[1].review</literal> is valid and means all reviews of the second (index 1) book.
		</para>
		
		<para>
			The contained-event selection syntax is part of the filter expression and may therefore occur in patterns and anywhere a filter expression is valid. 
		</para>

		<para>
			A pattern example is below. The example assumes that a <literal>Cancel</literal> event type has been defined that also has an <literal>orderId</literal> property:
		</para>
		<programlisting>select * from pattern [c=Cancel -&gt; books=MediaOrder(orderId = c.orderId)[books.book] ]</programlisting>
	
		<para>
			When used in a pattern, a filter with a contained-event selection returns an array of events, similar to the match-until clause in patterns. The above statement returns, in the <literal>books</literal> property, an
			array of book events.
		</para>

		<sect2 id="epl-containedeventselect-select" revision="1">
			<title>Select Clause in a Contained-Event Selection</title>

			<para>
				 The optional <literal>select</literal> clause provides control over which fields are available in output events. The expressions in the select clause apply only to the properties available underneath the property in the <literal>from</literal> clause, and the properties of the enclosing event.
			</para>

			<para>
				 When no <literal>select</literal> is specified, only the properties underneath the selected property are available in output events.
			</para>

			<para>
				 In summary, the <literal>select</literal> clause may contain:
			</para>

			<orderedlist spacing="compact">
				<listitem>
					<para>
						Any expressions, wherein properties are resolved relative to the property in the <literal>from</literal> clause.
					</para>
				</listitem>
				<listitem>
					<para>
						Use the wildcard (<literal>*</literal>) to provide all properties that exist under the property in the <literal>from</literal> clause.
					</para>
				</listitem>
				<listitem>
					<para>
						Use the <emphasis>property_alias</emphasis><literal>.*</literal> syntax to provide all properties that exist under a property in the <literal>from</literal> clause.
					</para>
				</listitem>
			</orderedlist>

			<para>
				The next query's <literal>select</literal> clause selects each review for each book, and the order id as well as the book id of each book:
			</para>
			<programlisting><![CDATA[select * from MediaOrder[select orderId, bookId from books.book][select * from review]
// ... equivalent to ...
select * from MediaOrder[select orderId, bookId from books.book][review]]]]></programlisting>
	
			<para>
				Listeners to the statement above receive an event for each review of each book. Each output event has all properties of the review row, and in addition the <literal>bookId</literal> of each book and the <literal>orderId</literal> of the order.
				Thus <literal>bookId</literal> and <literal>orderId</literal> are found in each result event, duplicated when there are multiple reviews per book and order.
			</para>

			<para>
				 The above query uses wildcard <literal>(*)</literal> to select all properties from reviews. As has been discussed as part of the <literal>select</literal> clause, the wildcard (<literal>*</literal>) and <emphasis>property_alias</emphasis><literal>.*</literal> do not copy properties for performance reasons. The wildcard syntax instead specifies the underlying type, and additional properties are added onto that underlying type if required. Only one wildcard (<literal>*</literal>) and <emphasis>property_alias</emphasis><literal>.*</literal> (unless used with a column rename) may therefore occur in the <literal>select</literal> clause list of expressions.
			</para>

			<para>
				All the following queries produce an output event for each review of each book. The next sample queries illustrate the options available to control the fields of output events.
			</para>

			<para>
				The output events produced by the next query have all properties of each review and no other properties available:
			</para>
			<programlisting><![CDATA[select * from MediaOrder[books.book][review]]]></programlisting>

			<para>
				The following query is not a valid query, since the order id and book id are not part of the contained-event selection:
			</para>
			<programlisting><![CDATA[// Invalid select clause: orderId and bookId not produced.
select orderId, bookId from MediaOrder[books.book][review]]]></programlisting>

			<para>
				This query is valid. Note that output events carry only the <literal>orderId</literal> and <literal>bookId</literal> properties and no other data:
			</para>
			<programlisting><![CDATA[select orderId, bookId from MediaOrder[books.book][select orderId, bookId from review]
//... equivalent to ...
select * from MediaOrder[select orderId, bookId from books.book][review]]]></programlisting>

			<para>
				This variation produces output events that have all properties of each book and only <literal>reviewId</literal> and <literal>comment</literal> for each review:
			</para>
			<programlisting><![CDATA[select * from MediaOrder[select * from books.book][select reviewId, comment from review]
// ... equivalent to ...
select * from MediaOrder[books.book as book][select book.*, reviewId, comment from review]]]></programlisting>
	
			<para>
				The output events of the next EPL have all properties of the order and only <literal>bookId</literal> and <literal>reviewId</literal> for each review:
			</para>
			<programlisting><![CDATA[select * from MediaOrder[books.book as book]
    [select mediaOrder.*, bookId, reviewId from review] as mediaOrder]]></programlisting>

			<para>
				This EPL produces output events with 3 columns: a column named <literal>mediaOrder</literal> that is the order itself, a column named <literal>book</literal> for each book and a column named <literal>review</literal> that holds each review:
			</para>
			<programlisting><![CDATA[insert into ReviewStream select * from MediaOrder[books.book as book]
  [select mo.* as mediaOrder, book.* as book, review.* as review from review as review] as mo
// .. and a sample consumer of ReviewStream...
select mediaOrder.orderId, book.bookId, review.reviewId from ReviewStream]]></programlisting>

			<para>
				Please note these limitations:
			</para>
			<orderedlist spacing="compact">
				<listitem>
					<para>
						Sub-selects, aggregation functions and the <literal>prev</literal> and <literal>prior</literal> operators are not available in contained-event selection.
					</para>
				</listitem>
				<listitem>
					<para>
						Expressions in the <literal>select</literal> and <literal>where</literal> clause of a contained-event selection can only reference properties relative to the current event and property.
					</para>
				</listitem>
			</orderedlist>

		</sect2>
	
		<sect2 id="epl-containedeventselect-where" revision="1">
			<title>Where Clause in a Contained-Event Selection</title>
			<para>
				The optional <literal>where</literal> clause may be used to filter out properties at the same level that the where-clause occurs.
			</para>
			
			<para>
				The properties in the filter expression must be relative to the property in the <literal>from</literal> clause or the enclosing event.
			</para>

			<para>
				This query outputs all books with a given author:
			</para>
			<programlisting><![CDATA[select * from MediaOrder[books.book where author = 'Heinlein']]]></programlisting>
	
			<para>
				This query outputs each review of each book where a review comment contains the word 'good':
			</para>
			<programlisting><![CDATA[select * from MediaOrder[books.book][review where comment like 'good']]]></programlisting>
	
		</sect2>

		<sect2 id="epl-containedeventselect-join" revision="1">
			<title>Contained-Event Selection and Joins</title>
			<para>
				This section discusses contained-event selection in joins.
			</para>

			<para>
				When joining within the same event it is not required that views are specified. Recall, in a join or outer join there must be views specified that hold the data to be joined. For self-joins, no views are required and the join
				executes against the data returned by the same event.
			</para>
			
			<para>
				This query inner-joins items to books where book id matches the product id:
			</para>
			<programlisting><![CDATA[select book.bookId, item.itemId 
from MediaOrder[books.book] as book, 
      MediaOrder[items.item] as item 
where productId = bookId]]></programlisting>

			<para>
				Query results for the above query when sending the media order event as shown earlier are:
			</para>

			<informaltable frame="topbot">
				<tgroup cols="2">
					<colspec colwidth="1*"/>
					<colspec colwidth="1*"/>
					<thead>
						<row>
							<entry>book.bookId</entry>
							<entry>item.itemId</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>B001</entry>
							<entry>100001</entry>
						</row>
					</tbody>
				</tgroup>				
			</informaltable>

			<para>
				The next example query is a left outer join. It returns all books and their items, and for books without item it returns the book and a <literal>null</literal> value:
			</para>

			<programlisting><![CDATA[select book.bookId, item.itemId 
from MediaOrder[books.book] as book 
  left outer join 
    MediaOrder[items.item] as item 
  on productId = bookId]]></programlisting>

			<para>
				Query results for the above query when sending the media order event as shown earlier are:
			</para>

			<informaltable frame="topbot">
				<tgroup cols="2">
					<colspec colwidth="1*"/>
					<colspec colwidth="1*"/>
					<thead>
						<row>
							<entry>book.bookId</entry>
							<entry>item.itemId</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>B001</entry>
							<entry>100001</entry>
						</row>
						<row>
							<entry>B002</entry>
							<entry>null</entry>
						</row>
					</tbody>
				</tgroup>				
			</informaltable>

			<para>
				A full outer join combines the results of both left and right outer joins. The joined table will contain all records from both tables, and fill in <literal>null</literal> values for missing matches on either side.
			</para>

			<para>
				This example query is a full outer join, returning all books as well as all items, and filling in <literal>null</literal> values for book id or item id if no match is found:
			</para>
			
			<programlisting><![CDATA[select orderId, book.bookId,item.itemId 
from MediaOrder[books.book] as book 
  full outer join 
     MediaOrder[select orderId, * from items.item] as item 
  on productId = bookId 
order by bookId, item.itemId asc
]]></programlisting>

			<para>
				As in all other continuous queries, aggregation results are cumulative from the time the statement was created.
			</para>
			
			<para>
				The following query counts the cumulative number of items in which the product id matches a book id:
			</para>

			<programlisting><![CDATA[select count(*) 
from MediaOrder[books.book] as book, 
      MediaOrder[items.item] as item 
where productId = bookId]]></programlisting>

			<para>
				The <literal>unidirectional</literal> keyword in a join indicates to the query engine that aggregation state is not cumulative. The next query counts the number of items in which the product id matches a book id for each event:
			</para>
			
			<programlisting><![CDATA[select count(*) 
from MediaOrder[books.book] as book unidirectional, 
      MediaOrder[items.item] as item 
where productId = bookId]]></programlisting>

		</sect2>

	</sect1>
</chapter>
