<chapter id="outputmodel">

    <title>Understanding the Output Model</title>

    <sect1 id="outputmodel_intro" revision="1">
        <title>Introduction</title>
        
        <para>
			The Esper output model is continuous:  Update listeners to statements receive updated data as soon as the engine processes events for that statement, according to the statement's choice of event streams, views, filters and output rates.
        </para>
			
        <para>
			As outlined in <xref linkend="api"/> the interface for listeners is <literal>net.esper.client.UpdateListener</literal>. Implementations must provide a single <literal>update</literal> method that the engine invokes when results become available:
        </para>
        
		<mediaobject>
			<imageobject role="fo">
				<imagedata fileref="images/refdoc_outputmodel_updatelistener.gif" format="GIF" align="center"/>
			</imageobject>
			<imageobject role="html">
				<imagedata fileref="../shared/images/refdoc_outputmodel_updatelistener.gif" format="GIF" align="center"/>
			</imageobject>
		</mediaobject>

        <para>
			The engine provides statement results to update listeners by placing results in <literal>net.esper.event.EventBean</literal> instances. A typical listener implementation queries the <literal>EventBean</literal> instances via getter methods to obtain the statement-generated results. 
        </para>

		<mediaobject>
			<imageobject role="fo">
				<imagedata fileref="images/refdoc_outputmodel_eventbean.gif" format="GIF" align="center"/>
			</imageobject>
			<imageobject role="html">
				<imagedata fileref="../shared/images/refdoc_outputmodel_eventbean.gif" format="GIF" align="center"/>
			</imageobject>
		</mediaobject>

        <para>
			The <literal>get</literal> method on the <literal>EventBean</literal> interface can be used to retrieve result columns by name. The property name supplied to the <literal>get</literal> method can also be used to query nested, indexed or array properties of object graphs as discussed in more detail in <xref linkend="event_representation"/>. 
        </para>

        <para>
			The <literal>getUnderlying</literal> method on the <literal>EventBean</literal> interface allows update listeners to obtain the underlying event object. For wildcard selects, the underlying event is the event object that was sent into the engine via the <literal>sendEvent</literal> method. 
			For joins and select clauses with expressions, the underlying object implements <literal>java.util.Map</literal>.
        </para>

	</sect1>
	
    <sect1 id="outputmodel_nowindow" revision="1">
        <title>Insert Stream</title>
        <para>
			In this section we look at the output of a very simple EQL statement. The statement selects an event stream without using a data window and without applying any filtering, as follows:
        </para>
        
        <programlisting><![CDATA[select * from Withdrawal]]></programlisting>

        <para>
			This statement selects all <literal>Withdrawal</literal> events. Every time the engine processes an event of type <literal>Withdrawal</literal> or any sub-type of <literal>Withdrawal</literal>, it invokes all update listeners, handing the new event to each of the statement's listeners.
        </para>
        
        <para>
			The term <emphasis>insert stream</emphasis> denotes the new events arriving, and entering a data window or aggregation. The insert stream in this example is the stream of arriving Withdrawal events, and is posted to listeners as new events.
        </para>
        
        <para>
			The diagram below shows a series of Withdrawal events 1 to 6 arriving over time. The number in parenthesis is the withdrawal amount, an event property that is used in the examples that discuss filtering. 
        </para>

        <figure id="outputmodel_nowindow_flow">
			<title>Output  example for a simple statement</title>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/refdoc_outputmodel_nowindow.gif" format="GIF" align="center"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="../shared/images/refdoc_outputmodel_nowindow.gif" format="GIF" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>

        <para>
			The example statement above results in only new events and no old events posted by the engine to the statement's listeners.
        </para>
    </sect1>

    <sect1 id="outputmodel_lengthwindow" revision="1">
        <title>Insert and Remove Stream</title>
        <para>
			A length window instructs the engine to only keep the last N events for a stream. The next statement applies a length window onto the Withdrawal event stream. The statement serves to illustrate the concept of data window and events entering and leaving a data window:
        </para>
        
        <programlisting><![CDATA[select * from Withdrawal.win:length(5)]]></programlisting>

        <para>
			The size of this statement's length window is five events. The engine enters all arriving Withdrawal events into the length window. When the length window is full, the oldest Withdrawal event is pushed out the window. The engine indicates to listeners all events entering the window as new events, and all events leaving the window as old events. 
        </para>

        <para>
			While the term <emphasis>insert stream</emphasis> denotes new events arriving, the term <emphasis>remove stream</emphasis> denotes events leaving a data window, or changing aggregation values. In this example, the remove stream is the stream of Withdrawal events that leave the length window, and such events are posted to listeners as old events. 
        </para>

        <para>
			The next diagram illustrates how the length window contents change as events arrive and shows the events posted to an update listener.
        </para>

        <figure id="outputmodel_lengthwindow_flow">
			<title>Output  example for a length window</title>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/refdoc_outputmodel_lengthwindow.gif" format="GIF" align="center"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="../shared/images/refdoc_outputmodel_lengthwindow.gif" format="GIF" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>

        <para>
			As before, all arriving events are posted as new events to listeners. In addition, when event W<subscript>1</subscript> leaves the length window on arrival of event W<subscript>6</subscript>, it is posted as an old event to listeners.
        </para>

        <para>
			Similar to a length window, a time window also keeps the most recent events up to a given time period. A time window of 5 seconds, for example, keeps the last 5 seconds of events. As seconds pass, the time window actively pushes the oldest events out of the window resulting in one or more old events posted to update listeners.
        </para>

        <para>
			Note EQL supports optional <literal>istream</literal> and <literal>rstream</literal> keywords on select-clauses and on insert-into clauses. These instruct the engine to only forward events that enter or leave data windows, or select only current or prior aggregation values, i.e. the insert stream or the remove stream.
        </para>

    </sect1>

    <sect1 id="outputmodel_filter" revision="1">
        <title>Filters and Where-clauses</title>
        <para>
			Filters to event streams allow filtering events out of a given stream before events enter a data window. The statement below shows a filter that selects Withdrawal events with an amount value of 200 or more.
        </para>
        
        <programlisting><![CDATA[select * from Withdrawal(amount>=200).win:length(5)]]></programlisting>

        <para>
			With the filter, any Withdrawal events that have an amount of less then 200 do not enter the length window and are therefore not passed to update listeners. Filters are discussed in more details in <xref linkend="pattern-filter"/>.
        </para>

        <figure id="outputmodel_filter_flow">
			<title>Output example for a statement with an event stream filter</title>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/refdoc_outputmodel_filter.gif" format="GIF" align="center"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="../shared/images/refdoc_outputmodel_filter.gif" format="GIF" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>
        
        <para>
			The where-clause and having-clause in statements eliminate potential result rows at a later stage in processing, after events have been processed into a statement's data window or other views.
        </para>

        <para>
			The next statement applies a where-clause to Withdrawal events. Where-clauses are discussed in more detail in <xref linkend="eql-where-clause"/>.
        </para>

        <programlisting><![CDATA[select * from Withdrawal.win:length(5) where amount >= 200]]></programlisting>

        <para>
			The where-clause applies to both new events and old events. As the diagram below shows, arriving events enter the window however only events that pass the where-clause are handed to update listeners. Also,
			as events leave the data window, only those events that pass the conditions in the where-clause are posted to listeners as old events.
        </para>

        <figure id="outputmodel_where">
			<title>Output example for a statement with where-clause</title>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/refdoc_outputmodel_where.gif" format="GIF" align="center"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="../shared/images/refdoc_outputmodel_where.gif" format="GIF" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>

        <para>
			The where-clause can contain complex conditions while event stream filters are more restrictive in the type of filters that can be specified. The next statement's where-clause applies the <literal>ceil</literal> function of the <literal>java.lang.Math</literal> Java library class in the where clause. The insert-into clause makes the results of the first statement available to the second statement:
        </para>
        <programlisting><![CDATA[insert into WithdrawalFiltered select * from Withdrawal where Math.ceil(amount) >= 200

select * from WithdrawalFiltered]]></programlisting>
    </sect1>

    <sect1 id="outputmodel_aggregation" revision="1">
        <title>Aggregation</title>
        <para>
			Statements that aggregate events via aggregations functions also post remove stream events as aggregated values change.
        </para>

        <para>
			Consider the following statement that alerts when 2 Withdrawal events have been received:
        </para>
        
        <programlisting><![CDATA[select count(*) as mycount from Withdrawal having count(*) = 2]]></programlisting>

        <para>
	        When the engine encounters the second withdrawal event, the engine posts a new event to update listeners. The value of the "mycount" property on that new event is 2.
	        Additionally, when the engine encounters the third Withdrawal event, it posts an old event to update listeners containing the prior value of the count. The value of the "mycount" property on that old event is also 2.
        </para>

        <para>
	        The <literal>istream</literal> or <literal>rstream</literal> keyword can be used to eliminate either new events or old events posted to listeners. The next statement uses the <literal>istream</literal> keyword causing the engine to call the listener only once when the second Withdrawal event is received:
        </para>
        <programlisting><![CDATA[select istream count(*) as mycount from Withdrawal having count(*) = 2]]></programlisting>
    </sect1>
    
    <sect1 id="outputmodel_time_window" revision="1">
        <title>Time Windows</title>
        
        <para>
			In this section we explain the output model of statements employing a time window view and a time batch view.
        </para>

		<sect2 id="outputmodel_time_window_1" revision="1">
			<title>Time Window</title>

			<para>
				A time window is a moving window extending to the specified time interval into the past based on the system time. Time windows enable us to limit the number of events considered by a query, as do length windows. 
			</para>
			
			<para>
				As a practical example, consider the need to determine all accounts where the average withdrawal amount per account for the last 4 seconds of withdrawals is greater then 1000. The statement to solve this problem is shown below.
			</para>

			<programlisting><![CDATA[select account, avg(amount) 
from Withdrawal.win:time(4 sec) 
group by account
having amount > 1000]]></programlisting>
	
			<para>
				The next diagram serves to illustrate the functioning of a time window. For the diagram, we assume a query that simply selects the event itself and does not group or filter events.
			</para>

			<programlisting><![CDATA[select * from Withdrawal.win:time(4 sec)]]></programlisting>

			<para>
				The diagram starts at a given time <literal>t</literal> and displays the contents of the time window at <literal>t + 4</literal> and <literal>t + 5 seconds</literal> and so on.
			</para>

			<figure id="outputmodel_timewindow_flow">
				<title>Output example for a statement with a time window</title>
				<mediaobject>
					<imageobject role="fo">
						<imagedata fileref="images/refdoc_outputmodel_timewindow.gif" format="GIF" align="center"/>
					</imageobject>
					<imageobject role="html">
						<imagedata fileref="../shared/images/refdoc_outputmodel_timewindow.gif" format="GIF" align="center"/>
					</imageobject>
				</mediaobject>
			</figure>
	
			<para>
				The activity as illustrated by the diagram:
			</para>
			
			<orderedlist>
				<listitem>
					<para>
						At time <literal>t + 4 seconds</literal> an event <literal>W<subscript>1</subscript></literal> arrives and enters the time window. The engine reports the new event to update listeners.
					</para>
				</listitem>
				<listitem>
					<para>
						At time <literal>t + 5 seconds</literal> an event <literal>W<subscript>2</subscript></literal> arrives and enters the time window. The engine reports the new event to update listeners.
					</para>
				</listitem>
				<listitem>
					<para>
						At time <literal>t + 6.5 seconds</literal> an event <literal>W<subscript>3</subscript></literal> arrives and enters the time window. The engine reports the new event to update listeners.
					</para>
				</listitem>
				<listitem>
					<para>
						At time <literal>t + 8 seconds</literal> event <literal>W<subscript>1</subscript></literal> leaves the time window. The engine reports the event as an old event to update listeners.
					</para>
				</listitem>
			</orderedlist>

		</sect2>
        
		<sect2 id="outputmodel_time_batch_1" revision="1">
			<title>Time Batch</title>

			<para>
				The time batch view buffers events and releases them every specified time interval in one update. Time windows control the evaluation of events, as does the length batch window. 
			</para>
			
			<para>
				The next diagram serves to illustrate the functioning of a time batch view. For the diagram, we assume a simple query as below:
			</para>

			<programlisting><![CDATA[select * from Withdrawal.win:time_batch(4 sec)]]></programlisting>

			<para>
				The diagram starts at a given time <literal>t</literal> and displays the contents of the time window at <literal>t + 4</literal> and <literal>t + 5 seconds</literal> and so on.
			</para>

			<figure id="outputmodel_timebatch_flow">
				<title>Output example for a statement with a time batch view</title>
				<mediaobject>
					<imageobject role="fo">
						<imagedata fileref="images/refdoc_outputmodel_timebatch.gif" format="GIF" align="center"/>
					</imageobject>
					<imageobject role="html">
						<imagedata fileref="../shared/images/refdoc_outputmodel_timebatch.gif" format="GIF" align="center"/>
					</imageobject>
				</mediaobject>
			</figure>
	
			<para>
				The activity as illustrated by the diagram:
			</para>
			
			<orderedlist>
				<listitem>
					<para>
						At time <literal>t + 1 seconds</literal> an event <literal>W<subscript>1</subscript></literal> arrives and enters the batch. No call to inform update listeners occurs.
					</para>
				</listitem>
				<listitem>
					<para>
						At time <literal>t + 3 seconds</literal> an event <literal>W<subscript>2</subscript></literal> arrives and enters the batch. No call to inform update listeners occurs.
					</para>
				</listitem>
				<listitem>
					<para>
						At time <literal>t + 4 seconds</literal> the engine processes the batched events and a starts a new batch. The engine reports events <literal>W<subscript>1</subscript></literal> and <literal>W<subscript>2</subscript></literal> to update listeners.
					</para>
				</listitem>
				<listitem>
					<para>
						At time <literal>t + 6.5 seconds</literal> an event <literal>W<subscript>3</subscript></literal> arrives and enters the batch. No call to inform update listeners occurs.
					</para>
				</listitem>
				<listitem>
					<para>
						At time <literal>t + 8 seconds</literal> the engine processes the batched events and a starts a new batch. The engine reports the event <literal>W<subscript>3</subscript></literal> as new data to update listeners. The engine reports the events <literal>W<subscript>1</subscript></literal> and <literal>W<subscript>2</subscript></literal> as old data (prior batch) to update listeners.
					</para>
				</listitem>
			</orderedlist>

		</sect2>

    </sect1>

    <sect1 id="outputmodel_eventbean" revision="1">
        <title><literal>EventBean</literal> Query Results</title>
        
        <para>
			The engine posts events to <literal>UpdateListener</literal> implementations as <literal>net.esper.event.EventBean</literal> instances. The <literal>EventBean</literal> represents a row (event) in your continuous query's result set.  
        </para>
			
        <para>
			Use the <literal>iterator</literal> method on <literal>EPStatement</literal> statements to poll or read data out of statements, if your require read-based access to statement result sets. Statement iterators also return <literal>EventBean</literal> instances.
        </para>

        <para>
			The <literal>EventBean</literal> interface offers property type metadata via the <literal>getEventType</literal> method. The <literal>EventType</literal> offers a rich set of property name, property type and underlying type information. This information can be useful to dynamically interrogate query results.
        </para>

        <para>
			Consider a statement that returns the symbol, count of events per symbol and average price per symbol for tick events. Our sample statement may declare a fully-qualified Java class name as the event type: <literal>org.sample.StockTickEvent</literal>. Assume that this class exists and exposes a <literal>symbol</literal> property of type String, and a <literal>price</literal> property of type double.
        </para>
		<programlisting><![CDATA[select symbol, avg(price) as avgprice, count(*) as mycount 
from org.sample.StockTickEvent 
group by symbol]]></programlisting>

        <para>
			The next table summarized the property names and types as posted by the statement above:
        </para>
        
		<table frame="topbot">
			<title>Properties offered by sample statement</title>
			<tgroup cols="4">
				<colspec colwidth="1*"/>
				<colspec colwidth="1*"/>
				<colspec colwidth="2*"/>
				<colspec colwidth="2*"/>
				<thead>
					<row>
						<entry>Name</entry>
						<entry>Type</entry>
						<entry>Description</entry>
						<entry>Java code snippet</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry><literal>symbol</literal></entry>
						<entry>String</entry>
						<entry>Value of symbol event property</entry>
						<entry><synopsis>eventBean.get("symbol")</synopsis></entry>
					</row>
					<row>
						<entry><literal>avgprice</literal></entry>
						<entry>Double</entry>
						<entry>Average price per symbol</entry>
						<entry><synopsis>eventBean.get("avgprice")</synopsis></entry>
					</row>
					<row>
						<entry><literal>mycount</literal></entry>
						<entry>Long</entry>
						<entry>Number of events per symbol</entry>
						<entry><synopsis>eventBean.get("mycount")</synopsis></entry>
					</row>
				</tbody>
			</tgroup>
		</table> 
        
        <para>
			The engine supplies the boxed <literal>java.lang.Double</literal> and <literal>java.lang.Long</literal> types as property values rather then primitive Java types. This is because aggregated values can return a <literal>null</literal> value to indicate that no data is available for aggregation. 
        </para>

		<!-- underlying type and primitive types -->
		
        <para>
			Consider a second statement that specifies a wildcard-select:
        </para>
		<programlisting><![CDATA[select * from org.sample.StockTickEvent where price > 100]]></programlisting>

        <para>
			The next table summarized the property names and types as posted by the statement above:
        </para>
        
		<table frame="topbot">
			<title>Properties offered by sample statement</title>
			<tgroup cols="4">
				<colspec colwidth="1*"/>
				<colspec colwidth="1*"/>
				<colspec colwidth="2*"/>
				<colspec colwidth="2*"/>
				<thead>
					<row>
						<entry>Name</entry>
						<entry>Type</entry>
						<entry>Description</entry>
						<entry>Java code snippet</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry><literal>symbol</literal></entry>
						<entry>String</entry>
						<entry>Value of symbol event property</entry>
						<entry><synopsis>eventBean.get("symbol")</synopsis></entry>
					</row>
					<row>
						<entry><literal>avgprice</literal></entry>
						<entry>Double</entry>
						<entry>Average price per symbol</entry>
						<entry><synopsis>eventBean.get("avgprice")</synopsis></entry>
					</row>
					<row>
						<entry><literal>mycount</literal></entry>
						<entry>Long</entry>
						<entry>Number of events per symbol</entry>
						<entry><synopsis>eventBean.get("mycount")</synopsis></entry>
					</row>
				</tbody>
			</tgroup>
		</table> 
	</sect1>
</chapter>

