<chapter id="event_patterns">
    <title>Event Pattern Reference</title>
    
    <sect1 id="event-pattern-intro">
        <title>Event Pattern Overview</title>

        <para>
			Event patterns match when an event or multiple events occur that match the pattern's definition. Patterns can also be time-based.
         </para>

        <para>
			Pattern expressions can consist of filter expressions combined with pattern operators. Expressions can contain further nested
			pattern expressions by including the nested expression(s) in <literal>()</literal> round brackets.
         </para>
         
        <para>
			There are 5 types of operators:
         </para>

		<orderedlist spacing="compact">
			<listitem>
				<para>
					Operators that control pattern sub-expression repetition: <literal>every</literal>
				</para>
			</listitem>
			<listitem>
				<para>
					Logical operators: <literal>and</literal>, <literal>or</literal>, <literal>not</literal>
				</para>
			</listitem>
			<listitem>
				<para>
					Temporal operators that operate on event order: <literal>-&gt;</literal> (followed-by)
				</para>
			</listitem>
			<listitem>
				<para>
					Guards are where-conditions that control the lifecycle of sub-expressions. Examples are <literal>timer:within</literal>.
				</para>
			</listitem>
			<listitem>
				<para>
					Observers observe time events as well as other events. Examples are <literal>timer:interval</literal> and <literal>timer:at</literal>.
				</para>
			</listitem>
		</orderedlist>
    </sect1>

    <sect1 id="pattern-how-to-use">
        <title>How to use Patterns</title>
        
        <sect2 id="pattern-howto-syntax">
           <title>Pattern Syntax</title>
           
			<para>
				This is an example pattern expression that matches on every <literal>ServiceMeasurement</literal> events in which the
				value of the <literal>latency</literal> event property is over 20 seconds, and on every <literal>ServiceMeasurement</literal> event in which the
				<literal>success</literal> property is false. Either one or the other condition must be true for this pattern to match.
			</para>
			<programlisting><![CDATA[every (spike=ServiceMeasurement(latency>20000) or error=ServiceMeasurement(success=false))]]></programlisting>
			
			<para>
				In the example above, the pattern expression starts with an <literal>every</literal> operator to indicate that the pattern should fire for every matching events and not just the first
				matching event. Within the <literal>every</literal> operator in round brackets is a nested pattern expression using the <literal>or</literal> operator. 
				The left hand of the <literal>or</literal> operator is a filter expression that filters for events with a high latency value. The right hand of the operator 
				contains a filter expression that filters for events with error status. Filter expressions are explained in <xref linkend="pattern-filter"/>.
			</para>
						
			<para>
				The example above assigned the tags <literal>spike</literal> and <literal>error</literal> to the events in the pattern. The tags are important since the
				engine only places tagged events into the output event(s) that a pattern generates, and that the engine supplies to listeners of the pattern statement. The tags can
				further be selected in the select-clause of an EQL statement as discussed in <xref linkend="eql-from-clause-patterns"/>.
			</para>

			<para>
				Pattern statements are created via the <literal>EPAdministrator</literal> interface. The <literal>EPAdministrator</literal> interface allows to create pattern statements in two ways:
				Pattern statements that want to make use of the EQL <literal>select</literal> clause or any other EQL constructs use the <literal>createEQL</literal> method to create a statement that specifies one or more pattern expressions. EQL statements that use patterns are described in more detail in <xref linkend="eql-from-clause-patterns"/>. Use the syntax as shown in below example.
			</para>
				
			<programlisting><![CDATA[EPAdministrator admin = EPServiceProviderManager.getDefaultProvider().getEPAdministrator();

String eventName = ServiceMeasurement.class.getName();

EPStatement myTrigger = admin.createEQL("select * from pattern [" +
  "every (spike=" + eventName + "(latency>20000) or error=" + eventName + "(success=false))]");
]]></programlisting>

			<para>
				Pattern statements that do not need to make use of the EQL <literal>select</literal> clause or any other EQL constructs can use the <literal>createPattern</literal> method, as in below example.
			</para>

			<programlisting><![CDATA[EPStatement myTrigger = admin.createPattern(
  "every (spike=" + eventName + "(latency>20000) or error=" + eventName + "(success=false))");
]]></programlisting>
		</sect2>
		
        <sect2 id="patterns-howto-subscribe" >
           <title>Subscribing to Pattern Events</title>
           
			<para>			
				When a pattern fires it publishes one or more events to any listeners to the pattern statement. 
				The listener interface is the <literal>net.esper.client.UpdateListener</literal> interface.
			</para>
			
			<para>            
				The example below shows an anonymous implementation of the <literal>net.esper.client.UpdateListener</literal> interface.
				We add the anonymous listener implementation to the <literal>myPattern</literal> statement created earlier. 
				The listener code simply extracts the underlying event class.
			</para>
			<programlisting><![CDATA[myPattern.addListener(new UpdateListener()
{
  public void update(EventBean[] newEvents, EventBean[] oldEvents)
  {
    ServiceMeasurement spike = (ServiceMeasurement) newEvents[0].get("spike");
    ServiceMeasurement error = (ServiceMeasurement) newEvents[0].get("error");
    ... // either spike or error can be null, depending on which occurred
    ... // add more logic here
  }
});
]]></programlisting>

			<para>            
				Listeners receive an array of <literal>EventBean</literal> instances in the <literal>newEvents</literal> parameter.
				There is one <literal>EventBean</literal> instance passed to the listener for each combination of events that matches
				the pattern expression. At least one <literal>EventBean</literal> instance is always passed to the listener.
			</para>
				
			<para>
				The properties of each <literal>EventBean</literal> instance contain the underlying events that caused the
				pattern to fire, if events have been named in the filter expression via the <literal>name=eventType</literal> syntax.
				The property name is thus the name supplied in the pattern expression, while the property type is the type of the underlying class, 
				in this example <literal>ServiceMeasurement</literal>.
			</para>

		</sect2>
		
        <sect2 id="pattern-howto-pull-data" >
           <title>Pulling Data from Patterns</title>
           
			<para>
				Data can also be pulled from pattern statements via the <literal>iterator()</literal> method. 
				If the pattern had fired at least once, then the iterator returns the last event for which it fired.
				The <literal>hasNext()</literal> method can be used to determine if the pattern had fired.				 				
			</para>

			<programlisting><![CDATA[if (myPattern.iterator().hasNext())
{
	ServiceMeasurement event = (ServiceMeasurement) view.iterator().next().get("alert");
    ... // some more code here to process the event
}
else
{
    ... // no matching events at this time
}]]></programlisting>

		</sect2>                
    </sect1>

    <sect1 id="pattern-filter">
        <title>Pattern Filter Expressions</title>

		<para>
			The simplest form of filter is a filter for events of a given type without any conditions on the event property values. This filter matches any event of that type regardless of the event's properties. The example below is such a filter. Note that this event pattern would stop firing as soon as the first RfidEvent is encountered.
		 </para>
		 <programlisting><![CDATA[com.mypackage.myevents.RfidEvent]]></programlisting>

		 <para>
			 To make the event pattern fire for every RfidEvent and not just the first event, use the <literal>every</literal> keyword.
		 </para>
		 <programlisting><![CDATA[every com.mypackage.myevents.RfidEvent]]></programlisting>
		 
		 <para>
			 The example above specifies the fully-qualified Java class name as the event type. Via configuration, the event pattern above can be simplified by using the alias
			 that has been defined for the event type.
		 </para>
		 <programlisting><![CDATA[every RfidEvent]]></programlisting>
		 
		 <para>
			 Interfaces and superclasses are also supported as event types. In the below example <literal>IRfidReadable</literal> is an interface class, and the statement matches any event that implements this interface:
		 </para>
		 <programlisting><![CDATA[every org.myorg.rfid.IRfidReadable]]></programlisting>

		<para>
			The filtering criteria to filter for events with certain event property values are placed within parenthesis after the event type name:
		 </para>
		 <programlisting><![CDATA[RfidEvent(category="Perishable")]]></programlisting>
		 
		<para>
			All expressions can be used in filters, including static method invocations that return a boolean value:
		 </para>
		 <programlisting><![CDATA[RfidEvent(MyRFIDLib.isInRange(x, y) or (x<0 and y < 0))]]></programlisting>
			
		<para>
			Filter expressions can be separated via a single comma '<literal>,</literal>'. The comma represents a logical AND between expressions:
		 </para>
		 <programlisting><![CDATA[RfidEvent(zone=1, category=10)
...is equivalent to...
RfidEvent(zone=1 and category=10)]]></programlisting>

		<para>
			The following set of operators are highly optimized through indexing and are the preferred means of filtering high-volume event streams:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
					equals <literal>=</literal>
				</para>
			</listitem>
			<listitem>
				<para>
					not equals <literal>!=</literal>
				</para>
			</listitem>
			<listitem>
				<para>
					comparison operators <literal>&lt; , &gt; , &gt;=, &lt;=</literal>
				</para>
			</listitem>
			<listitem>
				<para>
					ranges 
				</para>
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							use the <literal>between</literal> keyword for a closed range where both endpoints are included
						</para>
					</listitem>
					<listitem>
						<para>
							use the <literal>in </literal> keyword and round <literal>()</literal> or square brackets <literal>[]</literal> to control how endpoints are included
						</para>
					</listitem>
					<listitem>
						<para>
							for inverted ranges use the <literal>not</literal> keyword and the <literal>between</literal> or <literal>in</literal> keywords
						</para>
					</listitem>
				</itemizedlist>
			</listitem>
			<listitem>
				<para>
					list-of-values checks using the <literal>in</literal> keyword or the <literal>not in </literal> keywords followed by a comma-separated list of values
				</para>
			</listitem>
		</itemizedlist>

		<para>
			At compile time as well as at run time, the engine scans new filter expressions for sub-expressions that can be indexed. Indexing filter values to match event properties of incoming events enables the engine to match incoming events faster. The above list of operators represents the set of operators that the engine can best convert into indexes. The use of comma or logical <literal>and</literal> in filter expressions does not impact optimizations by the engine. 
		</para>
		
		<para>
			For more information on filters please see <xref linkend="eql-from-clause-filter"/>.
		</para>

		<para>
			Filter criteria can also refer to events matching prior named events in the same expression. Below pattern is an example in which the pattern
			matches once for every RfidEvent that is preceded by an RfidEvent with the same asset id.
		 </para>
		 <programlisting><![CDATA[every A=RfidEvent -> B=RfidEvent(assetId=A.assetId)]]></programlisting>
		 
		<para>
			The syntax shown above allows filter criteria to reference prior results by specifying the event name tag of the prior event, and the event property name. This syntax can be used in all filter operators or expressions including ranges and the <literal>in</literal> set-of-values check:
		 </para>
		 <programlisting><![CDATA[every A=RfidEvent -> 
  B=RfidEvent(MyLib.isInRadius(A.x, A.y, x, y) and zone in (1, A.zone))]]></programlisting>
	</sect1>

    <sect1 id="pattern-operators">
        <title>Pattern Operators</title>

        <sect2 id="pattern-logical-every" >
           <title>Every</title>
    
            <para>				
				The <literal>every</literal> operator indicates that the pattern sub-expression should restart when the sub-expression qualified by the <literal>every</literal> keyword evaluates to true or false.
				Without the <literal>every</literal> operator the pattern sub-expression stops when the pattern sub-expression evaluates to true or false.
            </para>
				
            <para>
				Thus the <literal>every</literal> operator works like a factory for the pattern sub-expression contained within. When the pattern sub-expression within it 
				fires and thus quits checking for events, the <literal>every</literal> causes the start of a new pattern sub-expression listening for more occurances of the same
				event or set of events.
            </para>				

            <para>
				Every time a pattern sub-expression within an <literal>every</literal> operator turns true the engine starts a new active sub-expression looking 
				for more event(s) or timing conditions that match the pattern sub-expression. If the <literal>every</literal> operator is not specified for a sub-expression, 
				the sub-expression stops after the first match was found.
            </para>
            
            <para>
				This pattern fires when encountering event A and then stops looking.
            </para>
			<programlisting><![CDATA[A]]></programlisting>

            <para>
				This pattern keeps firing when encountering event A, and doesn't stop looking.
            </para>
			<programlisting><![CDATA[every A]]></programlisting>
			
            <para>
				Let's consider an example event sequence as follows.
            </para>

            <para>
				A<subscript>1</subscript>   
				B<subscript>1</subscript>   
				C<subscript>1</subscript>   
				B<subscript>2</subscript>   
				A<subscript>2</subscript>   
				D<subscript>1</subscript>   
				A<subscript>3</subscript>   
				B<subscript>3</subscript>   
				E<subscript>1</subscript>   
				A<subscript>4</subscript>   
				F<subscript>1</subscript>   
				B<subscript>4</subscript>   
            </para>

			<table frame="topbot" id="pattern-every-samples" revision="2">
				<title>'Every' operator examples</title>
				<tgroup cols="2">
					<colspec colwidth="1*"/>
					<colspec colwidth="2.5*"/>
					<thead>
						<row>
							<entry>Example</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry><programlisting><![CDATA[every ( A -> B )]]></programlisting></entry>
							<entry>
								<para>
									Detect event A followed by event B. 
									At the time when B occurs the pattern matches, then the pattern matcher restarts and looks for event A again.
								</para>
								<orderedlist spacing="compact">
									<listitem>
										<para>
											Matches on B<subscript>1</subscript> for combination {A<subscript>1</subscript>, B<subscript>1</subscript>}
										</para>
									</listitem>
									<listitem>
										<para>
											Matches on B<subscript>3</subscript> for combination {A<subscript>2</subscript>, B<subscript>3</subscript>}
										</para>
									</listitem>
									<listitem>
										<para>
											Matches on B<subscript>4</subscript> for combination {A<subscript>4</subscript>, B<subscript>4</subscript>}
										</para>
									</listitem>
								</orderedlist>
							</entry>
						</row>
						<row>					
							<entry><programlisting><![CDATA[every A -> B]]></programlisting></entry>
							<entry>
								<para>
									The pattern fires for every event A followed by an event B.
								</para>
								<orderedlist spacing="compact">
									<listitem>
										<para>
											Matches on B<subscript>1</subscript> for combination {A<subscript>1</subscript>, B<subscript>1</subscript>}
										</para>
									</listitem>
									<listitem>
										<para>
											Matches on B<subscript>3</subscript> for combination {A<subscript>2</subscript>, B<subscript>3</subscript>}
											and {A<subscript>3</subscript>, B<subscript>3</subscript>}
										</para>
									</listitem>
									<listitem>
										<para>
											Matches on B<subscript>4</subscript> for combination {A<subscript>4</subscript>, B<subscript>4</subscript>}
										</para>
									</listitem>
								</orderedlist>
							</entry>
						</row>
						<row>
							<entry><programlisting><![CDATA[A -> every B]]></programlisting></entry>
							<entry>
								<para>
									The pattern fires for an event A followed by every event B.
								</para>
								<orderedlist spacing="compact">
									<listitem>
										<para>
											Matches on B<subscript>1</subscript> for combination {A<subscript>1</subscript>, B<subscript>1</subscript>}.
										</para>
									</listitem>
									<listitem>
										<para>
											Matches on B<subscript>2</subscript> for combination {A<subscript>1</subscript>, B<subscript>2</subscript>}.
										</para>
									</listitem>
									<listitem>
										<para>
											Matches on B<subscript>3</subscript> for combination {A<subscript>1</subscript>, B<subscript>3</subscript>}
										</para>
									</listitem>
									<listitem>
										<para>
											Matches on B<subscript>4</subscript> for combination {A<subscript>1</subscript>, B<subscript>4</subscript>}
										</para>
									</listitem>
								</orderedlist>
							</entry>
						</row>
						<row>
							<entry><programlisting><![CDATA[every A -> every B]]></programlisting></entry>
							<entry>
								<para>
									The pattern fires for every event A followed by every event B.
								</para>
								<orderedlist spacing="compact">
									<listitem>
										<para>
											Matches on B<subscript>1</subscript> for combination {A<subscript>1</subscript>, B<subscript>1</subscript>}.
										</para>
									</listitem>
									<listitem>
										<para>
											Matches on B<subscript>2</subscript> for combination {A<subscript>1</subscript>, B<subscript>2</subscript>}.
										</para>
									</listitem>
									<listitem>
										<para>
											Matches on B<subscript>3</subscript> for combination {A<subscript>1</subscript>, B<subscript>3</subscript>}
											and {A<subscript>2</subscript>, B<subscript>3</subscript>} and {A<subscript>3</subscript>, B<subscript>3</subscript>}
										</para>
									</listitem>
									<listitem>
										<para>
											Matches on B<subscript>4</subscript> for combination {A<subscript>1</subscript>, B<subscript>4</subscript>}
											and {A<subscript>2</subscript>, B<subscript>4</subscript>} and {A<subscript>3</subscript>, B<subscript>4</subscript>}
											and {A<subscript>4</subscript>, B<subscript>4</subscript>}
										</para>
									</listitem>
								</orderedlist>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>

            <para>
				The examples show that it is possible that a pattern fires for multiple combinations of events that match a pattern expression.
				Each combination is posted as an <literal>EventBean</literal> instance to the <literal>update</literal> method in the <literal>UpdateListener</literal> implementation.
            </para>
            
            <para>
				Let's consider the <literal>every</literal> operator in conjunction with a sub-expression that matches 3 events that follow each other:
            </para>
			<programlisting><![CDATA[every (A -> B -> C)]]></programlisting>
  
            <para>
				The pattern first looks for event A. When event A arrives, it looks for event B. After event B arrives, the pattern looks for event C. Finally when event C arrives the pattern fires. The engine then starts looking for event A again.
            </para>

            <para>
				Assume that between event B and event C a second event A<subscript>2</subscript> arrives. The pattern would ignore the A<subscript>2</subscript> entirely since it's then looking for event C.
				As observed in the prior example, the <literal>every</literal> operator restarts the sub-expression <literal>A -> B -> C</literal> only when the sub-expression fires.
            </para>

            <para>
				In the next statement the <literal>every</literal> operator applies only to the A event, not the whole sub-expression:
            </para>
			<programlisting><![CDATA[every A -> B -> C]]></programlisting>
 
            <para>
				This pattern now matches for any event A that is followed by an event B and then event C, regardless of when the event A arrives. Oftentimes this can be practical in combination with the <literal>and not</literal> syntax and the <literal>timer:within</literal> syntax as the
				next example shows. 
            </para>
				
            <para>
				This example looks at temperature sensor events named Sample. The pattern detects when 3 sensor events indicate a temperature of more then 50 degrees uninterrupted within 90 seconds of the first event, considering events for the same sensor only.
            </para>

			<programlisting><![CDATA[every sample=Sample(temp > 50) ->
  ( (Sample(sensor=sample.sensor, temp > 50) and not Sample(sensor=sample.sensor, temp <= 50))   
      ->
    (Sample(sensor=sample.sensor, temp > 50) and not Sample(sensor=sample.sensor, temp <= 50))   
  ) where timer:within(90 seconds))]]></programlisting>

            <para>
				The pattern starts a new sub-expression in the round braces after the first followed-by operator for each time a sensor indicated more then 50 degrees. Each sub-expression then lives a maximum of 90 seconds. Each sub-expression ends if a temperature of 50 degress or less is encountered for the same sensor. Only if 3 temperature events in a row indicate more then 50 degrees, and within 90 seconds of the first event, and for the same sensor, does this pattern fire.
            </para>

        </sect2>

        <sect2 id="pattern-logical-and" >
           <title>And</title>
    
            <para>
				Similar to the Java &amp;&amp; operator the <literal>and</literal> operator requires both nested pattern expressions to turn 
				true before the whole expression turns true (a join pattern).
            </para>
            
            <para>
				Pattern matches when both event A and event B are found.
            </para>
			<programlisting><![CDATA[A and B]]></programlisting>

            <para>
				Pattern matches on any sequence A followed by B and C followed by D, or C followed by D and A followed by B
            </para>
			<programlisting><![CDATA[(A -> B) and (C -> D)]]></programlisting>
            
        </sect2>

        <sect2 id="pattern-logical-or" >
           <title>Or</title>
    
            <para>
				Similar to the Java “||” operator the <literal>or</literal> operator requires either one of the expressions 
				to turn true before the whole expression turns true.
            </para>
            
           <para>
			   Look for either event A or event B. As always, A and B can itself be nested expressions as well.
            </para>
			<programlisting><![CDATA[A or B]]></programlisting>

            <para>
				Detect all stock ticks that are either above or below a threshold.
            </para>
			<programlisting><![CDATA[every (StockTick(symbol='IBM', price < 100) or StockTick(symbol='IBM', price > 105)]]></programlisting>
            
        </sect2>

        <sect2 id="pattern-logical-not" >
           <title>Not</title>
    
            <para>
				The <literal>not</literal> operator negates the truth value of an expression. Pattern expressions prefixed with <literal>not</literal> are automatically 
				defaulted to true.
            </para>
            
           <para>
				This pattern matches only when an event A is encountered followed by event B but only if no event C was encountered before event B.          
            </para>
			<programlisting><![CDATA[( A -> B ) and not C]]></programlisting>
			            
        </sect2>

        <sect2 id="pattern-temporal-followed-by" >
           <title>Followed-by</title>
    
            <para>
				The followed by <literal>-&gt;</literal> operator specifies that first the left hand expression must turn true and only 
				then is the right hand expression evaluated for matching events.
            </para>
            
            <para>
				Look for event A and if encountered, look for event B. As always, A and B can itself be nested event pattern expressions.
            </para>
			<programlisting><![CDATA[A -> B]]></programlisting>

            <para>
				This is a pattern that fires when 2 status events indicating an error occur one after the other.
            </para>
			<programlisting><![CDATA[StatusEvent(status='ERROR') -> StatusEvent(status='ERROR')]]></programlisting>

        </sect2>
                    
    </sect1>

    <sect1 id="pattern-guards">
        <title>Pattern Guards</title>        

		<para>
			Guards are where-conditions that control the lifecycle of sub-expressions. Custom guard functions can also be used. The section <xref linkend="extension"/> outlines guard plug-in development in greater detail.
		</para>

        <para>
			Take as an example the following pattern expression:  
        </para>
		<programlisting><![CDATA[MyEvent where timer.within(10 sec)]]></programlisting>

        <para>
			In this pattern the <literal>timer:within</literal> guard controls the sub-expression that is looking for MyEvent events. The guard terminates the sub-expression looking for MyEvent events after 10 seconds after start of the pattern. Thus the pattern alerts only once when the first MyEvent event arrives within 10 seconds after start of the pattern.
        </para>

        <para>
			The <literal>every</literal> keyword requires additional discussion since it also controls sub-expression lifecycle. Let's add the <literal>every</literal> keyword to the example pattern:
        </para>
		<programlisting><![CDATA[every MyEvent where timer.within(10 sec)]]></programlisting>

        <para>
			The difference to the pattern without <literal>every</literal> is that each MyEvent event that arrives now starts a new sub-expression, including a new guard, looking for a further MyEvent event. The result is that, when a MyEvent arrives within 10 seconds after pattern start, the pattern execution will look for the next MyEvent event to arrive within 10 seconds after the previous one.
        </para>

        <para>
			By placing parentheses around the <literal>every</literal> keyword and its sub-expression, we can have the <literal>every</literal> under the control of the guard:
        </para>
		<programlisting><![CDATA[(every MyEvent) where timer.within(10 sec)]]></programlisting>

        <para>
			In the pattern above, the guard terminates the sub-expression looking for all MyEvent events after 10 seconds after start of the pattern. This pattern alerts for all MyEvent events arriving within 10 seconds after pattern start, and then stops.
        </para>

        <sect2 id="pattern-timer-within" >
           <title>timer:within</title>
           
            <para>
				The <literal>timer:within</literal> guard acts like a stopwatch. 
				If the associated pattern expression does not turn true within the specified time period it is stopped and permanently false.
				The <literal>timer:within</literal> guard takes a time period (see <xref linkend="eql-syntax-time-periods"/>) or a number of seconds as a parameter.
            </para>
            
            <para>
				This pattern fires if an A event arrives within 5 seconds after statement creation.
            </para>
			<programlisting><![CDATA[A where timer:within (5 seconds)]]></programlisting>

            <para>
				This pattern fires for all A events that arrive within 5 seconds. After 5 seconds, this pattern stops matching even if more A events arrive.
            </para>
			<programlisting><![CDATA[(every A) where timer:within (5 seconds)]]></programlisting>
            
            <para>
				This pattern is similar to the first pattern but here every time A arrives within 5 seconds, the pattern begins looking for A for another 5 seconds. As long
				as A events arrive within 5 seconds after the last A, the pattern does not stop matching.
            </para>
			<programlisting><![CDATA[every (A where timer:within (5 sec))]]></programlisting>

            <para>
				This pattern matches for any one A or B event in the next 5 seconds.
            </para>
			<programlisting><![CDATA[( A or B ) where timer:within (5 sec)]]></programlisting>

            <para>
				This pattern matches for any 2 errors that happen 10 seconds within each other.
            </para>
			<programlisting><![CDATA[every (StatusEvent(status='ERROR') -> StatusEvent(status='ERROR') where timer:within (10 sec))]]></programlisting>

			<para>
				The following guards are equivalent:
			</para>
			<programlisting><![CDATA[]]>timer:within(2 minutes 5 seconds)
timer:within(125 sec)
timer:within(125)</programlisting>

        </sect2>
   </sect1>
   
    <sect1 id="pattern-observers">
        <title>Pattern Observers</title>

		<para>
			Observers observe time-based events for which the thread-of-control originates by the engine timer thread. Custom observers can also be developed that observe timer events or other engine-external events. The section <xref linkend="extension"/> outlines observer plug-in development in greater detail.
		</para>
		
        <sect2 id="pattern-timer-interval" >
           <title>timer:interval</title>
               
            <para>
				The <literal>timer:interval</literal> observer waits for the defined time before the truth value of the observer turns true.
				The observer takes a time period (see <xref linkend="eql-syntax-time-periods"/>) or a number of seconds as a parameter.
            </para>

            <para>
				After event A arrived wait 10 seconds then indicate that the pattern matches.
            </para>
			<programlisting><![CDATA[A -> timer:interval(10 seconds) ]]></programlisting>

            <para>
				The pattern below fires every 20 seconds.
            </para>
			<programlisting><![CDATA[every timer:interval(20 sec)]]></programlisting>

            <para>
				The next example pattern fires for every event A that is not followed by an event B within 60 seconds after event A arrived. B must have the same "id" property
				value as A.
            </para>
			<programlisting><![CDATA[every a=A -> (timer:interval(60 sec) and not B(id=a.id)) ]]></programlisting>
        </sect2>

        <sect2 id="pattern-timer-at" >
           <title>timer:at</title>

            <para>
				The <literal>timer:at</literal> observer is similar in function to the Unix “crontab” command. At a specified time the 
				expression turns true. The <literal>at</literal> operator can also be made to pattern match at regular intervals by using an <literal>every</literal> operator 
				in front of the <literal>timer:at</literal> operator. 
            </para>
				
            <para>
				The syntax is: <literal>timer:at (minutes, hours, days of month, months, days of week [, seconds]).</literal>
            </para>
				
            <para>
				The value for seconds is optional. Each element allows wildcard <literal>*</literal> values. Ranges can be specified 
				by means of lower bounds then a colon ‘:’ then the upper bound. The division operator <literal>*/x</literal> can be used to 
				specify that every x<subscript>th</subscript> value is valid. Combinations of these operators can be used by placing these into square brackets([]).
            </para>
            
            <para>
				This expression pattern matches every 5 minutes past the hour.
            </para>
			<programlisting><![CDATA[every timer:at(5, *, *, *, *)]]></programlisting>

            <para>
				The below <literal>timer:at</literal> pattern matches every 15 minutes from 8am to 5pm on even numbered days of the month as well as on the 
				first day of the month.
            </para>
			<programlisting><![CDATA[timer:at (*/15, 8:17, [*/2, 1], *, *)]]></programlisting>
           
            <para>
				The below table outlines the fields, valid values and keywords available for each field:
            </para>

		   <table frame="topbot">
				<title>Properties offered by sample statement aggregating price</title>
				<tgroup cols="4">
					<colspec colwidth="0.7*"/>
					<colspec colwidth="0.7*"/>
					<colspec colwidth="0.7*"/>
					<colspec colwidth="1.3*"/>
					<thead>
						<row>
							<entry>Field Name</entry>
							<entry>Mandatory?</entry>
							<entry>Allowed Values</entry>
							<entry>Additional Keywords</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>Minutes</entry>
							<entry>yes</entry>
							<entry>0 - 59</entry>
							<entry></entry>
						</row>
						<row>
							<entry>Hours</entry>
							<entry>yes</entry>
							<entry>0 - 23</entry>
							<entry></entry>
						</row>
						<row>
							<entry>Days Of Month</entry>
							<entry>yes</entry>
							<entry>1 - 31</entry>
							<entry>last, weekday, lastweekday</entry>
						</row>
						<row>
							<entry>Months</entry>
							<entry>yes</entry>
							<entry>1 - 12</entry>
							<entry></entry>
						</row>
						<row>
							<entry>Days Of Week</entry>
							<entry>yes</entry>
							<entry>0 (Sunday) - 6 (Saturday)</entry>
							<entry>last</entry>
						</row>
						<row>
							<entry>Seconds</entry>
							<entry>no</entry>
							<entry>0 - 59</entry>
							<entry></entry>
						</row>
					</tbody>
				</tgroup>
			</table> 

            <para>
				The keyword <literal>last</literal> used in the days-of-month field means the last day of the month (current month). To specify the last day of another month, a value for the month field has to be provided. For example: <literal>timer:at(*, *, last,2,*)</literal> is the last day of February. 
            </para>
				
            <para>
				The <literal>last</literal> keyword in the day-of-week field by itself simply means Saturday. If used in the day-of-week field after another value, it means "the last xxx day of the month" - for example "5 last" means "the last friday of the month". 
				So the last Friday of the current month will be: <literal>timer:at(*, *, *, *, 5 last)</literal>. And the last Friday of June: <literal>timer:at(*, *, *, 6, 5 last)</literal>.
            </para>

            <para>
				The keyword <literal>weekday</literal> is used to specify the weekday (Monday-Friday) nearest the given day. Variant could include month like in: <literal>timer:at(*, *, 30 weekday, 9, *)</literal> which is Friday September 28th (no jump over month).
            </para>

            <para>
				The keyword <literal>lastweekday</literal> is a combination of two parameters, the <literal>last</literal> and the <literal>weekday</literal> keywords. A typical example could be: <literal>timer:at(*, *, *, lastweekday, 9, *)</literal> which will define Friday September 28th (example year is 2007).
            </para>

        </sect2>
   </sect1>
   
</chapter>
