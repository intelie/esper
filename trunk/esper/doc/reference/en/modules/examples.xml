<chapter id="examples">
    <title>Examples, Tutorials, Case Studies</title>
    
	<para>
		The tutorial and case studies are available on the public web site at <literal>http://esper.codehaus.org/evaluating/evaluating.html</literal>.
	</para>

    <sect1 id="examples-overview">
        <title>Examples Overview</title>
        
		<para>
			This chapter outlines the examples that come with Esper in the <literal>examples/src</literal> folder of the distribution. The code for examples can be found in the <literal>net.esper.example</literal> packages.
		</para>
    	
		<para>
			In order to compile and run the samples please follow the below instructions:
		</para>

		<orderedlist>
			<listitem>
				<para>
                    Make sure Java 1.5 or greater is installed and the JAVA_HOME environment variable is set.
                </para>
			</listitem>
			<listitem>
				<para>
                    Open a console window and change directory to examples/etc.
                </para>
			</listitem>
			<listitem>
				<para>
                    Run "setenv.bat" (Windows) or "setenv.sh" (Unix) to verify your environment settings.
                </para>
			</listitem>
			<listitem>
				<para>
                    Run "compile.bat" (Windows) or "compile.sh" (Unix) to compile the examples.
                </para>
			</listitem>
			<listitem>
				<para>
                    Now you are ready to run the examples. Some examples require mandatory parameters. Further information to running
                    each example can be found in the "examples/etc" folder in file "readme.txt".
                </para>
			</listitem>
			<listitem>
				<para>
                    Modify the logger logging level in the "log4j.xml" configuration file 
                    changing DEBUG to INFO on a class or package level to reduce the volume of text output. 
                </para>
			</listitem>
		</orderedlist>

		<para>
			JUnit tests exist for the example code. The JUnit test source code for the examples can be found in the <literal>examples/test</literal> folder. To build and run the example JUnit tests, use the Maven 2 goal <literal>test</literal>. The JUnit test source code can also be helpful in understanding the example and in the use of Esper APIs.
		</para>		
    </sect1>

    <sect1 id="examples-marketdata-monitor">
        <title>Market Data Feed Monitor</title>

		<para>
			This example processes a raw market data feed. It reports throughput statistics and 
			detects when the data rate of a feed falls off unexpectedly. A rate fall-off may mean that the data is stale and 
			we want to alert when there is a possible problem with the feed.
		</para>

		<para>
			The classes for this example live in package <literal>net.esper.example.marketdatafeed</literal>. 
			Run "run_mktdatafeed.bat" (Windows) or "run_mktdatafeed.sh" (Unix) in the <literal>examples/etc</literal> folder 
			to start the market data feed simulator. 			
		</para>
		
        <sect2 id="examples-marketdata-monitor-input">
        	<title>Input Events</title>
        
			<para>
				The input stream consists of 1 event stream that contains 2 simulated market data feeds. Each individual event in the stream 
				indicates the feed that supplies the market data, the security symbol and some pricing information:
			</para>

<programlisting><![CDATA[String symbol;
FeedEnum feed;
double bidPrice;
double askPrice;
]]></programlisting>
		</sect2>
			
        <sect2 id="examples-marketdata-computing">
        	<title>Computing Rates Per Feed</title>

			<para>
				For the throughput statistics and to detect rapid fall-off we calculate a ticks per second rate for each market data feed. 
			</para>

			<para>
				We can use an EQL statement that specifies a view onto the market data event stream that batches together 1 second of events. 
				We specify the feed and a count of events per feed as output values. To make this data available for further processing, we
				insert output events into the TicksPerSecond event stream:
			</para>

<programlisting><![CDATA[insert into TicksPerSecond
select feed, count(*) as cnt 
  from MarketDataEvent.win:time_batch(1 second) 
 group by feed
]]></programlisting>
		</sect2>

        <sect2 id="examples-marketdata-falloff">
        	<title>Detecting a Fall-off</title>

			<para>
				We define a rapid fall-off by alerting when the number of ticks per second for any second falls below 75% of the 
				average number of ticks per second over the last 10 seconds. 
			</para>

			<para>
				We can compute the average number of ticks per second over the last 10 seconds simply by using the TicksPerSecond events computed by the
				prior statement and averaging the last 10 seconds. Next, we compare the current rate with the moving average and
				filter out any rates that fall below 75% of the average:
			</para>

<programlisting><![CDATA[select feed, avg(cnt) as avgCnt, cnt as feedCnt 
  from TicksPerSecond.win:time(10 seconds)
 group by feed 
having cnt < avg(cnt) * 0.75
]]></programlisting>
		</sect2>

        <sect2 id="examples-marketdata-monitor-sim">
			<title>Event generator</title>
			<para>
				The simulator generates market data events for 2 feeds, feed A and feed B. A target rate parameter
				defines how many events for each feed the simulator sends to the engine in each second. Depending on your system,
				a large target rate may result in more events to be sent to the engine then your system can handle in one second.
				In that case, the target rate will not be achieved. After reaching the target number of events for a given second, 
				the simulator sleeps the thread for an approximate remainder of the current second.
			</para>

			<para>
				The simulator generates a number of events per second following the formula 
				<literal>target rate * 0.9 + target rate * 0.2 * random.nextDouble()</literal>.
				This generates a random rate for each feed in a +-10% range within the target rate.
			</para>

			<para>
				The rate drop probability parameter specifies the probability in percent that the engine drops the rate 
				for a randomly chosen feed to 60% of the target rate for that second. Thus rate fall-off alerts can be generated.
			</para>
		</sect2>
    </sect1>

    <sect1 id="examples-transaction-3-event-challenge">
        <title>Transaction 3-Event Challenge</title>

		<para>
			The classes for this example live in package <literal>net.esper.example.transaction</literal>. 
			Run "run_txnsim.bat" (Windows) or "run_txnsim.sh" (Unix) to start the transaction simulator. 
			Please see the readme file in the same folder for build instructions and command line parameters.
		</para>

        <sect2 id="examples-txn3event-1" >
			<title>The Events</title>

			<para>
	The use case involves tracking three components of a transaction. It‘s important that we use at least three components, since some engines have different performance or coding for only two events per transaction. Each component comes to the engine as an event with the following fields:
			</para>
	
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Transaction ID
					</para>
				</listitem>
				<listitem>
					<para>
						Time stamp
					</para>
				</listitem>
			</itemizedlist>
	
			<para>
				In addition, we have the following extra fields:
			</para>
	
			<para>
				In event A:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Customer ID
					</para>
				</listitem>
			</itemizedlist>
	
			<para>
				In event C:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Supplier ID (the ID of the supplier that the order was filled through)
					</para>
				</listitem>
			</itemizedlist>
		</sect2>

        <sect2 id="examples-txn3event-2" >
			<title>Combined event</title>

			<para>
					We need to take in events A, B and C and produce a single, combined event with the following fields:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Transaction ID
					</para>
				</listitem>
				<listitem>
					<para>
						Customer ID
					</para>
				</listitem>
				<listitem>
					<para>
						Time stamp from event A
					</para>
				</listitem>
				<listitem>
					<para>
						Time stamp from event B
					</para>
				</listitem>
				<listitem>
					<para>
						Time stamp from event C
					</para>
				</listitem>
			</itemizedlist>

			<para>
What we‘re doing here is matching the transaction IDs on each event, to form an aggregate event. If all these events were in a relational database, this could be done as a simple SQL join… except that with 10,000 events per second, you will need some serious database hardware to do it.
			</para>
		</sect2>
		
        <sect2 id="examples-txn3event-3">
			<title>Real time summary data</title>

			<para>
Further, we need to produce the following:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Min,Max,Average total latency from the events (difference in time between A and C) over the past 30 minutes.
					</para>
				</listitem>
				<listitem>
					<para>
						Min,Max,Average latency grouped by (a) customer ID and (b) supplier ID. In other words, metrics on the the latency of the orders coming from each customer and going to each supplier.
					</para>
				</listitem>
				<listitem>
					<para>
						Min,Max,Average latency between events A/B (time stamp of B minus A) and B/C (time stamp of C minus B).
					</para>
				</listitem>
			</itemizedlist>
		</sect2>
		
        <sect2 id="examples-txn3event-4">
			<title>Find problems</title>

			<para>
We need to detect a transaction that did not make it through all three events. In other words, a transaction with events A or B, but not C. Note that, in this case, what we care about is event C. The lack of events A or B could indicate a failure in the event transport and should be ignored. Although the lack of an event C could also be a transport failure, it merits looking into.
			</para>			
		</sect2>
		
        <sect2 id="examples-txn3event-5">
			<title>Event generator</title>
		
			<para>
To make testing easier, standard and to demonstrate how the example works, the example is including an event generator. The generator generates events for a given number of transactions, using the following rules:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						One in 5,000 transactions will skip event A
					</para>
				</listitem>
				<listitem>
					<para>
						One in 1,000 transactions will skip event B
					</para>
				</listitem>
				<listitem>
					<para>
						One in 10,000 transactions will skip event C.
					</para>
				</listitem>
				<listitem>
					<para>
						Transaction identifiers are randomly generated
					</para>
				</listitem>
				<listitem>
					<para>
						Customer and supplier identifiers are randomly chosen from two lists
					</para>
				</listitem>
				<listitem>
					<para>
						The time stamp on each event is based on the system time. Between events A and B as well as B and C, between 0 and 999 is added to the time. So, we have an expected time difference of around 500 milliseconds between each event
					</para>
				</listitem>
				<listitem>
					<para>
						Events are randomly shuffled as described below
					</para>
				</listitem>
				</itemizedlist>
	
				<para>
	To make things harder, we don‘t want transaction events coming in order. This code ensures that they come completely out of order. To do this, we fill in a bucket with events and, when the bucket is full, we shuffle it. The buckets are sized so that some transactions‘ events will be split between buckets. So, you have a fairly randomized flow of events, representing the worst case from a big, distributed infrastructure.
				</para>
	
				<para>
	The generator lets you change the size of the bucket (small, medium, large, larger, largerer). The larger the bucket size, the more events potentially come in between two events in a given transaction and so, the more the performance characteristics like buffers, hashes/indexes and other structures are put to the test as the bucket size increases.
				</para>
			</sect2>
    </sect1>

    <sect1 id="examples-terminalsvc-J2EE">
        <title>J2EE Self-Service Terminal Management </title>

		<para>
			The example is about a J2EE-based self-service terminal managing system in an airport that gets a lot of events from connected terminals. The event rate is around 500 events per second. Some events indicate abnormal situations such as 'paper low' or 'terminal out of order'. Other events observe activity as customers use a terminal to check in and print boarding tickets.
		</para>
		
        <sect2 id="examples-terminalsvc-events">
			<title>Events</title>

			<para>
				Each self-service terminal can publish any of the 6 events below.
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Checkin - Indicates a customer started a check-in dialog
					</para>
				</listitem>
				<listitem>
					<para>
						Cancelled - Indicates a customer cancelled a check-in dialog
					</para>
				</listitem>
				<listitem>
					<para>
						Completed	- Indicates a customer completed a check-in dialog
					</para>
				</listitem>
				<listitem>
					<para>
						OutOfOrder - Indicates the terminal detected a hardware problem
					</para>
				</listitem>
				<listitem>
					<para>
						LowPaper	- Indicates the terminal is low on paper
					</para>
				</listitem>
				<listitem>
					<para>
						Status - Indicates terminal status, published every 1 minute regardless of activity as a terminal heartbeat
					</para>
				</listitem>
			</itemizedlist>
			
			<para>
				All events provide information about the terminal that published the event, and a timestamp. The terminal information is held in a property named "term" and provides a terminal id. Since all events carry similar information, we model each event as a subtype to a base class BaseTerminalEvent, which will provide the terminal information that all events share. This enables us to treat all terminal events polymorphically, that is we can treat derived event types just like their parent event types. This helps simplify our queries.
			</para>

			<para>
				All terminals publish Status events every 1 minute. In normal cases, the Status events indicate that a terminal is alive and online. The absence of status events may indicate that a terminal went offline for some reason and that may need to be investigated.
			</para>
			
		</sect2>

        <sect2 id="examples-terminalsvc-pattern1">
			<title>Detecting Customer Check-in Issues</title>

			<para>
				A customer may be in the middle of a check-in when the terminal detects a hardware problem or when the network goes down. In that situation we want to alert a team member to help the customer. When the terminal detects a problem, it issues an OutOfOrder event. A pattern can find situations where the terminal indicates out-of-order and the customer is in the middle of the check-in process:
			</para>

<programlisting><![CDATA[select * from pattern [ every a=Checkin -> 
      ( OutOfOrder(term.id=a.term.id) and not 
          (Cancelled(term.id=a.term.id) or Completed(term.id=a.term.id)) )]]]></programlisting>
			
		</sect2>

        <sect2 id="examples-terminalsvc-pattern2">
			<title>Absence of Status Events</title>

			<para>
				Since Status events arrive in regular intervals of 60 seconds, we can make us of temporal pattern matching using timer to find events that didn't arrive. We can use the every operator and timer:interval() to repeat an action every 60 seconds. Then we combine this with a not operator to check for absence of Status events. A 65 second interval during which we look for Status events allows 5 seconds to account for a possible delay in transmission or processing:
			</para>

<programlisting><![CDATA[select 'terminal 1 is offline' from pattern 
  [every timer:interval(60 sec) -> (timer:interval(65 sec) and not Status(term.id = 'T1'))]
output first every 5 minutes]]></programlisting>

		</sect2>

        <sect2 id="examples-terminalsvc-eql1">
			<title>Activity Summary Data</title>

			<para>
				By presenting statistical information about terminal activity to our staff in real-time we enable them to monitor the system and spot problems. The next example query simply gives us a count per event type every 1 minute. We could further use this data, available through the CountPerType event stream, to join and compare against a recorded usage pattern, or to just summarize activity in real-time.
			</para>

<programlisting><![CDATA[insert into CountPerType
select type, count(*) as countPerType 
from BaseTerminalEvent.win:time(10 minutes) 
group by type
output all every 1 minutes]]></programlisting>
		</sect2>

        <sect2 id="examples-terminalsvc-j2ee">
			<title>Sample Application for J2EE Application Server</title>

			<para>
				The example code in the distribution package implements a message-driven enterprise java bean (MDB EJB). We used an MDB as a convenient place for processing incoming events via a JMS message queue or topic. The example uses 2 JMS queues: One queue to receive events published by terminals, and a second queue to indicate situations detected via EQL statement and listener back to a receiving process.
			</para>

			<para>
				This example has been packaged for deployment into a JBoss Java application server (see http://www.jboss.org) with default deployment configuration. JBoss is an open-source application server available under LGPL license. Of course the choice of application server does not indicate a requirement or preference for the use of Esper in a J2EE container. Other quality J2EE application servers are available and perhaps more suitable to run this example or a similar application.
			</para>

			<para>
				The complete example code can be found in the "examples/terminalsvc" folder of the distribution. The Java package name is net.esper.example.terminalsvc.
			</para>
			
			<sect3 id="examples-terminalsvc-j2ee-running">
				<title>Running the Example</title>
			
				<para>
					The pre-build EAR file contains the MDB for deployment to a JBoss application server with default deployment options. The JBoss default configuration provides 2 queues that this example utilizes: queue/A and queue/B. The queue/B is used to send events into the MDB, while queue/A is used to indicate back the any data received by listeners to EQL statements.
				</para>

				<para>
					The application can be deployed by copying the ear file in the "examples/terminalsvc/terminalsvc-ear" folder to your JBoss deployment directory located under the JBoss home directory under "server/default/deploy".
				</para>

				<para>
					The example contains an event simulator and an event receiver that can be invoked from the command line. See the folder "examples/terminalsvc/etc" folder readme file and start scripts for Windows and Unix, and the documentation set for further information on the simulator.
				</para>
			</sect3>

			<sect3 id="examples-terminalsvc-j2ee-building">
				<title>Building the Example</title>

				<para>
					This example requires Maven 2 to build. To build the example, change directory to the folder "examples/terminalsvc" and type "mvn package". The instructions have been tested with JBoss AS 4.0.4.GA and Maven 2.0.4.
				</para>

				<para>
					The Maven build packages the EAR file for deployment to a JBoss application server with default deployment options.
				</para>
			</sect3>

			<sect3 id="examples-terminalsvc-j2ee-running-sim">
				<title>Running the Event Simulator and Receiver</title>

					<para>
						The example also contains an event simulator that generates meaningful events. The simulator can be run from the directory "examples/terminalsvc/etc" via the command "run_terminalsvc_sender.bat" (Windows) and "run_terminalsvc_sender.sh" (Linux). The event simulator generates a batch of at least 200 events every 1 second. Randomly, with a chance of 1 in 10 for each batch of events, the simulator generates either an OutOfOrder or a LowPaper event for a random terminal. Each batch the simulator generates 100 random terminal ids and generates a Checkin event for each. It then generates either a Cancelled or a Completed event for each. With a chance of 1 in 1000, it generates an OutOfOrder event instead of the Cancelled or Completed event for a terminal.
					</para>

					<para>
						The event receiver listens to the MDB-outcoming queue for alerts and prints these out to console. The receiver can be run from the directory "examples/terminalsvc/etc" via the command "run_terminalsvc_receiver.bat" (Windows) and "run_terminalsvc_receiver.sh" (Linux). 
					</para>
			</sect3>	
		</sect2>
    </sect1>

    <sect1 id="examples-autoid">
        <title>AutoID RFID Reader</title>

		<para>
			In this example an array of RFID readers sense RFID tags as pallets are coming within the range of one of the readers. 
			A reader generates XML documents with observation information such as reader sensor ID, observation time 
			and tags observed. A statement computes the total number of tags per reader sensor ID within the last 60 seconds.
		</para>
    	
		<para>
			This example demonstrates how XML documents unmarshalled to <literal>org.w3c.dom.Node</literal> DOM document nodes
			can natively be processed by the engine without requiring Java object event representations. The example uses an XPath
			expression for an event property counting the number of tags observed by a sensor. The XML documents follow the AutoID (<literal>http://www.autoid.org/</literal>) organization
			standard. 
		</para>

		<para>
			The classes for this example can be found in package <literal>net.esper.example.autoid</literal>.
			As events are XML documents with no Java object representation, the example does not have event classes.
		</para>

		<para>
			A simulator that can be run from the command line is also available for this example.
			The simulator generates a number of XML documents as specified by a command line argument and
			prints out the totals per sensor.
			Run "run_autoid.bat" (Windows) or "run_autoid.sh" (Unix) to start the autoid simulator. 
			Please see the readme file in the same folder for build instructions and command line parameters.
		</para>

		<para>
			The code snippet below shows the simple statement to compute the total number of tags per sensor. The statement is created by class 
			<literal>net.esper.example.autoid.RFIDTagsPerSensorStmt</literal>.
		</para>

<programlisting><![CDATA[select ID as sensorId, sum(countTags) as numTagsPerSensor
from AutoIdRFIDExample.win:time(60 seconds)
where Observation[0].Command = 'READ_PALLET_TAGS_ONLY'
group by ID]]></programlisting>

    </sect1>

    <sect1 id="examples-stockticker">
        <title>StockTicker</title>

		<para>
			 The StockTicker example comes from the stock trading domain. The example creates event patterns to filter stock tick events based on price and symbol. 
			 When a stock tick event is encountered that falls outside the lower or upper price limit, the example simply displays that stock tick event.
			 The price range itself is dynamically created and changed. This is accomplished by an event patterns that searches for another event class, the price limit event.			 			 
		</para>
    	
		<para>
			The classes <literal>net.esper.example.stockticker.event.StockTick</literal> and <literal>PriceLimit</literal> represent our events. The event patterns are created by the class <literal>net.esper.example.stockticker.monitor.StockTickerMonitor</literal>. 
		</para>

		<para>
			Summary:
		</para>

        <itemizedlist spacing="compact">
			<listitem>
				<para>
                    Good example to learn the API and get started with event patterns
                </para>
			</listitem>
			<listitem>
				<para>
                    Dynamically creates and removes event patterns based on price limit events received
                </para>
			</listitem>
			<listitem>
				<para>
                    Simple, highly-performant filter expressions for event properties in the stock tick event such as symbol and price
                </para>
			</listitem>
		</itemizedlist>
    </sect1>

    <sect1 id="examples-matchmaker">
        <title>MatchMaker</title>

		<para>
			 In the MatchMaker example every mobile user has an X and Y location, a set of properties (gender, hair color, age range) and a set of preferences (one for each property) to match. The task of the event patterns created by this example is to detect mobile users that are within proximity given a certain range, and for which the properties match preferences.
		</para>
		
		<para>
			The event class representing mobile users is <literal>net.esper.example.matchmaker.event.MobileUserBean</literal>. The <literal>net.esper.example.matchmaker.monitor.MatchMakingMonitor</literal> class contains the patterns for detecing matches.
		</para>
    	
		<para>
			Summary:
		</para>

        <itemizedlist spacing="compact">
			<listitem>
				<para>
                    Dynamically creates and removes event patterns based on mobile user events received
                </para>
			</listitem>
			<listitem>
				<para>
                    Uses range matching for X and Y properties of mobile user events
                </para>
			</listitem>
		</itemizedlist>

    </sect1>
    
	<sect1 id="examples-qossla" revision="2">
        <title>QualityOfService</title>
            
        <para>
            This example develops some code for measuring quality-of-service levels such as for a service-level agreement (SLA).
            A SLA is a contract between 2 parties that defines service constraints such as maximum latency for service operations or error rates.
        </para>
            
        <para>                      
            The example measures and monitors operation latency and error counts per customer and operation. When 
            one of our operations oversteps these constraints, we want to be alerted right away. Additionally, we would like to have some monitoring in
            place that checks the health of our service and provides some information on how the operations are used.
        </para>

        <para>                      
            Some of the constraints we need to check are:
         </para>
            
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					That the latency (time to finish) of some of the operations is always less then X seconds.
				</para>
			</listitem>
			<listitem>
				<para>
					That the latency average is always less then Y seconds over Z operation invocations. 
				</para>
			</listitem>
		</itemizedlist>
		
		<para>
			The <literal>net.esper.example.qos_sla.events.OperationMeasurement</literal> event class with its latency and status properties is the main event used for the SLA analysis. The other event <literal>LatencyLimit</literal> serves to set latency limits on the fly.
		</para>

		<para>
			The <literal>net.esper.example.qos_sla.monitor.AverageLatencyMonitor</literal> creates an EQL statement that computes latency statistics per customer and operation for the
			last 100 events. The <literal>DynaLatencySpikeMonitor</literal> uses an event pattern to listen to spikes in latency with dynamically set limits. The <literal>ErrorRateMonitor</literal> uses the timer <literal>'at'</literal> operator in an event pattern that wakes up periodically and polls the error rate within the last 10 minutes. The <literal>ServiceHealthMonitor</literal> simply alerts when 3 errors occur, and the <literal>SpikeAndErrorMonitor</literal> alerts when a fixed latency is overstepped or an error status is reported.
		</para>

		<para>
			Summary:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
                    This example combines event patterns with EQL statements for event stream analysis.
                </para>
			</listitem>
			<listitem>
				<para>
                    Shows the use of the timer <literal>'at'</literal> operator and followed-by operator <literal>-&gt;</literal> in event patterns
                </para>
			</listitem>
			<listitem>
				<para>
                    Outlines basic EQL statements
                </para>
			</listitem>
			<listitem>
				<para>
                    Shows how to pull data out of EQL statements rather then subscribing to events a statement publishes
                </para>
			</listitem>
		</itemizedlist>
    </sect1>
    
	<sect1 id="examples-linearroad" revision="2">
        <title>LinearRoad</title>
        
        <para>
			The Linear Road example is a very incomplete implementation of the Stream Data Management Benchmark [3] by Standford University. 
        </para>

        <para>
			Linear Road simulates a toll system for the motor vehicle expressways of a large metropolitan area. The main event in this example is a car location report which the class
			<literal>net.esper.example.linearroad.CarLocEvent</literal> represents. Currently the event stream joins are performed by JUnit test classes in the <literal>examples/test</literal> folder. See the <literal>net.esper.example.linearroad.TestAccidentNotify</literal> and the <literal>TestCarSegmentCount</literal> classes. Please consider this a work in progress.
        </para>
        
		<para>
			Summary:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
                    Shows more complex joins between event streams.
                </para>
			</listitem>
		</itemizedlist>        
    </sect1>
    
	<sect1 id="examples-stocktick-rsi" revision="2">
        <title>StockTick RSI</title>
        
        <para>
			The RSI gives you the trend for a stock and for more complete explanation, you can visit the link: http://www.stockcharts.com/education/IndicatorAnalysis/indic_RSI.html.
		</para>
		
        <para>
			After a definite number of stock events, or accumulation period, the first RSI is computed. Then for each subsequent stock event, the RSI calculations use the previous period’s Average Gain and Loss to determine the “smoothed RSI”.
        </para>

		<para>
			Summary:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
                    Uses a simple event pattern with a filter which feeds a listener that computes the RSI, which publishes events containing the computed RSI.
                </para>
			</listitem>
		</itemizedlist>        
    </sect1>

</chapter>

