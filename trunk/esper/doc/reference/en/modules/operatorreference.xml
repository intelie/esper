<chapter id="epl-operator">
    <title>EPL Reference: Operators</title>
        		
		<para>
			Esper arithmetic and logical operator precedence follows Java standard arithmetic and logical operator precedence.
		</para>

		<sect1 id="epl-operator-ref-arithmetic">
			<title>Arithmetic Operators</title>

			<indexterm><primary>arithmetic operators</primary></indexterm>
			<indexterm><primary>operators</primary><secondary>arithmetic</secondary></indexterm>
			<para>
				The below table outlines the arithmetic operators available.
			</para>
	
			<table frame="topbot" id="epl-arith-operators" revision="2">
				<title>Syntax and results of arithmetic operators</title>
				<tgroup cols="2">
					<colspec colwidth="2.0*"/>
					<colspec colwidth="1.5*"/>
					<thead>
						<row>
							<entry>Operator</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>+, -</entry>
							<entry>
								<para>As unary operators they denote a positive or negative expression. As binary operators they add or subtract.</para>
							</entry>
						</row>
						<row>
							<entry>*, /</entry>
							<entry>
								<para>Multiplication and division are binary operators.</para>
							</entry>
						</row>
						<row>
							<entry>%</entry>
							<entry>
								<para>Modulo binary operator.</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</sect1>		
		
		<sect1 id="epl-operator-ref-logical">
			<title>Logical And Comparsion Operators</title>

			<indexterm><primary>logical and comparison operators</primary></indexterm>
			<indexterm><primary>operators</primary><secondary>logical and comparison</secondary></indexterm>
			<para>
				The below table outlines the logical and comparison operators available.
			</para>
	
			<table frame="topbot" id="epl-log-operators" revision="2">
				<title>Syntax and results of logical and comparison operators</title>
				<tgroup cols="2">
					<colspec colwidth="2.0*"/>
					<colspec colwidth="1.5*"/>
					<thead>
						<row>
							<entry>Operator</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>NOT</entry>
							<entry>
								<para>Returns true if the following condition is false, returns false if it is true.</para>
							</entry>
						</row>
						<row>
							<entry>OR</entry>
							<entry>
								<para>Returns true if either component condition is true, returns false if both are false.</para>
							</entry>
						</row>
						<row>
							<entry>AND</entry>
							<entry>
								<para>Returns true if both component conditions are true, returns false if either is false.</para>
							</entry>
						</row>
						<row>
							<entry>=, !=, &lt;, &gt; &lt;=, &gt;=,</entry>
							<entry>
								<para>Comparison.</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</sect1>		
		
		<sect1 id="epl-operator-ref-string">
			<title>Concatenation Operators</title>

			<indexterm><primary>concatenation operators</primary></indexterm>
			<indexterm><primary>operators</primary><secondary>concatenation</secondary></indexterm>
			<para>
				The below table outlines the concatenation operators available.
			</para>
	
			<table frame="topbot" id="epl-concat-operators" revision="2">
				<title>Syntax and results of concatenation operators</title>
				<tgroup cols="2">
					<colspec colwidth="2.0*"/>
					<colspec colwidth="1.5*"/>
					<thead>
						<row>
							<entry>Operator</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>||</entry>
							<entry>
								<para>Concatenates character strings</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</sect1>		

		<sect1 id="epl-operator-ref-binary">
			<title>Binary Operators</title>

			<indexterm><primary>binary operators</primary></indexterm>
			<indexterm><primary>operators</primary><secondary>binary</secondary></indexterm>
			<para>
				The below table outlines the binary operators available.
			</para>
	
			<table frame="topbot" id="epl-binary-operators" revision="2">
				<title>Syntax and results of binary operators</title>
				<tgroup cols="2">
					<colspec colwidth="2.0*"/>
					<colspec colwidth="1.5*"/>
					<thead>
						<row>
							<entry>Operator</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>&amp;</entry>
							<entry>
								<para>Bitwise AND if both operands are numbers; conditional AND if both operands are boolean</para>
							</entry>
						</row>
						<row>
							<entry>|</entry>
							<entry>
								<para>Bitwise OR if both operands are numbers; conditional OR if both operands are boolean</para>
							</entry>
						</row>
						<row>
							<entry>^</entry>
							<entry>
								<para>Bitwise exclusive OR (XOR)</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</sect1>		

		<sect1 id="epl-operator-ref-array">
			<title>Array Definition Operator</title>

			<indexterm><primary>array definition operator</primary></indexterm>
			<indexterm><primary>operators</primary><secondary>array definition</secondary></indexterm>
			<para>
				The <literal>{</literal> and <literal>}</literal> curly braces are array definition operators following the Java array initialization syntax. Arrays can be useful to pass to user-defined functions or to select array data in a select clause.
			</para>

			<para>
				Array definitions consist of zero or more expressions within curly braces. Any type of expression is allowed within array definitions including constants, arithmetic expressions or event properties. This is the syntax of an array definition:
			</para>
			<synopsis><emphasis>{</emphasis> [<emphasis>expression</emphasis> [,<emphasis>expression</emphasis>...]] }</synopsis>

			<para>
				Consider the next statement that returns an event property named <literal>actions</literal>. The engine populates the <literal>actions</literal> property as an array of <literal>java.lang.String</literal> values with a length of 2 elements. The first element of the array contains the <literal>observation</literal> property value and the second element the <literal>command</literal> property value of <literal>RFIDEvent</literal> events.
			</para>
			<programlisting><![CDATA[select {observation, command} as actions from RFIDEvent]]></programlisting>

			<para>
				The engine determines the array type based on the types returned by the expressions in the array definiton. For example, if all expressions in the array definition return integer values then the type of the array is <literal>java.lang.Integer[]</literal>. If the types returned by all expressions are compatible number types, such as integer and double values, the engine coerces the array element values and returns a suitable type, <literal>java.lang.Double[]</literal> in this example.
				The type of the array returned is <literal>Object[]</literal> if the types of expressions cannot be coerced or return object values. Null values can also be used in an array definition.
			</para>

			<para>
				Arrays can come in handy for use as parameters to user-defined functions:
			</para>
			<programlisting><![CDATA[select * from RFIDEvent where Filter.myFilter(zone, {1,2,3})]]></programlisting>
		</sect1>

		<sect1 id="epl-operator-ref-keyword-in">
			<title>The '<literal>in</literal>' Keyword</title>

			<indexterm><primary><literal>in</literal> set operator</primary></indexterm>
			<indexterm><primary>operators</primary><secondary><literal>in</literal></secondary></indexterm>
			<para>
				The <literal>in</literal> keyword determines if a given value matches any value in a list. The syntax of the keyword is:	
			</para>
			
			<synopsis><emphasis>test_expression</emphasis> [not] in (<emphasis>expression</emphasis> [,<emphasis>expression</emphasis>...] )</synopsis>
	
			<para>
				The <emphasis>test_expression</emphasis> is any valid expression. The keyword is followed by a list of expressions to test for a match. The optional <literal>not</literal> keyword specifies that the result of the predicate be negated.
			</para>
				
			<para>
				The result of an <literal>in</literal> expression is of type <literal>Boolean</literal>. If the value of <emphasis>test_expression</emphasis> is equal to any expression from the comma-separated list, the result value is <literal>true</literal>. Otherwise, the result value is <literal>false</literal>. All expressions must be of the same type as or a compatible type to <emphasis>test_expression</emphasis>.
			</para>

			<para>
				The next example shows how the <literal>in</literal> keyword can be applied to select certain command types of RFID events:
			</para>
			<programlisting><![CDATA[select * from RFIDEvent where command in ('OBSERVATION', 'SIGNAL')]]></programlisting>
			<para>
				The statement is equivalent to:
			</para>
			<programlisting><![CDATA[select * from RFIDEvent where command = 'OBSERVATION' or command = 'SIGNAL']]></programlisting>
		</sect1>		

		<sect1 id="epl-operator-ref-keyword-between">
			<title>The '<literal>between</literal>' Keyword</title>

			<indexterm><primary><literal>between</literal> operator</primary></indexterm>
			<indexterm><primary>operators</primary><secondary><literal>between</literal></secondary></indexterm>
			<para>
				The <literal>between</literal> keyword specifies a range to test. The syntax of the keyword is:	
			</para>
			
			<synopsis><emphasis>test_expression</emphasis> [not] between <emphasis>begin_expression</emphasis> and <emphasis>end_expression</emphasis></synopsis>
	
			<para>
				The <emphasis>test_expression</emphasis> is any valid expression and is the expression to test for in the range defined by <emphasis>begin_expression</emphasis> and <emphasis>end_expression</emphasis>. The <literal>not</literal> keyword specifies that the result of the predicate be negated. 
			</para>
				
			<para>
				The result of a <literal>between</literal> expression is of type <literal>Boolean</literal>. If the value of <emphasis>test_expression</emphasis> is greater then or equal to the value of <emphasis>begin_expression</emphasis> and less than or equal to the value of <emphasis>end_expression</emphasis>, the result is <literal>true</literal>. 
			</para>

			<para>
				The next example shows how the <literal>between</literal> keyword can be used to select events with a price between 55 and 60 (inclusive).
			</para>
			<programlisting><![CDATA[select * from StockTickEvent where price between 55 and 60]]></programlisting>
			<para>
				The equivalent expression without <literal>between</literal> is:
			</para>
			<programlisting><![CDATA[select * from StockTickEvent where price >= 55 and price <= 60]]></programlisting>
			<para>
				And also equivalent to:
			</para>
			<programlisting><![CDATA[]]>select * from StockTickEvent where price between 60 and 55</programlisting>
		</sect1>		

		<sect1 id="epl-operator-ref-keyword-like">
			<title>The '<literal>like</literal>' Keyword</title>

			<indexterm><primary><literal>like</literal> operator</primary></indexterm>
			<indexterm><primary>operators</primary><secondary><literal>like</literal></secondary></indexterm>
			<para>
				The <literal>like</literal> keyword provides standard SQL pattern matching. SQL pattern matching allows you to use <literal>'_'</literal> to match any single character and <literal>'%'</literal> to match an arbitrary number of characters (including zero characters). In Esper, SQL patterns are case-sensitive by default. The syntax of <literal>like</literal> is:	
			</para>
			
			<synopsis><emphasis>test_expression</emphasis> [not] like <emphasis>pattern_expression</emphasis> [escape <emphasis>string_literal</emphasis>]</synopsis>
	
			<para>
				The <emphasis>test_expression</emphasis> is any valid expression yielding a String-type or a numeric result. The optional <literal>not</literal> keyword specifies that the result of the predicate be negated. The <literal>like</literal> keyword is followed by any valid standard SQL <emphasis>pattern_expression</emphasis> yielding a String-typed result. The optional <literal>escape</literal> keyword signals the escape character to escape <literal>'_'</literal> and <literal>'%'</literal> values in the pattern.
			</para>
				
			<para>
				The result of a <literal>like</literal> expression is of type <literal>Boolean</literal>. If the value of <emphasis>test_expression</emphasis> matches the <emphasis>pattern_expression</emphasis>, the result value is <literal>true</literal>. Otherwise, the result value is <literal>false</literal>.
			</para>

			<para>
				An example for the <literal>like</literal> keyword is below.
			</para>
			<programlisting><![CDATA[select * from PersonLocationEvent where name like '%Jack%']]></programlisting>

			<para>
				The escape character can be defined as follows. In this example the where-clause matches events where the suffix property is a single <literal>'_'</literal> character.
			</para>
			<programlisting><![CDATA[select * from PersonLocationEvent where suffix like '!_' escape '!']]></programlisting>
		</sect1>		

		<sect1 id="epl-operator-ref-keyword-regexp">
			<title>The '<literal>regexp</literal>' Keyword</title>

			<indexterm><primary><literal>regexp</literal> operator</primary></indexterm>
			<indexterm><primary>operators</primary><secondary><literal>regexp</literal></secondary></indexterm>
			<para>
				The <literal>regexp</literal> keyword is a form of pattern matching based on regular expressions implemented through the Java <literal>java.util.regex</literal> package. The syntax of <literal>regexp</literal> is:	
			</para>
			
			<synopsis><emphasis>test_expression</emphasis> [not] regexp <emphasis>pattern_expression</emphasis></synopsis>
	
			<para>
				The <emphasis>test_expression</emphasis> is any valid expression yielding a String-type or a numeric result. The optional <literal>not</literal> keyword specifies that the result of the predicate be negated. The <literal>regexp</literal> keyword is followed by any valid regular expression <emphasis>pattern_expression</emphasis> yielding a String-typed result.
			</para>
				
			<para>
				The result of a <literal>regexp</literal> expression is of type <literal>Boolean</literal>. If the value of <emphasis>test_expression</emphasis> matches the regular expression <emphasis>pattern_expression</emphasis>, the result value is <literal>true</literal>. Otherwise, the result value is <literal>false</literal>.
			</para>

			<para>
				An example for the <literal>regexp</literal> keyword is below.
			</para>
			<programlisting><![CDATA[select * from PersonLocationEvent where name regexp '*Jack*']]></programlisting>
		</sect1>		

</chapter>