<chapter id="extension">

    <title>Extension and Plug-in</title>

    <sect1 id="ext-intro" revision="1">
        <title>Overview</title>
        
        <para>
			Esper can currently be extended by these means:
        </para>
        
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					User-defined functions - these can be used anywhere where expressions are allowed, please see <xref linkend="eql-function-user-defined"/>
				</para>
			</listitem>
			<listitem>
				<para>
					Custom-developed Plug-in Views
				</para>
			</listitem>
		</itemizedlist>
    </sect1>
    
    <sect1 id="custom-views" revision="1">
        <title>Custom View Implementation</title>
        
        <para>
			Views in Esper are used to derive information from an event stream, and to represent data windows onto an event stream. This chapter describes how to plug-in a new, custom view. 
        </para>
        
        <para>
			The following steps are required to develop and use a custom view with Esper. 
        </para>
			
		<orderedlist spacing="compact">
			<listitem>
				<para>
					Implement a view factory class. View factories are classes that accept and check view parameters and instantiate the appropriate view class.
				</para>
			</listitem>
			<listitem>
				<para>
					Implement a view class. A view class commonly represents a data window or derives new information from a stream.
				</para>
			</listitem>
			<listitem>
				<para>
					Configure the view factory class supplying a view namespace and name in the engine configuration file.
				</para>
			</listitem>
		</orderedlist>

        <para>
			The example view factory and view class that are used in this chapter can be found in the test source folder in the package <literal>net.esper.regression.client</literal> by the name <literal>MyTrendSpotterViewFactory</literal> and <literal>MyTrendSpotterView</literal>.
        </para>

        <para>
			Views can make use of the following engine services available via <literal>StatementServiceContext</literal>:
        </para>
        
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					The <literal>SchedulingService</literal> interface allows views to schedule timer callbacks to a view
				</para>
			</listitem>
			<listitem>
				<para>
					The <literal>EventAdapterService</literal> interface allows views to create new event types and event instances of a given type. 
				</para>
			</listitem>
			<listitem>
				<para>
					The <literal>StatementStopService</literal> interface allows view to register a callback that the engine invokes to indicate that the view's statement has been stopped
				</para>
			</listitem>
		</itemizedlist>

        <para>
			Note that custom views may use engine services and APIs that can be subject to change between major releases. The engine services discussed above and view APIs are considered part of the engine internal public API and are stable. Any changes to such APIs are disclosed through the release change logs and history. Please also consider contributing your custom view to the Esper project team by submitting the view code through the mailing list or via a JIRA issue.
        </para>

		<sect2 id="custom-views-viewfactory" revision="1">
			<title>Implementing a View Factory</title>
			
			<para>
				A view factory class is responsible for the following functions:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Accept zero, one or more view parameters. Validate and parse the parameters as required.
					</para>
				</listitem>
				<listitem>
					<para>
						Validate that the parameterized view is compatible with its parent view. For example, validate that field names are valid in the event type of the parent view.
					</para>
				</listitem>
				<listitem>
					<para>
						Instantiate the actual view class.
					</para>
				</listitem>
				<listitem>
					<para>
						Provide information about the event type of events posted by the view.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				View factory classes simply subclass <literal>net.esper.view.ViewFactorySupport</literal>:
			</para>
			<programlisting><![CDATA[public class MyTrendSpotterViewFactory extends ViewFactorySupport { ...]]></programlisting>

			<para>
				Your view factory class must implement the <literal>setViewParameters</literal> method to accept and parse view parameters. The next code snippet shows an implementation of this method. The code obtains a single field name
				parameter from the parameter list passed to the method:
			</para>
			<programlisting><![CDATA[public class MyTrendSpotterViewFactory extends ViewFactorySupport {
  private String fieldName;
  private EventType eventType;

  public void setViewParameters(ViewFactoryContext viewFactoryContext, 
                          List<Object> viewParameters) throws ViewParameterException
  {
    String errorMessage = "'Trend spotter' view require a single field name as a parameter";
    if (viewParameters.size() != 1) {
      throw new ViewParameterException(errorMessage);
    }

    if (!(viewParameters.get(0) instanceof String)) {
      throw new ViewParameterException(errorMessage);
    }

    fieldName = (String) viewParameters.get(0);
  }
  ...]]></programlisting>
    
		<para>
			After the engine supplied view parameters to the factory, the engine will ask the view to attach to its parent view and validate any field name parameters against the parent view's event type. If the view will be generating events of a different type then the events generated by the parent view, then the view factory can create the new event type in this method:
		</para>

		<programlisting><![CDATA[public void attach(EventType parentEventType, 
		StatementServiceContext statementServiceContext, 
		ViewFactory optionalParentFactory, 
		List<ViewFactory> parentViewFactories) 
		    throws ViewAttachException {
  String result = PropertyCheckHelper.checkNumeric(parentEventType, fieldName);
  if (result != null) {
    throw new ViewAttachException(result);
  }

  // create new event type
  Map<String, Class> eventTypeMap = new HashMap<String, Class>();
  eventTypeMap.put(PROPERTY_NAME, Long.class);
  eventType = statementServiceContext.getEventAdapterService().
                         createAnonymousMapType(eventTypeMap);
}]]></programlisting>

		<para>
			Finally, the engine asks the view factory to create a view instance:
		</para>

		<programlisting><![CDATA[public View makeView(StatementServiceContext statementServiceContext) {
  return new MyTrendSpotterView(statementServiceContext, fieldName);
}]]></programlisting>
		</sect2>
		
		<sect2 id="custom-views-view" revision="1">
			<title>Implementing a View</title>
			
			<para>
				A view class is responsible for:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						The <literal>setParent</literal> method informs the view of the parent view's event type
					</para>
				</listitem>
				<listitem>
					<para>
						The <literal>update</literal> method receives insert streams and remove stream events from its parent view
					</para>
				</listitem>
				<listitem>
					<para>
						The <literal>iterator</literal> method supplies an (optional) iterator to allow an application to pull or request results from an <literal>EPStatement</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						The <literal>cloneView</literal> method must make a configured copy of the view to enable the view to work in a grouping context together with a <literal>std:groupby</literal> parent view
					</para>
				</listitem>
			</itemizedlist>

			<para>
				View classes simply subclass <literal>net.esper.view.ViewSupport</literal>:
			</para>
			<programlisting><![CDATA[public class MyTrendSpotterView extends ViewSupport { ...]]></programlisting>

			<para>
				The view class must implement the <literal>setParent(Viewable parent)</literal> method. This is an opportunity for the view to initialize and obtain a fast event property getter for later use to obtain event property values. The next code snippet shows an implementation of this method:
			</para>
			<programlisting><![CDATA[public void setParent(Viewable parent) {
  super.setParent(parent);
  if (parent != null)  {
    fieldGetter = parent.getEventType().getGetter(fieldName);
  }
}
]]></programlisting>

			<para>
				Your <literal>update</literal> method will be processing incoming (insert stream) and outgoing (remove stream) events, as well as providing incoming and outgoing events to child views. The convention required of your update method implementation is that the view releases any insert stream events which the view generates as semantically-equal remove stream events at a later time. A sample <literal>update</literal> method implementation that computes a number of events in an upward trend is shown below:
			</para>
			<programlisting><![CDATA[public final void update(EventBean[] newData, EventBean[] oldData) {
  EventBean oldDataPost = populateMap(trendcount);

  // add data points
  if (newData != null) {
    for (int i = 0; i < newData.length; i++) {
      double dataPoint = ((Number) fieldGetter.get(newData[i])).doubleValue();

      if (lastDataPoint == null) {
        trendcount = 1L;
      }
      else if (lastDataPoint < dataPoint) {
        trendcount++;
      }
      else if (lastDataPoint > dataPoint) {
        trendcount = 0L;
      }
      lastDataPoint = dataPoint;
    }
  }

  if (this.hasViews())	{
    EventBean newDataPost = populateMap(trendcount);
    updateChildren(new EventBean[] {newDataPost}, new EventBean[] {oldDataPost});
  }
}]]></programlisting>

			<para>
				This <literal>update</literal> method must adhere to the following view conventions, to prevent memory leaks and to enable correct behavior within the engine:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Views must post a remove stream in the form of old data to child views. The remove stream must consist of the same event reference(s) posted as insert stream (new data).
					</para>
				</listitem>
			</itemizedlist>

			<para>
				The engine can provide a callback to the view indicating when a statement using the view is stopped. The callback is available to the view via the <literal>net.esper.view.StatementStopCallback</literal> interface. Your
				view code must subscribe to the stop callback in order for the engine to invoke the callback:
			</para>
			
			<programlisting><![CDATA[statementContext.getStatementStopService().addSubscriber(this);]]></programlisting>

			<para>
				Please refer to the sample views for a code sample on how to implement <literal>iterator</literal> and <literal>cloneView</literal> methods.
			</para>

		</sect2>
		
		<sect2 id="custom-views-config" revision="1">
			<title>Configuring View Namespace and Name</title>
			
			<para>
				The view factory class name as well as the view namespace and name for the new view must be added to the engine configuration via the configuration API or using the XML configuration file. The configuration shown below is XML however the same options are available through the configuration API:
			</para>
		
			<programlisting><![CDATA[<esper-configuration
  <plugin-view namespace="custom" name="trendspotter" 
      factory-class="net.esper.regression.view.MyTrendSpotterViewFactory" /> 
</esper-configuration>]]></programlisting>

			<para>
				The new view is now ready to use in a statement:
			</para>		
			<programlisting><![CDATA[select * from StockTick.custom:trendspotter('price')]]></programlisting>

			<para>
				Note that the view must implement the <literal>copyView</literal> method to enable the view to work in a grouping context as shown in the next statement:
			</para>		
			<programlisting><![CDATA[select * from StockTick.std:groupby('symbol').custom:trendspotter('price')]]></programlisting>

		</sect2>
    </sect1>

    <sect1 id="custom-aggregation-function" revision="1">
        <title>Custom Aggregation Functions</title>
        
        <para>
			Aggregation functions aggregate event property values or expression results obtained from one or more streams. Examples for built-in aggregation functions are <literal>count(*)</literal>, <literal>sum(price * volume)</literal> or <literal>avg(distinct volume)</literal>.
        </para>
        
        <para>
			The optional keyword <literal>distinct</literal> ensures that only distinct (unique) values are aggregated and duplicate values are ignored by the aggregation function. Custom plug-in aggregation functions do not need to implement the logic to handle <literal>distinct</literal> values. This is because when the engine encounters the <literal>distinct</literal> keyword, it eliminates any non-distinct values before passing the value for aggregation to the custom aggregation function.
        </para>

        <para>
			The following steps are required to develop and use a custom aggregation function with Esper. 
        </para>
			
		<orderedlist spacing="compact">
			<listitem>
				<para>
					Implement an aggregation function class.
				</para>
			</listitem>
			<listitem>
				<para>
					Register the aggregation function class with the engine by supplying a function name, via the engine configuration file or the configuration API.
				</para>
			</listitem>
		</orderedlist>

        <para>
			The code for the example aggregation function as shown in this chapter can be found in the test source folder in the package <literal>net.esper.regression.client</literal> by the name <literal>MyConcatAggregationFunction</literal>. The sample function simply concatenates string-type values.
        </para>

		<sect2 id="custom-aggregation-implementing" revision="1">
			<title>Implementing an Aggregation Function</title>
			
			<para>
				An aggregation function class is responsible for the following functions:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Implement a <literal>validate</literal> method that validates the value type of the data points that the function must process.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement a <literal>getValueType</literal> method that returns the type of the aggregation value generated by the function. For example, the built-in <literal>count</literal> aggregation function returns <literal>Long.class</literal> as it generates <literal>long</literal> -typed values.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement an <literal>enter</literal> method that the engine invokes to add a data point into the aggregation, when an event enters a data window
					</para>
				</listitem>
				<listitem>
					<para>
						Implement a <literal>leave</literal> method that the engine invokes to remove a data point from the aggregation, when an event leaves a data window
					</para>
				</listitem>
				<listitem>
					<para>
						Implement a <literal>getValue</literal> method that returns the current value of the aggregation. 
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Aggregation function classes simply subclass <literal>net.esper.eql.agg.AggregationSupport</literal>:
			</para>
			<programlisting><![CDATA[public class MyConcatAggregationFunction extends AggregationSupport { ...]]></programlisting>

			<para>
				The engine generally constructs one instance of the aggregation function class for each time the function is listed in a statement, however the engine may decide to reduce the number of aggregation class instances if it finds equivalent aggregations. The constructor initializes the aggregation function:
			</para>
			<programlisting><![CDATA[public class MyConcatAggregationFunction extends AggregationSupport {
  private final static char DELIMITER = ' ';
  private StringBuilder builder;
  private String delimiter;

  public MyConcatAggregationFunction()
  {
    super();
    builder = new StringBuilder();
    delimiter = "";
  }
  ...]]></programlisting>

			<para>
				An aggregation function must provide an implementation of the <literal>validate</literal> method that is passed the result type of the expression within the aggregation function. Since the example concatenation function requires string types, it implements a type check:
			</para>
			<programlisting><![CDATA[public void validate(Class childNodeType) {
  if (childNodeType != String.class) {
    throw new IllegalArgumentException("Concat aggregation requires a String parameter");
  }
}]]></programlisting>

			<para>
				The <literal>enter</literal> method adds a datapoint to the current aggregation value. The example <literal>enter</literal> method shown below adds a delimiter and the string value to a string buffer:
			</para>
			<programlisting><![CDATA[public void enter(Object value) {
  if (value != null) {
    builder.append(delimiter);
    builder.append(value.toString());
    delimiter = String.valueOf(DELIMITER);
  }
}]]></programlisting>

			<para>
				Conversly, the <literal>leave</literal> method removes a datapoint from the current aggregation value. The example <literal>leave</literal> method removes from the string buffer:
			</para>
			<programlisting><![CDATA[public void leave(Object value) {
  if (value != null) {
    builder.delete(0, value.toString().length() + 1);
  }
}]]></programlisting>

			<para>
				In order for the engine to validate the type returned by the aggregation function against the types expected by enclosing expressions, the <literal>getValueType</literal> must return the result type of any values produced by the aggregation function:
			</para>
			<programlisting><![CDATA[public Class getValueType() {
  return String.class;
}]]></programlisting>

			<para>
				Finally, the engine obtains the current aggregation value by means of the <literal>getValue</literal> method:
			</para>
			<programlisting><![CDATA[public Object getValue() {
  return builder.toString();
}]]></programlisting>

		</sect2>

		<sect2 id="custom-aggregation-config" revision="1">
			<title>Configuring Aggregation Function Name</title>
			
			<para>
				The aggregation function class name as well as the function name for the new aggregation function must be added to the engine configuration via the configuration API or using the XML configuration file. The configuration shown below is XML however the same options are available through the configuration API:
			</para>
		
			<programlisting><![CDATA[<esper-configuration
  <plugin-aggregation-function name="concat" 
    function-class="net.esper.regression.client.MyConcatAggregationFunction" />
</esper-configuration>]]></programlisting>

			<para>
				The new aggregation function is now ready to use in a statement:
			</para>		
			<programlisting><![CDATA[select concat(symbol) from StockTick.win:length(3)]]></programlisting>

		</sect2>
	</sect1>

    <sect1 id="custom-pattern-guard" revision="1">
        <title>Custom Pattern Guard</title>
        
        <para>
			Pattern guards are pattern objects that control the lifecycle of the guarded sub-expression, and can filter the events fired by the subexpression. 
        </para>
        
        <para>
			The following steps are required to develop and use a custom guard object with Esper. 
        </para>
			
		<orderedlist spacing="compact">
			<listitem>
				<para>
					Implement a guard factory class, responsible for creating guard object instances.
				</para>
			</listitem>
			<listitem>
				<para>
					Implement a guard class.
				</para>
			</listitem>
			<listitem>
				<para>
					Register the guard factory class with the engine by supplying a namespace and name, via the engine configuration file or the configuration API.
				</para>
			</listitem>
		</orderedlist>

        <para>
			The code for the example guard object as shown in this chapter can be found in the test source folder in the package <literal>net.esper.regression.client</literal> by the name <literal>MyCountToPatternGuardFactory</literal>. The sample guard discussed here counts the number of events occurring up to a maximum number of events, and end the sub-expression when that maximum is reached.
        </para>

		<sect2 id="custom-pattern-guard-factory-implementing" revision="1">
			<title>Implementing a Guard Factory</title>
			
			<para>
				A guard factory class is responsible for the following functions:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Implement a <literal>setGuardParameters</literal> method that validates guard parameters.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement a <literal>makeGuard</literal> method that constructs a new guard instance.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Guard factory classes subclass <literal>net.esper.pattern.guard.GuardFactorySupport</literal>:
			</para>
			<programlisting><![CDATA[public class MyCountToPatternGuardFactory extends GuardFactorySupport { ...]]></programlisting>

			<para>
				The engine constructs one instance of the guard factory class for each time the guard is listed in a statement. 
			</para>
				
			<para>
				The guard factory class implements the <literal>setGuardParameters</literal> method that is passed the parameters to the guard as supplied by the statement. It verifies the guard parameters, similar to the code snippet shown next. Our example counter guard takes a single numeric parameter:
			</para>
			<programlisting><![CDATA[public void setGuardParameters(List<Object> guardParameters) throws GuardParameterException {
  if (guardParameters.size() != 1) {
    throw new GuardParameterException("Count-to guard takes a single integer parameter");
  }
  if (!(guardParameters.get(0) instanceof Integer)) {
    throw new GuardParameterException("Count-to guard takes a single integer parameter");
  }
  numCountTo = (Integer) guardParameters.get(0);
}]]></programlisting>

			<para>
				The <literal>makeGuard</literal> method is called by the engine to create a new guard instance. The example <literal>makeGuard</literal> method shown below passes the maximum count of events to the guard instance. It also passes a <literal>Quitable</literal> implementation to the guard instance. The guard uses <literal>Quitable</literal> to indicate that the sub-expression contained within must stop (quit) listening for events.
			</para>
			<programlisting><![CDATA[public Guard makeGuard(PatternContext context, Quitable quitable, 
  Object stateNodeId, Object guardState) {
    return new MyCountToPatternGuard(numCountTo, quitable);
}]]></programlisting>

		</sect2>

		<sect2 id="custom-pattern-guard-implementing" revision="1">
			<title>Implementing a Guard Class</title>
			
			<para>
				A guard class has the following responsibilities:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Provides a <literal>startGuard</literal> method that initalizes the guard.
					</para>
				</listitem>
				<listitem>
					<para>
						Provides a <literal>stopGuard</literal> method that stops the guard, called by the engine when the whole pattern is stopped, or the sub-expression containing the guard is stopped.
					</para>
				</listitem>
				<listitem>
					<para>
						Provides an <literal>inspect</literal> method that the pattern engine invokes to determine if the guard lets matching events pass for further evaluation by the containing expression.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Guard classes subclass <literal>net.esper.pattern.guard.GuardSupport</literal> as shown here:
			</para>
			<programlisting><![CDATA[public abstract class GuardSupport implements Guard { ...]]></programlisting>

			<para>
				The engine invokes the guard factory class to construct an instance of the guard class for each new sub-expression instance within a statement.
			</para>

			<para>
				A guard class must provide an implementation of the <literal>startGuard</literal> method that the pattern engine invokes to start a guard instance. In our example, the method resets the guard's counter to zero:
			</para>
			<programlisting><![CDATA[public void startGuard() {
  counter = 0;
}]]></programlisting>

			<para>
				The pattern engine invokes the <literal>inspect</literal> method for each time the sub-expression indicates a new event result. Our example guard needs to count the number of events matched, and quit if the maximum number is reached:
			</para>
			<programlisting><![CDATA[public boolean inspect(MatchedEventMap matchEvent) {
  counter++;
  if (counter > numCountTo) {
    quitable.guardQuit();
    return false;
  }
  return true;
}]]></programlisting>

			<para>
				The <literal>inspect</literal> method returns true for events that pass the guard, and false for events that should not pass the guard.
			</para>

		</sect2>

		<sect2 id="custom-pattern-guard-config" revision="1">
			<title>Configuring Guard Namespace and Name</title>
			
			<para>
				The guard factory class name as well as the namespace and name for the new guard must be added to the engine configuration via the configuration API or using the XML configuration file. The configuration shown below is XML however the same options are available through the configuration API:
			</para>
		
			<programlisting><![CDATA[<esper-configuration
  <plugin-pattern-guard namespace="myplugin" name="count_to" 
      factory-class="net.esper.regression.client.MyCountToPatternGuardFactory"/>
</esper-configuration>]]></programlisting>

			<para>
				The new guard is now ready to use in a statement. The next pattern statement detects the first 10 MyEvent events:
			</para>		
			<programlisting><![CDATA[select * from pattern [(every MyEvent) where myplugin:count_to(10)]]]></programlisting>

			<para>
				Note that the <literal>every</literal> keyword was placed within parentheses to ensure the guard controls the repeated matching of events.
			</para>		

		</sect2>
	</sect1>

    <sect1 id="custom-pattern-observer" revision="1">
        <title>Custom Pattern Observer</title>
        
        <para>
			Pattern observers are pattern objects that are executed as part of a pattern expression and can observe events or test conditions. Examples for built-in observers are <literal>timer:at</literal> and <literal>timer:interval</literal>. Some suggested uses of observer objects are: 
        </para>
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Implement custom scheduling logic using the engine's own scheduling and timer services
				</para>
			</listitem>
			<listitem>
				<para>
					Test conditions related to prior events matching an expression
				</para>
			</listitem>
		</itemizedlist>
        
        <para>
			The following steps are required to develop and use a custom observer object within pattern statements: 
        </para>
			
		<orderedlist spacing="compact">
			<listitem>
				<para>
					Implement an observer factory class, responsible for creating observer object instances.
				</para>
			</listitem>
			<listitem>
				<para>
					Implement an observer class.
				</para>
			</listitem>
			<listitem>
				<para>
					Register an observer factory class with the engine by supplying a namespace and name, via the engine configuration file or the configuration API.
				</para>
			</listitem>
		</orderedlist>

        <para>
			The code for the example observer object as shown in this chapter can be found in the test source folder in package <literal>net.esper.regression.client</literal> by the name <literal>MyFileExistsObserver</literal>. The sample observer discussed here very simply checks if a file exists, using the filename supplied by the pattern statement, and via the <literal>java.io.File</literal> class.
        </para>

		<sect2 id="custom-pattern-observer-factory-implementing" revision="1">
			<title>Implementing an Observer Factory</title>
			
			<para>
				An observer factory class is responsible for the following functions:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Implement a <literal>setObserverParameters</literal> method that validates observer parameters.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement a <literal>makeObserver</literal> method that constructs a new observer instance.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Observer factory classes subclass <literal>net.esper.pattern.observer.ObserverFactorySupport</literal>:
			</para>
			<programlisting><![CDATA[public class MyFileExistsObserverFactory extends ObserverFactorySupport { ...]]></programlisting>

			<para>
				The engine constructs one instance of the observer factory class for each time the observer is listed in a statement. 
			</para>
				
			<para>
				The observer factory class implements the <literal>setObserverParameters</literal> method that is passed the parameters to the observer as supplied by the statement. It verifies the observer parameters, similar to the code snippet shown next. Our example file-exists observer takes a single string parameter:
			</para>
			<programlisting><![CDATA[public void setObserverParameters(List<Object> observerParameters) 
			throws ObserverParameterException {
  String message = "File exists observer takes a single string filename parameter";
  if (observerParameters.size() != 1) {
    throw new ObserverParameterException(message);
  }
  if (!(observerParameters.get(0) instanceof String)) {
    throw new ObserverParameterException(message);
  }
  
  filename = observerParameters.get(0).toString();
}]]></programlisting>

			<para>
				The pattern engine calls the <literal>makeObserver</literal> method to create a new observer instance. The example <literal>makeObserver</literal> method shown below passes parameters to the observer instance:
			</para>
			<programlisting><![CDATA[public EventObserver makeObserver(PatternContext context, 
			MatchedEventMap beginState, 
			ObserverEventEvaluator observerEventEvaluator, 
			Object stateNodeId, 
			Object observerState) {
  return new MyFileExistsObserver(beginState, observerEventEvaluator, filename);
}]]></programlisting>

			<para>
				The <literal>ObserverEventEvaluator</literal> parameter allows an observer to indicate events, and to indicate change of truth value to permanently false. Use this interface to indicate when your observer has received or witnessed an event, or changed it's truth value to true or permanently false.
			</para>

			<para>
				The <literal>MatchedEventMap</literal> parameter provides a Map of all matching events for the expression prior to the observer's start. For example, consider a pattern as below:
			</para>
			<programlisting><![CDATA[a=MyEvent -> myplugin:my_observer(...)]]></programlisting>

			<para>
				The above pattern tagged the MyEvent instance with the tag "a". The pattern engine starts an instance of <literal>my_observer</literal> when it receives the first MyEvent. The observer can query the <literal>MatchedEventMap</literal> using  "a" as a key and obtain the tagged event.
			</para>
		</sect2>

		<sect2 id="custom-pattern-observer-implementing" revision="1">
			<title>Implementing an Observer Class</title>
			
			<para>
				An observer class has the following responsibilities:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Provides a <literal>startObserve</literal> method that starts the observer.
					</para>
				</listitem>
				<listitem>
					<para>
						Provides a <literal>stopObserve</literal> method that stops the observer, called by the engine when the whole pattern is stopped, or the sub-expression containing the observer is stopped.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Observer classes subclass <literal>net.esper.pattern.observer.ObserverSupport</literal> as shown here:
			</para>
			<programlisting><![CDATA[public class MyFileExistsObserver implements EventObserver { ...]]></programlisting>

			<para>
				The engine invokes the observer factory class to construct an instance of the observer class for each new sub-expression instance within a statement.
			</para>

			<para>
				An observer class must provide an implementation of the <literal>startObserve</literal> method that the pattern engine invokes to start an observer instance. In our example, the observer checks for the presence of a file and indicates the truth value to the remainder of the expression:
			</para>
			<programlisting><![CDATA[public void startObserve() {
  File file = new File(filename);
  if (file.exists()) {
    observerEventEvaluator.observerEvaluateTrue(beginState);
  } 
  else {
    observerEventEvaluator.observerEvaluateFalse(); 
  }
}]]></programlisting>

			<para>
				Note the observer passes the <literal>ObserverEventEvaluator</literal> an instance of <literal>MatchedEventMap</literal>. The observer can also create one or more new events and pass these events through the Map to the remaining expressions in the pattern.
			</para>

		</sect2>

		<sect2 id="custom-pattern-observer-config" revision="1">
			<title>Configuring Observer Namespace and Name</title>
			
			<para>
				The observer factory class name as well as the namespace and name for the new observer must be added to the engine configuration via the configuration API or using the XML configuration file. The configuration shown below is XML however the same options are available through the configuration API:
			</para>
		
			<programlisting><![CDATA[<esper-configuration
  <plugin-pattern-observer namespace="myplugin" name="file_exists" 
    factory-class="net.esper.regression.client.MyFileExistsObserverFactory" />
</esper-configuration>]]></programlisting>

			<para>
				The new observer is now ready to use in a statement. The next pattern statement checks every 10 seconds if the given file exists, and indicates to the listener when the file is found.
			</para>		
			<programlisting><![CDATA[select * from pattern [every timer:interval(10 sec) -> myplugin:file_exists("myfile.txt")]]]></programlisting>

		</sect2>
	</sect1>

</chapter>

